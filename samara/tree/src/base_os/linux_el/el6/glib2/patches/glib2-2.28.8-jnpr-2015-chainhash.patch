diff -uNr glib-2.28.8-orig/gio/fen/fen-helper.c glib-2.28.8-new/gio/fen/fen-helper.c
--- glib-2.28.8-orig/gio/fen/fen-helper.c	2011-02-17 14:02:50.000000000 -0800
+++ glib-2.28.8-new/gio/fen/fen-helper.c	2015-06-02 19:06:38.000000000 -0700
@@ -43,6 +43,29 @@
 
 G_LOCK_EXTERN (fen_lock);
 
+typedef struct process_node_args {
+  gpointer sub;
+  gboolean emit;
+  gint event;
+} process_node_args_t;
+
+static void
+cb_process_node(gpointer key, gpointer value, gpointer user_data)
+{
+  process_node_args_t *d = (process_node_args_t *)user_data;
+  node_t *child = (node_t *)value;
+
+#ifdef GIO_COMPILATION
+  /* GIO initially doesn't emit created/existed events. */
+  /* g_file_monitor_emit_event(G_FILE_MONITOR(sub), child->gfile,
+                               NULL, event); */
+#else
+  gam_server_emit_one_event(NODE_NAME(child),
+                            gam_subscription_is_dir(d->sub), d->event,
+                            d->sub, 1);
+#endif
+}
+
 /* misc */
 static void
 scan_children_init(node_t *f, gpointer sub)
@@ -65,20 +88,12 @@
         /* GIO initially doesn't emit created/existed events. */
         node_create_children_snapshot(f, event, emit);
     } else {
-        GHashTableIter iter;
-        gpointer value;
+        process_node_args_t d;
+        d.sub = sub;
+        d.emit = emit;
+        d.event = event;
 
-        g_hash_table_iter_init (&iter, f->children);
-        while (g_hash_table_iter_next (&iter, NULL, &value)) {
-            node_t *child = (node_t *)value;
-
-#ifdef GIO_COMPILATION
-            /* GIO initially doesn't emit created/existed events. */
-            /* g_file_monitor_emit_event(G_FILE_MONITOR(sub), child->gfile, NULL, event); */
-#else
-            gam_server_emit_one_event(NODE_NAME(child), gam_subscription_is_dir(sub), event, sub, 1);
-#endif
-        }
+        g_hash_table_foreach(f->children, cb_process_node, &d);
     }
 }
 
diff -uNr glib-2.28.8-orig/gio/fen/fen-node.c glib-2.28.8-new/gio/fen/fen-node.c
--- glib-2.28.8-orig/gio/fen/fen-node.c	2011-02-17 14:02:50.000000000 -0800
+++ glib-2.28.8-new/gio/fen/fen-node.c	2015-06-02 19:09:22.000000000 -0700
@@ -100,11 +100,24 @@
     return FALSE;
 }
 
+typedef struct cb_node_traverse_args {
+  void (*traverse_cb)(node_t*, gpointer);
+  gpointer user_data;
+} cb_node_traverse_args_t;
+
+static void
+cb_node_traverse(gpointer key, gpointer value, gpointer user_data)
+{
+  cb_node_traverse_args_t *d = (cb_node_traverse_args_t *) user_data;
+  node_traverse((node_t *)value, d->traverse_cb, d->user_data);
+}
+
 void
 node_traverse (node_t* node, void(*traverse_cb)(node_t*, gpointer), gpointer user_data)
 {
-    GHashTableIter iter;
-    gpointer value;
+    cb_node_traverse_args_t d;
+    d.traverse_cb = traverse_cb;
+    d.user_data = user_data;
 
     g_assert(traverse_cb);
     if (node == NULL) {
@@ -115,10 +128,7 @@
         traverse_cb(node, user_data);
     }
 
-    g_hash_table_iter_init (&iter, node->children);
-    while (g_hash_table_iter_next (&iter, NULL, &value)) {
-        node_traverse((node_t *)value, traverse_cb, user_data);
-    }
+    g_hash_table_foreach(node->children, cb_node_traverse, &d);
 }
 
 node_t*
diff -uNr glib-2.28.8-orig/gio/gapplication.c glib-2.28.8-new/gio/gapplication.c
--- glib-2.28.8-orig/gio/gapplication.c	2011-06-05 16:18:49.000000000 -0700
+++ glib-2.28.8-new/gio/gapplication.c	2015-06-02 18:30:38.000000000 -0700
@@ -1345,6 +1345,18 @@
          g_action_group_has_action (application->priv->actions, action_name);
 }
 
+typedef struct key_data {
+  gint i;
+  gchar **keys;
+} key_data_t;
+
+static void
+copy_key(gpointer key, gpointer value, gpointer user_data)
+{
+  key_data_t *d = (key_data_t *)user_data;
+  d->keys[d->i++] = g_strdup(key);
+}
+
 static gchar **
 g_application_list_actions (GActionGroup *action_group)
 {
@@ -1354,21 +1366,19 @@
 
   if (application->priv->remote_actions != NULL)
     {
-      GHashTableIter iter;
-      gint n, i = 0;
-      gchar **keys;
-      gpointer key;
+      gint n;
+      key_data_t d;
 
+      d.i = 0;
       n = g_hash_table_size (application->priv->remote_actions);
-      keys = g_new (gchar *, n + 1);
+      d.keys = g_new (gchar *, n + 1);
+
+      g_hash_table_foreach(application->priv->remote_actions, copy_key, &d);
 
-      g_hash_table_iter_init (&iter, application->priv->remote_actions);
-      while (g_hash_table_iter_next (&iter, &key, NULL))
-        keys[i++] = g_strdup (key);
-      g_assert_cmpint (i, ==, n);
-      keys[n] = NULL;
+      g_assert_cmpint (d.i, ==, n);
+      d.keys[n] = NULL;
 
-      return keys;
+      return d.keys;
     }
 
   else if (application->priv->actions != NULL)
diff -uNr glib-2.28.8-orig/gio/gcontenttype.c glib-2.28.8-new/gio/gcontenttype.c
--- glib-2.28.8-orig/gio/gcontenttype.c	2011-06-05 10:20:40.000000000 -0700
+++ glib-2.28.8-new/gio/gcontenttype.c	2015-06-02 18:26:00.000000000 -0700
@@ -1057,6 +1057,17 @@
   g_free (mimedir);
 }
 
+
+
+static void
+list_mime (gpointer     key,
+           gpointer     value,
+           gpointer     user_data)
+{
+        GList ** l = user_data;
+        *l = g_list_prepend(*l, key);
+}
+
 /**
  * g_content_types_get_registered:
  *
@@ -1074,8 +1085,6 @@
 {
   const char * const* dirs;
   GHashTable *mimetypes;
-  GHashTableIter iter;
-  gpointer key;
   int i;
   GList *l;
 
@@ -1088,12 +1097,7 @@
     enumerate_mimetypes_dir (dirs[i], mimetypes);
 
   l = NULL;
-  g_hash_table_iter_init (&iter, mimetypes);
-  while (g_hash_table_iter_next (&iter, &key, NULL))
-    {
-      l = g_list_prepend (l, key);
-      g_hash_table_iter_steal (&iter);
-    }
+  g_hash_table_foreach(mimetypes, list_mime, &l);
 
   g_hash_table_destroy (mimetypes);
 
diff -uNr glib-2.28.8-orig/gio/gdbus-tool.c glib-2.28.8-new/gio/gdbus-tool.c
--- glib-2.28.8-orig/gio/gdbus-tool.c	2011-06-05 16:18:49.000000000 -0700
+++ glib-2.28.8-new/gio/gdbus-tool.c	2015-06-03 14:06:59.000000000 -0700
@@ -258,6 +258,13 @@
 }
 
 static void
+cb_get_keys(gpointer key, gpointer value, gpointer user_data)
+{
+  GList **l = (GList **)user_data;
+  *l = g_list_prepend(*l, key);
+}
+
+static void
 print_names (GDBusConnection *c,
              gboolean         include_unique_names)
 {
@@ -319,7 +326,9 @@
   g_variant_iter_free (iter);
   g_variant_unref (result);
 
-  keys = g_hash_table_get_keys (name_set);
+  keys = NULL;
+  g_hash_table_foreach(name_set, cb_get_keys, &keys);
+
   keys = g_list_sort (keys, (GCompareFunc) g_strcmp0);
   for (l = keys; l != NULL; l = l->next)
     {
diff -uNr glib-2.28.8-orig/gio/gdbusaddress.c glib-2.28.8-new/gio/gdbusaddress.c
--- glib-2.28.8-orig/gio/gdbusaddress.c	2011-06-05 16:18:49.000000000 -0700
+++ glib-2.28.8-new/gio/gdbusaddress.c	2015-06-03 12:23:32.000000000 -0700
@@ -106,6 +106,13 @@
   return ret;
 }
 
+static void
+cb_get_keys(gpointer key, gpointer value, gpointer user_data)
+{
+  GList **l = (GList **)user_data;
+  *l = g_list_prepend(*l, key);
+}
+
 static gboolean
 is_valid_unix (const gchar  *address_entry,
                GHashTable   *key_value_pairs,
@@ -124,7 +131,7 @@
   tmpdir = NULL;
   abstract = NULL;
 
-  keys = g_hash_table_get_keys (key_value_pairs);
+  g_hash_table_foreach(key_value_pairs, cb_get_keys, &keys);
   for (l = keys; l != NULL; l = l->next)
     {
       const gchar *key = l->data;
@@ -210,7 +217,7 @@
   family = NULL;
   nonce_file = NULL;
 
-  keys = g_hash_table_get_keys (key_value_pairs);
+  g_hash_table_foreach(key_value_pairs, cb_get_keys, &keys);
   for (l = keys; l != NULL; l = l->next)
     {
       const gchar *key = l->data;
@@ -286,7 +293,7 @@
   port = NULL;
   family = NULL;
 
-  keys = g_hash_table_get_keys (key_value_pairs);
+  g_hash_table_foreach(key_value_pairs, cb_get_keys, &keys);
   for (l = keys; l != NULL; l = l->next)
     {
       const gchar *key = l->data;
diff -uNr glib-2.28.8-orig/gio/gdbusconnection.c glib-2.28.8-new/gio/gdbusconnection.c
--- glib-2.28.8-orig/gio/gdbusconnection.c	2011-06-05 16:18:49.000000000 -0700
+++ glib-2.28.8-new/gio/gdbusconnection.c	2015-06-03 14:08:24.000000000 -0700
@@ -3565,23 +3565,26 @@
 
 /* ---------------------------------------------------------------------------------------------------- */
 
+static void
+copy_subscription_ids(gpointer key, gpointer value, gpointer user_data)
+{
+    GArray *ids = (GArray *)user_data;
+    guint subscription_id = GPOINTER_TO_UINT (key);
+    g_array_append_val (ids, subscription_id);
+}
+
 /* only called from finalize(), removes all subscriptions */
 static void
 purge_all_signal_subscriptions (GDBusConnection *connection)
 {
-  GHashTableIter iter;
-  gpointer key;
   GArray *ids;
   GArray *subscribers;
   guint n;
 
   ids = g_array_new (FALSE, FALSE, sizeof (guint));
-  g_hash_table_iter_init (&iter, connection->map_id_to_signal_data);
-  while (g_hash_table_iter_next (&iter, &key, NULL))
-    {
-      guint subscription_id = GPOINTER_TO_UINT (key);
-      g_array_append_val (ids, subscription_id);
-    }
+
+  g_hash_table_foreach(connection->map_id_to_signal_data,
+		       copy_subscription_ids, ids);
 
   subscribers = g_array_new (FALSE, FALSE, sizeof (SignalSubscriber));
   for (n = 0; n < ids->len; n++)
@@ -4311,6 +4314,26 @@
     }
 }
 
+typedef struct maybe_add_path_data {
+  const gchar *path;
+  gsize path_len;
+  GHashTable *set;
+} maybe_add_path_data_t;
+
+static void
+cb_maybe_add_path(gpointer key, gpointer value, gpointer user_data)
+{
+  maybe_add_path_data_t *d = (maybe_add_path_data_t *)user_data;
+  maybe_add_path(d->path, d->path_len, key, d->set);
+}
+
+static void
+cb_get_keys(gpointer key, gpointer value, gpointer user_data)
+{
+  GList **l = (GList **)user_data;
+  *l = g_list_prepend(*l, key);
+}
+
 /* TODO: we want a nicer public interface for this */
 static gchar **
 g_dbus_connection_list_registered_unlocked (GDBusConnection *connection,
@@ -4318,34 +4341,32 @@
 {
   GPtrArray *p;
   gchar **ret;
-  GHashTableIter hash_iter;
-  const gchar *object_path;
-  gsize path_len;
-  GHashTable *set;
+  maybe_add_path_data_t d;
+
   GList *keys;
   GList *l;
 
   CONNECTION_ENSURE_LOCK (connection);
 
-  path_len = strlen (path);
-  if (path_len > 1)
-    path_len++;
-
-  set = g_hash_table_new (g_str_hash, g_str_equal);
-
-  g_hash_table_iter_init (&hash_iter, connection->map_object_path_to_eo);
-  while (g_hash_table_iter_next (&hash_iter, (gpointer) &object_path, NULL))
-    maybe_add_path (path, path_len, object_path, set);
-
-  g_hash_table_iter_init (&hash_iter, connection->map_object_path_to_es);
-  while (g_hash_table_iter_next (&hash_iter, (gpointer) &object_path, NULL))
-    maybe_add_path (path, path_len, object_path, set);
+  d.path = path;
+  d.path_len = strlen (path);
+  if (d.path_len > 1)
+    d.path_len++;
+
+  d.set = g_hash_table_new (g_str_hash, g_str_equal);
+
+  g_hash_table_foreach(connection->map_object_path_to_eo,
+			cb_maybe_add_path, &d);
+
+  g_hash_table_foreach(connection->map_object_path_to_es,
+			cb_maybe_add_path, &d);
 
   p = g_ptr_array_new ();
-  keys = g_hash_table_get_keys (set);
+  keys = NULL;
+  g_hash_table_foreach(d.set, cb_get_keys, &keys);
   for (l = keys; l != NULL; l = l->next)
     g_ptr_array_add (p, l->data);
-  g_hash_table_unref (set);
+  g_hash_table_unref (d.set);
   g_list_free (keys);
 
   g_ptr_array_add (p, NULL);
@@ -4364,6 +4385,15 @@
   return ret;
 }
 
+static void
+cb_g_dbus_interface_info_generate_xml(gpointer key, gpointer value,
+					gpointer user_data)
+{
+    GString *s = (GString *)user_data;
+    ExportedInterface *ei = (ExportedInterface *)value;
+    g_dbus_interface_info_generate_xml (ei->interface_info, 2, s);
+}
+
 /* called in message handler thread with lock held */
 static gboolean
 handle_introspect (GDBusConnection *connection,
@@ -4373,8 +4403,6 @@
   guint n;
   GString *s;
   GDBusMessage *reply;
-  GHashTableIter hash_iter;
-  ExportedInterface *ei;
   gchar **registered;
 
   /* first the header with the standard interfaces */
@@ -4392,9 +4420,8 @@
     g_string_append (s, introspect_introspectable_interface);
 
   /* then include the registered interfaces */
-  g_hash_table_iter_init (&hash_iter, eo->map_if_name_to_ei);
-  while (g_hash_table_iter_next (&hash_iter, NULL, (gpointer) &ei))
-    g_dbus_interface_info_generate_xml (ei->interface_info, 2, s);
+  g_hash_table_foreach(eo->map_if_name_to_ei,
+			cb_g_dbus_interface_info_generate_xml, s);
 
   /* finally include nodes registered below us */
   registered = g_dbus_connection_list_registered_unlocked (connection, eo->object_path);
diff -uNr glib-2.28.8-orig/gio/gdbusmessage.c glib-2.28.8-new/gio/gdbusmessage.c
--- glib-2.28.8-orig/gio/gdbusmessage.c	2011-06-05 16:18:49.000000000 -0700
+++ glib-2.28.8-new/gio/gdbusmessage.c	2015-06-03 14:09:15.000000000 -0700
@@ -668,6 +668,13 @@
     }
 }
 
+static void
+cb_get_keys(gpointer key, gpointer value, gpointer user_data)
+{
+  GList **l = (GList **)user_data;
+  *l = g_list_prepend(*l, key);
+}
+
 /**
  * g_dbus_message_get_header_fields:
  * @message: A #GDBusMessage.
@@ -691,7 +698,8 @@
 
   g_return_val_if_fail (G_IS_DBUS_MESSAGE (message), NULL);
 
-  keys = g_hash_table_get_keys (message->headers);
+  keys = NULL;
+  g_hash_table_foreach(message->headers, cb_get_keys, &keys);
   num_keys = g_list_length (keys);
   ret = g_new (guchar, num_keys + 1);
   for (l = keys, n = 0; l != NULL; l = l->next, n++)
@@ -2189,6 +2197,16 @@
 
 /* ---------------------------------------------------------------------------------------------------- */
 
+static void
+cb_g_variant_builder_add(gpointer key, gpointer value, gpointer user_data)
+{
+  GVariantBuilder *builder = (GVariantBuilder *) user_data;
+  g_variant_builder_add (builder,
+			 "{yv}",
+			 (guchar) GPOINTER_TO_UINT (key),
+			 value);
+}
+
 /**
  * g_dbus_message_to_blob:
  * @message: A #GDBusMessage.
@@ -2220,9 +2238,6 @@
   gsize body_size;
   GVariant *header_fields;
   GVariantBuilder builder;
-  GHashTableIter hash_iter;
-  gpointer key;
-  GVariant *header_value;
   GVariant *signature;
   const gchar *signature_str;
   gint num_fds_in_message;
@@ -2285,14 +2300,9 @@
     }
 
   g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{yv}"));
-  g_hash_table_iter_init (&hash_iter, message->headers);
-  while (g_hash_table_iter_next (&hash_iter, &key, (gpointer) &header_value))
-    {
-      g_variant_builder_add (&builder,
-                             "{yv}",
-                             (guchar) GPOINTER_TO_UINT (key),
-                             header_value);
-    }
+
+  g_hash_table_foreach(message->headers, cb_g_variant_builder_add, &builder);
+
   header_fields = g_variant_builder_end (&builder);
 
   if (!append_value_to_blob (header_fields,
@@ -3047,7 +3057,8 @@
   g_string_append_printf (str, "%*sSerial:  %d\n", indent, "", message->serial);
 
   g_string_append_printf (str, "%*sHeaders:\n", indent, "");
-  keys = g_hash_table_get_keys (message->headers);
+  keys = NULL;
+  g_hash_table_foreach(message->headers, cb_get_keys, &keys);
   keys = g_list_sort (keys, _sort_keys_func);
   if (keys != NULL)
     {
@@ -3186,6 +3197,13 @@
   ;
 }
 
+static void
+cb_g_hash_table_insert(gpointer key, gpointer value, gpointer user_data)
+{
+  GHashTable *ht = (GHashTable *)user_data;
+  g_hash_table_insert (ht, key, g_variant_ref (value));
+}
+
 /**
  * g_dbus_message_copy:
  * @message: A #GDBusMessage.
@@ -3208,9 +3226,6 @@
                      GError       **error)
 {
   GDBusMessage *ret;
-  GHashTableIter iter;
-  gpointer header_key;
-  GVariant *header_value;
 
   g_return_val_if_fail (G_IS_DBUS_MESSAGE (message), NULL);
   g_return_val_if_fail (error == NULL || *error == NULL, NULL);
@@ -3249,9 +3264,8 @@
    * to just ref (as opposed to deep-copying) the GVariant instances
    */
   ret->body = message->body != NULL ? g_variant_ref (message->body) : NULL;
-  g_hash_table_iter_init (&iter, message->headers);
-  while (g_hash_table_iter_next (&iter, &header_key, (gpointer) &header_value))
-    g_hash_table_insert (ret->headers, header_key, g_variant_ref (header_value));
+
+  g_hash_table_foreach(message->headers, cb_g_hash_table_insert, ret->headers);
 
  out:
   return ret;
diff -uNr glib-2.28.8-orig/gio/gdbusproxy.c glib-2.28.8-new/gio/gdbusproxy.c
--- glib-2.28.8-orig/gio/gdbusproxy.c	2011-06-05 16:18:49.000000000 -0700
+++ glib-2.28.8-new/gio/gdbusproxy.c	2015-06-02 18:59:49.000000000 -0700
@@ -550,6 +550,13 @@
   return g_strcmp0 (*a, *b);
 }
 
+static void
+cb_g_ptr_array_add(gpointer key, gpointer value, gpointer user_data)
+{
+  GPtrArray *p = (GPtrArray *) user_data;
+  g_ptr_array_add (p, g_strdup (key));
+}
+
 /**
  * g_dbus_proxy_get_cached_property_names:
  * @proxy: A #GDBusProxy.
@@ -566,8 +573,6 @@
 {
   gchar **names;
   GPtrArray *p;
-  GHashTableIter iter;
-  const gchar *key;
 
   g_return_val_if_fail (G_IS_DBUS_PROXY (proxy), NULL);
 
@@ -577,9 +582,8 @@
 
   p = g_ptr_array_new ();
 
-  g_hash_table_iter_init (&iter, proxy->priv->properties);
-  while (g_hash_table_iter_next (&iter, (gpointer) &key, NULL))
-    g_ptr_array_add (p, g_strdup (key));
+  g_hash_table_foreach(proxy->priv->properties, cb_g_ptr_array_add, p);
+
   g_ptr_array_sort (p, (GCompareFunc) property_name_sort_func);
   g_ptr_array_add (p, NULL);
 
@@ -984,16 +988,15 @@
           GVariantBuilder builder;
           GVariant *changed_properties;
           GPtrArray *invalidated_properties;
-          GHashTableIter iter;
-          const gchar *key;
 
           /* Build changed_properties (always empty) and invalidated_properties ... */
           g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
           changed_properties = g_variant_builder_end (&builder);
           invalidated_properties = g_ptr_array_new_with_free_func (g_free);
-          g_hash_table_iter_init (&iter, proxy->priv->properties);
-          while (g_hash_table_iter_next (&iter, (gpointer) &key, NULL))
-            g_ptr_array_add (invalidated_properties, g_strdup (key));
+
+	  g_hash_table_foreach(proxy->priv->properties, cb_g_ptr_array_add,
+				invalidated_properties);
+
           g_ptr_array_add (invalidated_properties, NULL);
 
           /* ... throw out the properties ... */
diff -uNr glib-2.28.8-orig/gio/gdesktopappinfo.c glib-2.28.8-new/gio/gdesktopappinfo.c
--- glib-2.28.8-orig/gio/gdesktopappinfo.c	2011-06-05 16:18:49.000000000 -0700
+++ glib-2.28.8-new/gio/gdesktopappinfo.c	2015-06-02 19:29:02.000000000 -0700
@@ -1,5 +1,5 @@
 /* GIO - GLib Input, Output and Streaming Library
- * 
+ *
  * Copyright (C) 2006-2007 Red Hat, Inc.
  * Copyright © 2007 Ryan Lortie
  *
@@ -77,7 +77,7 @@
 
 /**
  * GDesktopAppInfo:
- * 
+ *
  * Information about an installed application from a desktop file.
  */
 struct _GDesktopAppInfo
@@ -140,7 +140,7 @@
     args[j++] = g_build_filename (data_dirs[i],
 				  "applications", NULL);
   args[j++] = NULL;
-  
+
   return args;
 }
   
@@ -2328,7 +2328,16 @@
     }
 }
 
-
+static void
+list_info (gpointer     key,
+           gpointer     value,
+           gpointer     user_data)
+{
+        if (value) {
+                GList ** l = user_data;
+                *l = g_list_prepend(*l, value);
+        }
+}
 /**
  * g_app_info_get_all:
  *
@@ -2349,7 +2358,6 @@
 {
   const char * const *dirs;
   GHashTable *apps;
-  GHashTableIter iter;
   gpointer value;
   int i;
   GList *infos;
@@ -2365,12 +2373,7 @@
 
 
   infos = NULL;
-  g_hash_table_iter_init (&iter, apps);
-  while (g_hash_table_iter_next (&iter, NULL, &value))
-    {
-      if (value)
-        infos = g_list_prepend (infos, value);
-    }
+  g_hash_table_foreach(apps, list_info, &infos);
 
   g_hash_table_destroy (apps);
 
diff -uNr glib-2.28.8-orig/gio/gdesktopappinfo.c.orig glib-2.28.8-new/gio/gdesktopappinfo.c.orig
--- glib-2.28.8-orig/gio/gdesktopappinfo.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ glib-2.28.8-new/gio/gdesktopappinfo.c.orig	2011-06-05 16:18:49.000000000 -0700
@@ -0,0 +1,3162 @@
+/* GIO - GLib Input, Output and Streaming Library
+ * 
+ * Copyright (C) 2006-2007 Red Hat, Inc.
+ * Copyright © 2007 Ryan Lortie
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Author: Alexander Larsson <alexl@redhat.com>
+ */
+
+#include "config.h"
+
+#include <errno.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/wait.h>
+
+#ifdef HAVE_CRT_EXTERNS_H
+#include <crt_externs.h>
+#endif
+
+#undef G_DISABLE_DEPRECATED
+
+#include "gcontenttypeprivate.h"
+#include "gdesktopappinfo.h"
+#include "gfile.h"
+#include "gioerror.h"
+#include "gthemedicon.h"
+#include "gfileicon.h"
+#include <glib/gstdio.h>
+#include "glibintl.h"
+#include "giomodule-priv.h"
+#include "gappinfo.h"
+
+
+/**
+ * SECTION:gdesktopappinfo
+ * @title: GDesktopAppInfo
+ * @short_description: Application information from desktop files
+ * @include: gio/gdesktopappinfo.h
+ *
+ * #GDesktopAppInfo is an implementation of #GAppInfo based on
+ * desktop files.
+ *
+ * Note that <filename>&lt;gio/gdesktopappinfo.h&gt;</filename> belongs to
+ * the UNIX-specific GIO interfaces, thus you have to use the
+ * <filename>gio-unix-2.0.pc</filename> pkg-config file when using it.
+ */
+
+#define DEFAULT_APPLICATIONS_GROUP  "Default Applications"
+#define ADDED_ASSOCIATIONS_GROUP    "Added Associations"
+#define REMOVED_ASSOCIATIONS_GROUP  "Removed Associations"
+#define MIME_CACHE_GROUP            "MIME Cache"
+#define FULL_NAME_KEY               "X-GNOME-FullName"
+
+static void     g_desktop_app_info_iface_init         (GAppInfoIface    *iface);
+static GList *  get_all_desktop_entries_for_mime_type (const char       *base_mime_type,
+						       const char      **except,
+						       gboolean          include_fallback,
+                                                       char            **explicit_default);
+static void     mime_info_cache_reload                (const char       *dir);
+static gboolean g_desktop_app_info_ensure_saved       (GDesktopAppInfo  *info,
+						       GError          **error);
+
+/**
+ * GDesktopAppInfo:
+ * 
+ * Information about an installed application from a desktop file.
+ */
+struct _GDesktopAppInfo
+{
+  GObject parent_instance;
+
+  char *desktop_id;
+  char *filename;
+
+  char *name;
+  /* FIXME: what about GenericName ? */
+  char *fullname;
+  char *comment;
+  char *icon_name;
+  GIcon *icon;
+  char **only_show_in;
+  char **not_show_in;
+  char *try_exec;
+  char *exec;
+  char *binary;
+  char *path;
+
+  guint nodisplay       : 1;
+  guint hidden          : 1;
+  guint terminal        : 1;
+  guint startup_notify  : 1;
+  guint no_fuse         : 1;
+  /* FIXME: what about StartupWMClass ? */
+};
+
+typedef enum {
+  UPDATE_MIME_NONE = 1 << 0,
+  UPDATE_MIME_SET_DEFAULT = 1 << 1,
+  UPDATE_MIME_SET_NON_DEFAULT = 1 << 2,
+  UPDATE_MIME_REMOVE = 1 << 3,
+  UPDATE_MIME_SET_LAST_USED = 1 << 4,
+} UpdateMimeFlags;
+
+G_DEFINE_TYPE_WITH_CODE (GDesktopAppInfo, g_desktop_app_info, G_TYPE_OBJECT,
+			 G_IMPLEMENT_INTERFACE (G_TYPE_APP_INFO,
+						g_desktop_app_info_iface_init))
+
+static gpointer
+search_path_init (gpointer data)
+{
+  char **args = NULL;
+  const char * const *data_dirs;
+  const char *user_data_dir;
+  int i, length, j;
+
+  data_dirs = g_get_system_data_dirs ();
+  length = g_strv_length ((char **) data_dirs);
+  
+  args = g_new (char *, length + 2);
+  
+  j = 0;
+  user_data_dir = g_get_user_data_dir ();
+  args[j++] = g_build_filename (user_data_dir, "applications", NULL);
+  for (i = 0; i < length; i++)
+    args[j++] = g_build_filename (data_dirs[i],
+				  "applications", NULL);
+  args[j++] = NULL;
+  
+  return args;
+}
+  
+static const char * const *
+get_applications_search_path (void)
+{
+  static GOnce once_init = G_ONCE_INIT;
+  return g_once (&once_init, search_path_init, NULL);
+}
+
+static void
+g_desktop_app_info_finalize (GObject *object)
+{
+  GDesktopAppInfo *info;
+
+  info = G_DESKTOP_APP_INFO (object);
+
+  g_free (info->desktop_id);
+  g_free (info->filename);
+  g_free (info->name);
+  g_free (info->fullname);
+  g_free (info->comment);
+  g_free (info->icon_name);
+  if (info->icon)
+    g_object_unref (info->icon);
+  g_strfreev (info->only_show_in);
+  g_strfreev (info->not_show_in);
+  g_free (info->try_exec);
+  g_free (info->exec);
+  g_free (info->binary);
+  g_free (info->path);
+  
+  G_OBJECT_CLASS (g_desktop_app_info_parent_class)->finalize (object);
+}
+
+static void
+g_desktop_app_info_class_init (GDesktopAppInfoClass *klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+  
+  gobject_class->finalize = g_desktop_app_info_finalize;
+}
+
+static void
+g_desktop_app_info_init (GDesktopAppInfo *local)
+{
+}
+
+static char *
+binary_from_exec (const char *exec)
+{
+  const char *p, *start;
+  
+  p = exec;
+  while (*p == ' ')
+    p++;
+  start = p;
+  while (*p != ' ' && *p != 0)
+    p++;
+  
+  return g_strndup (start, p - start);
+  
+}
+
+/**
+ * g_desktop_app_info_new_from_keyfile:
+ * @key_file: an opened #GKeyFile
+ * 
+ * Creates a new #GDesktopAppInfo.
+ *
+ * Returns: a new #GDesktopAppInfo or %NULL on error.
+ *
+ * Since: 2.18
+ **/
+GDesktopAppInfo *
+g_desktop_app_info_new_from_keyfile (GKeyFile *key_file)
+{
+  GDesktopAppInfo *info;
+  char *start_group;
+  char *type;
+  char *try_exec;
+  
+  start_group = g_key_file_get_start_group (key_file);
+  if (start_group == NULL || strcmp (start_group, G_KEY_FILE_DESKTOP_GROUP) != 0)
+    {
+      g_free (start_group);
+      return NULL;
+    }
+  g_free (start_group);
+
+  type = g_key_file_get_string (key_file,
+                                G_KEY_FILE_DESKTOP_GROUP,
+                                G_KEY_FILE_DESKTOP_KEY_TYPE,
+                                NULL);
+  if (type == NULL || strcmp (type, G_KEY_FILE_DESKTOP_TYPE_APPLICATION) != 0)
+    {
+      g_free (type);
+      return NULL;
+    }
+  g_free (type);
+
+  try_exec = g_key_file_get_string (key_file,
+                                    G_KEY_FILE_DESKTOP_GROUP,
+                                    G_KEY_FILE_DESKTOP_KEY_TRY_EXEC,
+                                    NULL);
+  if (try_exec && try_exec[0] != '\0')
+    {
+      char *t;
+      t = g_find_program_in_path (try_exec);
+      if (t == NULL)
+	{
+	  g_free (try_exec);
+	  return NULL;
+	}
+      g_free (t);
+    }
+
+  info = g_object_new (G_TYPE_DESKTOP_APP_INFO, NULL);
+  info->filename = NULL;
+
+  info->name = g_key_file_get_locale_string (key_file, G_KEY_FILE_DESKTOP_GROUP, G_KEY_FILE_DESKTOP_KEY_NAME, NULL, NULL);
+  info->fullname = g_key_file_get_locale_string (key_file, G_KEY_FILE_DESKTOP_GROUP, FULL_NAME_KEY, NULL, NULL);
+  info->comment = g_key_file_get_locale_string (key_file, G_KEY_FILE_DESKTOP_GROUP, G_KEY_FILE_DESKTOP_KEY_COMMENT, NULL, NULL);
+  info->nodisplay = g_key_file_get_boolean (key_file, G_KEY_FILE_DESKTOP_GROUP, G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY, NULL) != FALSE;
+  info->icon_name =  g_key_file_get_locale_string (key_file, G_KEY_FILE_DESKTOP_GROUP, G_KEY_FILE_DESKTOP_KEY_ICON, NULL, NULL);
+  info->only_show_in = g_key_file_get_string_list (key_file, G_KEY_FILE_DESKTOP_GROUP, G_KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN, NULL, NULL);
+  info->not_show_in = g_key_file_get_string_list (key_file, G_KEY_FILE_DESKTOP_GROUP, G_KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN, NULL, NULL);
+  info->try_exec = try_exec;
+  info->exec = g_key_file_get_string (key_file, G_KEY_FILE_DESKTOP_GROUP, G_KEY_FILE_DESKTOP_KEY_EXEC, NULL);
+  info->path = g_key_file_get_string (key_file, G_KEY_FILE_DESKTOP_GROUP, G_KEY_FILE_DESKTOP_KEY_PATH, NULL);
+  info->terminal = g_key_file_get_boolean (key_file, G_KEY_FILE_DESKTOP_GROUP, G_KEY_FILE_DESKTOP_KEY_TERMINAL, NULL) != FALSE;
+  info->startup_notify = g_key_file_get_boolean (key_file, G_KEY_FILE_DESKTOP_GROUP, G_KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY, NULL) != FALSE;
+  info->no_fuse = g_key_file_get_boolean (key_file, G_KEY_FILE_DESKTOP_GROUP, "X-GIO-NoFuse", NULL) != FALSE;
+  info->hidden = g_key_file_get_boolean (key_file, G_KEY_FILE_DESKTOP_GROUP, G_KEY_FILE_DESKTOP_KEY_HIDDEN, NULL) != FALSE;
+  
+  info->icon = NULL;
+  if (info->icon_name)
+    {
+      if (g_path_is_absolute (info->icon_name))
+	{
+	  GFile *file;
+	  
+	  file = g_file_new_for_path (info->icon_name);
+	  info->icon = g_file_icon_new (file);
+	  g_object_unref (file);
+	}
+      else
+        {
+          char *p;
+
+          /* Work around a common mistake in desktop files */    
+          if ((p = strrchr (info->icon_name, '.')) != NULL &&
+              (strcmp (p, ".png") == 0 ||
+               strcmp (p, ".xpm") == 0 ||
+               strcmp (p, ".svg") == 0)) 
+            *p = 0;
+
+	  info->icon = g_themed_icon_new (info->icon_name);
+        }
+    }
+  
+  if (info->exec)
+    info->binary = binary_from_exec (info->exec);
+  
+  if (info->path && info->path[0] == '\0')
+    {
+      g_free (info->path);
+      info->path = NULL;
+    }
+
+  return info;
+}
+
+/**
+ * g_desktop_app_info_new_from_filename:
+ * @filename: the path of a desktop file, in the GLib filename encoding
+ * 
+ * Creates a new #GDesktopAppInfo.
+ *
+ * Returns: a new #GDesktopAppInfo or %NULL on error.
+ **/
+GDesktopAppInfo *
+g_desktop_app_info_new_from_filename (const char *filename)
+{
+  GKeyFile *key_file;
+  GDesktopAppInfo *info = NULL;
+
+  key_file = g_key_file_new ();
+  
+  if (g_key_file_load_from_file (key_file,
+				 filename,
+				 G_KEY_FILE_NONE,
+				 NULL))
+    {
+      info = g_desktop_app_info_new_from_keyfile (key_file);
+      if (info)
+        info->filename = g_strdup (filename);
+    }  
+
+  g_key_file_free (key_file);
+
+  return info;
+}
+
+/**
+ * g_desktop_app_info_new:
+ * @desktop_id: the desktop file id
+ * 
+ * Creates a new #GDesktopAppInfo based on a desktop file id. 
+ *
+ * A desktop file id is the basename of the desktop file, including the 
+ * .desktop extension. GIO is looking for a desktop file with this name 
+ * in the <filename>applications</filename> subdirectories of the XDG data
+ * directories (i.e. the directories specified in the 
+ * <envar>XDG_DATA_HOME</envar> and <envar>XDG_DATA_DIRS</envar> environment 
+ * variables). GIO also supports the prefix-to-subdirectory mapping that is
+ * described in the <ulink url="http://standards.freedesktop.org/menu-spec/latest/">Menu Spec</ulink> 
+ * (i.e. a desktop id of kde-foo.desktop will match
+ * <filename>/usr/share/applications/kde/foo.desktop</filename>).
+ * 
+ * Returns: a new #GDesktopAppInfo, or %NULL if no desktop file with that id
+ */
+GDesktopAppInfo *
+g_desktop_app_info_new (const char *desktop_id)
+{
+  GDesktopAppInfo *appinfo;
+  const char * const *dirs;
+  char *basename;
+  int i;
+
+  dirs = get_applications_search_path ();
+
+  basename = g_strdup (desktop_id);
+  
+  for (i = 0; dirs[i] != NULL; i++)
+    {
+      char *filename;
+      char *p;
+
+      filename = g_build_filename (dirs[i], desktop_id, NULL);
+      appinfo = g_desktop_app_info_new_from_filename (filename);
+      g_free (filename);
+      if (appinfo != NULL)
+	goto found;
+
+      p = basename;
+      while ((p = strchr (p, '-')) != NULL)
+	{
+	  *p = '/';
+	  
+	  filename = g_build_filename (dirs[i], basename, NULL);
+	  appinfo = g_desktop_app_info_new_from_filename (filename);
+	  g_free (filename);
+	  if (appinfo != NULL)
+	    goto found;
+	  *p = '-';
+	  p++;
+	}
+    }
+  
+  g_free (basename);
+  return NULL;
+
+ found:
+  g_free (basename);
+  
+  appinfo->desktop_id = g_strdup (desktop_id);
+
+  if (g_desktop_app_info_get_is_hidden (appinfo))
+    {
+      g_object_unref (appinfo);
+      appinfo = NULL;
+    }
+  
+  return appinfo;
+}
+
+static GAppInfo *
+g_desktop_app_info_dup (GAppInfo *appinfo)
+{
+  GDesktopAppInfo *info = G_DESKTOP_APP_INFO (appinfo);
+  GDesktopAppInfo *new_info;
+  
+  new_info = g_object_new (G_TYPE_DESKTOP_APP_INFO, NULL);
+
+  new_info->filename = g_strdup (info->filename);
+  new_info->desktop_id = g_strdup (info->desktop_id);
+  
+  new_info->name = g_strdup (info->name);
+  new_info->fullname = g_strdup (info->fullname);
+  new_info->comment = g_strdup (info->comment);
+  new_info->nodisplay = info->nodisplay;
+  new_info->icon_name = g_strdup (info->icon_name);
+  if (info->icon)
+    new_info->icon = g_object_ref (info->icon);
+  new_info->only_show_in = g_strdupv (info->only_show_in);
+  new_info->not_show_in = g_strdupv (info->not_show_in);
+  new_info->try_exec = g_strdup (info->try_exec);
+  new_info->exec = g_strdup (info->exec);
+  new_info->binary = g_strdup (info->binary);
+  new_info->path = g_strdup (info->path);
+  new_info->hidden = info->hidden;
+  new_info->terminal = info->terminal;
+  new_info->startup_notify = info->startup_notify;
+  
+  return G_APP_INFO (new_info);
+}
+
+static gboolean
+g_desktop_app_info_equal (GAppInfo *appinfo1,
+			  GAppInfo *appinfo2)
+{
+  GDesktopAppInfo *info1 = G_DESKTOP_APP_INFO (appinfo1);
+  GDesktopAppInfo *info2 = G_DESKTOP_APP_INFO (appinfo2);
+
+  if (info1->desktop_id == NULL ||
+      info2->desktop_id == NULL)
+    return info1 == info2;
+
+  return strcmp (info1->desktop_id, info2->desktop_id) == 0;
+}
+
+static const char *
+g_desktop_app_info_get_id (GAppInfo *appinfo)
+{
+  GDesktopAppInfo *info = G_DESKTOP_APP_INFO (appinfo);
+
+  return info->desktop_id;
+}
+
+static const char *
+g_desktop_app_info_get_name (GAppInfo *appinfo)
+{
+  GDesktopAppInfo *info = G_DESKTOP_APP_INFO (appinfo);
+
+  if (info->name == NULL)
+    return _("Unnamed");
+  return info->name;
+}
+
+static const char *
+g_desktop_app_info_get_display_name (GAppInfo *appinfo)
+{
+  GDesktopAppInfo *info = G_DESKTOP_APP_INFO (appinfo);
+
+  if (info->fullname == NULL)
+    return g_desktop_app_info_get_name (appinfo);
+  return info->fullname;
+}
+
+/**
+ * g_desktop_app_info_get_is_hidden:
+ * @info: a #GDesktopAppInfo.
+ *
+ * A desktop file is hidden if the Hidden key in it is
+ * set to True.
+ *
+ * Returns: %TRUE if hidden, %FALSE otherwise. 
+ **/
+gboolean
+g_desktop_app_info_get_is_hidden (GDesktopAppInfo *info)
+{
+  return info->hidden;
+}
+
+/**
+ * g_desktop_app_info_get_filename:
+ * @info: a #GDesktopAppInfo
+ *
+ * When @info was created from a known filename, return it.  In some
+ * situations such as the #GDesktopAppInfo returned from
+ * g_desktop_app_info_new_from_keyfile(), this function will return %NULL.
+ *
+ * Returns: The full path to the file for @info, or %NULL if not known.
+ * Since: 2.24
+ */
+const char *
+g_desktop_app_info_get_filename (GDesktopAppInfo *info)
+{
+  return info->filename;
+}
+
+static const char *
+g_desktop_app_info_get_description (GAppInfo *appinfo)
+{
+  GDesktopAppInfo *info = G_DESKTOP_APP_INFO (appinfo);
+  
+  return info->comment;
+}
+
+static const char *
+g_desktop_app_info_get_executable (GAppInfo *appinfo)
+{
+  GDesktopAppInfo *info = G_DESKTOP_APP_INFO (appinfo);
+  
+  return info->binary;
+}
+
+static const char *
+g_desktop_app_info_get_commandline (GAppInfo *appinfo)
+{
+  GDesktopAppInfo *info = G_DESKTOP_APP_INFO (appinfo);
+  
+  return info->exec;
+}
+
+static GIcon *
+g_desktop_app_info_get_icon (GAppInfo *appinfo)
+{
+  GDesktopAppInfo *info = G_DESKTOP_APP_INFO (appinfo);
+
+  return info->icon;
+}
+
+static char *
+expand_macro_single (char macro, char *uri)
+{
+  GFile *file;
+  char *result = NULL;
+  char *path, *name;
+
+  file = g_file_new_for_uri (uri);
+  path = g_file_get_path (file);
+  g_object_unref (file);
+  
+  switch (macro)
+    {
+    case 'u':
+    case 'U':	
+      result = g_shell_quote (uri);
+      break;
+    case 'f':
+    case 'F':
+      if (path)
+	result = g_shell_quote (path);
+      break;
+    case 'd':
+    case 'D':
+      if (path)
+        {
+          name = g_path_get_dirname (path);
+	  result = g_shell_quote (name);
+          g_free (name);
+        }
+      break;
+    case 'n':
+    case 'N':
+      if (path)
+        {
+          name = g_path_get_basename (path);
+	  result = g_shell_quote (name);
+          g_free (name);
+        }
+      break;
+    }
+
+  g_free (path);
+  
+  return result;
+}
+
+static void
+expand_macro (char              macro, 
+              GString          *exec, 
+              GDesktopAppInfo  *info, 
+              GList           **uri_list)
+{
+  GList *uris = *uri_list;
+  char *expanded;
+  gboolean force_file_uri;
+  char force_file_uri_macro;
+  char *uri;
+
+  g_return_if_fail (exec != NULL);
+
+  /* On %u and %U, pass POSIX file path pointing to the URI via
+   * the FUSE mount in ~/.gvfs. Note that if the FUSE daemon isn't
+   * running or the URI doesn't have a POSIX file path via FUSE
+   * we'll just pass the URI.
+   */
+  force_file_uri_macro = macro;
+  force_file_uri = FALSE;
+  if (!info->no_fuse)
+    {
+      switch (macro)
+	{
+	case 'u':
+	  force_file_uri_macro = 'f';
+	  force_file_uri = TRUE;
+	  break;
+	case 'U':
+	  force_file_uri_macro = 'F';
+	  force_file_uri = TRUE;
+	  break;
+	default:
+	  break;
+	}
+    }
+
+  switch (macro)
+    {
+    case 'u':
+    case 'f':
+    case 'd':
+    case 'n':
+      if (uris)
+	{
+	  uri = uris->data;
+          if (!force_file_uri ||
+	      /* Pass URI if it contains an anchor */
+	      strchr (uri, '#') != NULL)
+            {
+              expanded = expand_macro_single (macro, uri);
+            }
+          else
+            {
+              expanded = expand_macro_single (force_file_uri_macro, uri);
+              if (expanded == NULL)
+                expanded = expand_macro_single (macro, uri);
+            }
+
+	  if (expanded)
+	    {
+	      g_string_append (exec, expanded);
+	      g_free (expanded);
+	    }
+	  uris = uris->next;
+	}
+
+      break;
+
+    case 'U':	
+    case 'F':
+    case 'D':
+    case 'N':
+      while (uris)
+	{
+	  uri = uris->data;
+	  
+          if (!force_file_uri ||
+	      /* Pass URI if it contains an anchor */
+	      strchr (uri, '#') != NULL)
+            {
+              expanded = expand_macro_single (macro, uri);
+            }
+          else
+            {
+              expanded = expand_macro_single (force_file_uri_macro, uri);
+              if (expanded == NULL)
+                expanded = expand_macro_single (macro, uri);
+            }
+
+	  if (expanded)
+	    {
+	      g_string_append (exec, expanded);
+	      g_free (expanded);
+	    }
+	  
+	  uris = uris->next;
+	  
+	  if (uris != NULL && expanded)
+	    g_string_append_c (exec, ' ');
+	}
+
+      break;
+
+    case 'i':
+      if (info->icon_name)
+	{
+	  g_string_append (exec, "--icon ");
+          expanded = g_shell_quote (info->icon_name);
+	  g_string_append (exec, expanded);
+          g_free (expanded);
+	}
+      break;
+
+    case 'c':
+      if (info->name) 
+        {
+          expanded = g_shell_quote (info->name);
+	  g_string_append (exec, expanded);
+          g_free (expanded);
+        }
+      break;
+
+    case 'k':
+      if (info->filename) 
+        {
+          expanded = g_shell_quote (info->filename);
+	  g_string_append (exec, expanded);
+          g_free (expanded);
+        }
+      break;
+
+    case 'm': /* deprecated */
+      break;
+
+    case '%':
+      g_string_append_c (exec, '%');
+      break;
+    }
+  
+  *uri_list = uris;
+}
+
+static gboolean
+expand_application_parameters (GDesktopAppInfo   *info,
+			       GList            **uris,
+			       int               *argc,
+			       char            ***argv,
+			       GError           **error)
+{
+  GList *uri_list = *uris;
+  const char *p = info->exec;
+  GString *expanded_exec;
+  gboolean res;
+
+  if (info->exec == NULL)
+    {
+      g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                           _("Desktop file didn't specify Exec field"));
+      return FALSE;
+    }
+
+  expanded_exec = g_string_new (NULL);
+
+  while (*p)
+    {
+      if (p[0] == '%' && p[1] != '\0')
+	{
+	  expand_macro (p[1], expanded_exec, info, uris);
+	  p++;
+	}
+      else
+	g_string_append_c (expanded_exec, *p);
+
+      p++;
+    }
+
+  /* No file substitutions */
+  if (uri_list == *uris && uri_list != NULL)
+    {
+      /* If there is no macro default to %f. This is also what KDE does */
+      g_string_append_c (expanded_exec, ' ');
+      expand_macro ('f', expanded_exec, info, uris);
+    }
+
+  res = g_shell_parse_argv (expanded_exec->str, argc, argv, error);
+  g_string_free (expanded_exec, TRUE);
+  return res;
+}
+
+static gboolean
+prepend_terminal_to_vector (int    *argc,
+			    char ***argv)
+{
+#ifndef G_OS_WIN32
+  char **real_argv;
+  int real_argc;
+  int i, j;
+  char **term_argv = NULL;
+  int term_argc = 0;
+  char *check;
+  char **the_argv;
+  
+  g_return_val_if_fail (argc != NULL, FALSE);
+  g_return_val_if_fail (argv != NULL, FALSE);
+	
+  /* sanity */
+  if(*argv == NULL)
+    *argc = 0;
+  
+  the_argv = *argv;
+
+  /* compute size if not given */
+  if (*argc < 0)
+    {
+      for (i = 0; the_argv[i] != NULL; i++)
+	;
+      *argc = i;
+    }
+  
+  term_argc = 2;
+  term_argv = g_new0 (char *, 3);
+
+  check = g_find_program_in_path ("gnome-terminal");
+  if (check != NULL)
+    {
+      term_argv[0] = check;
+      /* Note that gnome-terminal takes -x and
+       * as -e in gnome-terminal is broken we use that. */
+      term_argv[1] = g_strdup ("-x");
+    }
+  else
+    {
+      if (check == NULL)
+	check = g_find_program_in_path ("nxterm");
+      if (check == NULL)
+	check = g_find_program_in_path ("color-xterm");
+      if (check == NULL)
+	check = g_find_program_in_path ("rxvt");
+      if (check == NULL)
+	check = g_find_program_in_path ("xterm");
+      if (check == NULL)
+	check = g_find_program_in_path ("dtterm");
+      if (check == NULL)
+	{
+	  check = g_strdup ("xterm");
+	  g_warning ("couldn't find a terminal, falling back to xterm");
+	}
+      term_argv[0] = check;
+      term_argv[1] = g_strdup ("-e");
+    }
+
+  real_argc = term_argc + *argc;
+  real_argv = g_new (char *, real_argc + 1);
+  
+  for (i = 0; i < term_argc; i++)
+    real_argv[i] = term_argv[i];
+  
+  for (j = 0; j < *argc; j++, i++)
+    real_argv[i] = (char *)the_argv[j];
+  
+  real_argv[i] = NULL;
+  
+  g_free (*argv);
+  *argv = real_argv;
+  *argc = real_argc;
+  
+  /* we use g_free here as we sucked all the inner strings
+   * out from it into real_argv */
+  g_free (term_argv);
+  return TRUE;
+#else
+  return FALSE;
+#endif /* G_OS_WIN32 */
+}
+
+static GList *
+create_files_for_uris (GList *uris)
+{
+  GList *res;
+  GList *iter;
+
+  res = NULL;
+
+  for (iter = uris; iter; iter = iter->next)
+    {
+      GFile *file = g_file_new_for_uri ((char *)iter->data);
+      res = g_list_prepend (res, file);
+    }
+
+  return g_list_reverse (res);
+}
+
+typedef struct
+{
+  GSpawnChildSetupFunc user_setup;
+  gpointer user_setup_data;
+  char *display;
+  char *sn_id;
+  char *desktop_file;
+} ChildSetupData;
+
+static void
+child_setup (gpointer user_data)
+{
+  ChildSetupData *data = user_data;
+
+  if (data->display)
+    g_setenv ("DISPLAY", data->display, TRUE);
+
+  if (data->sn_id)
+    g_setenv ("DESKTOP_STARTUP_ID", data->sn_id, TRUE);
+
+  if (data->desktop_file)
+    {
+      gchar pid[20];
+
+      g_setenv ("GIO_LAUNCHED_DESKTOP_FILE", data->desktop_file, TRUE);
+
+      g_snprintf (pid, 20, "%ld", (long)getpid ());
+      g_setenv ("GIO_LAUNCHED_DESKTOP_FILE_PID", pid, TRUE);
+    }
+
+  if (data->user_setup)
+    data->user_setup (data->user_setup_data);
+}
+
+static void
+notify_desktop_launch (GDBusConnection  *session_bus,
+		       GDesktopAppInfo  *info,
+		       long              pid,
+		       const char       *display,
+		       const char       *sn_id,
+		       GList            *uris)
+{
+  GDBusMessage *msg;
+  GVariantBuilder uri_variant;
+  GVariantBuilder extras_variant;
+  GList *iter;
+  const char *desktop_file_id;
+  const char *gio_desktop_file;
+
+  if (session_bus == NULL)
+    return;
+
+  g_variant_builder_init (&uri_variant, G_VARIANT_TYPE ("as"));
+  for (iter = uris; iter; iter = iter->next)
+    g_variant_builder_add (&uri_variant, "s", iter->data);
+
+  g_variant_builder_init (&extras_variant, G_VARIANT_TYPE ("a{sv}"));
+  if (sn_id != NULL && g_utf8_validate (sn_id, -1, NULL))
+    g_variant_builder_add (&extras_variant, "{sv}",
+			   "startup-id",
+			   g_variant_new ("s",
+					  sn_id));
+  gio_desktop_file = g_getenv ("GIO_LAUNCHED_DESKTOP_FILE");
+  if (gio_desktop_file != NULL)
+    g_variant_builder_add (&extras_variant, "{sv}",
+			   "origin-desktop-file",
+			   g_variant_new_bytestring (gio_desktop_file));
+  if (g_get_prgname () != NULL)
+    g_variant_builder_add (&extras_variant, "{sv}",
+			   "origin-prgname",
+			   g_variant_new_bytestring (g_get_prgname ()));
+  g_variant_builder_add (&extras_variant, "{sv}",
+			 "origin-pid",
+			 g_variant_new ("x",
+					(gint64)getpid ()));
+
+  if (info->filename)
+    desktop_file_id = info->filename;
+  else if (info->desktop_id)
+    desktop_file_id = info->desktop_id;
+  else
+    desktop_file_id = "";
+  
+  msg = g_dbus_message_new_signal ("/org/gtk/gio/DesktopAppInfo",
+				   "org.gtk.gio.DesktopAppInfo",
+				   "Launched");
+  g_dbus_message_set_body (msg, g_variant_new ("(@aysxasa{sv})",
+					       g_variant_new_bytestring (desktop_file_id),
+					       display ? display : "",
+					       (gint64)pid,
+					       &uri_variant,
+					       &extras_variant));
+  g_dbus_connection_send_message (session_bus,
+				  msg, 0,
+				  NULL,
+				  NULL);
+  g_object_unref (msg);
+}
+
+#define _SPAWN_FLAGS_DEFAULT (G_SPAWN_SEARCH_PATH)
+
+static gboolean
+_g_desktop_app_info_launch_uris_internal (GAppInfo                   *appinfo,
+					  GList                      *uris,
+					  GAppLaunchContext          *launch_context,
+					  GSpawnFlags                 spawn_flags,
+					  GSpawnChildSetupFunc        user_setup,
+					  gpointer                    user_setup_data,
+					  GDesktopAppLaunchCallback   pid_callback,
+					  gpointer                    pid_callback_data,
+					  GError                     **error)
+{
+  GDesktopAppInfo *info = G_DESKTOP_APP_INFO (appinfo);
+  GDBusConnection *session_bus;
+  gboolean completed = FALSE;
+  GList *old_uris;
+  char **argv;
+  int argc;
+  ChildSetupData data;
+
+  g_return_val_if_fail (appinfo != NULL, FALSE);
+
+  argv = NULL;
+
+  session_bus = g_bus_get_sync (G_BUS_TYPE_SESSION, NULL, NULL);
+
+  do
+    {
+      GPid pid;
+      GList *launched_uris;
+      GList *iter;
+
+      old_uris = uris;
+      if (!expand_application_parameters (info, &uris,
+					  &argc, &argv, error))
+	goto out;
+
+      /* Get the subset of URIs we're launching with this process */
+      launched_uris = NULL;
+      for (iter = old_uris; iter != NULL && iter != uris; iter = iter->next)
+	launched_uris = g_list_prepend (launched_uris, iter->data);
+      launched_uris = g_list_reverse (launched_uris);
+      
+      if (info->terminal && !prepend_terminal_to_vector (&argc, &argv))
+	{
+	  g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                               _("Unable to find terminal required for application"));
+	  goto out;
+	}
+
+      data.user_setup = user_setup;
+      data.user_setup_data = user_setup_data;
+      data.display = NULL;
+      data.sn_id = NULL;
+      data.desktop_file = info->filename;
+
+      if (launch_context)
+	{
+	  GList *launched_files = create_files_for_uris (launched_uris);
+
+	  data.display = g_app_launch_context_get_display (launch_context,
+						           appinfo,
+						           launched_files);
+
+	  if (info->startup_notify)
+	    data.sn_id = g_app_launch_context_get_startup_notify_id (launch_context,
+								     appinfo,
+								     launched_files);
+	  g_list_foreach (launched_files, (GFunc)g_object_unref, NULL);
+	  g_list_free (launched_files);
+	}
+
+      if (!g_spawn_async (info->path,
+			  argv,
+			  NULL,
+			  spawn_flags,
+			  child_setup,
+			  &data,
+			  &pid,
+			  error))
+	{
+	  if (data.sn_id)
+	    g_app_launch_context_launch_failed (launch_context, data.sn_id);
+
+	  g_free (data.sn_id);
+	  g_free (data.display);
+	  g_list_free (launched_uris);
+
+	  goto out;
+	}
+
+      if (pid_callback != NULL)
+	pid_callback (info, pid, pid_callback_data);
+
+      notify_desktop_launch (session_bus,
+			     info,
+			     pid,
+			     data.display,
+			     data.sn_id,
+			     launched_uris);
+
+      g_free (data.sn_id);
+      g_free (data.display);
+      g_list_free (launched_uris);
+
+      g_strfreev (argv);
+      argv = NULL;
+    }
+  while (uris != NULL);
+
+  /* TODO - need to handle the process exiting immediately
+   * after launching an app.  See http://bugzilla.gnome.org/606960
+   */
+  if (session_bus != NULL)
+    {
+      /* This asynchronous flush holds a reference until it completes,
+       * which ensures that the following unref won't immediately kill
+       * the connection if we were the initial owner.
+       */
+      g_dbus_connection_flush (session_bus, NULL, NULL, NULL);
+      g_object_unref (session_bus);
+    }
+
+  completed = TRUE;
+
+ out:
+  g_strfreev (argv);
+
+  return completed;
+}
+
+static gboolean
+g_desktop_app_info_launch_uris (GAppInfo           *appinfo,
+				GList              *uris,
+				GAppLaunchContext  *launch_context,
+				GError            **error)
+{
+  return _g_desktop_app_info_launch_uris_internal (appinfo, uris,
+						   launch_context,
+						   _SPAWN_FLAGS_DEFAULT,
+						   NULL, NULL, NULL, NULL,
+						   error);
+}
+
+static gboolean
+g_desktop_app_info_supports_uris (GAppInfo *appinfo)
+{
+  GDesktopAppInfo *info = G_DESKTOP_APP_INFO (appinfo);
+ 
+  return info->exec && 
+    ((strstr (info->exec, "%u") != NULL) ||
+     (strstr (info->exec, "%U") != NULL));
+}
+
+static gboolean
+g_desktop_app_info_supports_files (GAppInfo *appinfo)
+{
+  GDesktopAppInfo *info = G_DESKTOP_APP_INFO (appinfo);
+ 
+  return info->exec && 
+    ((strstr (info->exec, "%f") != NULL) ||
+     (strstr (info->exec, "%F") != NULL));
+}
+
+static gboolean
+g_desktop_app_info_launch (GAppInfo           *appinfo,
+			   GList              *files,
+			   GAppLaunchContext  *launch_context,
+			   GError            **error)
+{
+  GList *uris;
+  char *uri;
+  gboolean res;
+
+  uris = NULL;
+  while (files)
+    {
+      uri = g_file_get_uri (files->data);
+      uris = g_list_prepend (uris, uri);
+      files = files->next;
+    }
+  
+  uris = g_list_reverse (uris);
+  
+  res = g_desktop_app_info_launch_uris (appinfo, uris, launch_context, error);
+  
+  g_list_foreach  (uris, (GFunc)g_free, NULL);
+  g_list_free (uris);
+  
+  return res;
+}
+
+/**
+ * g_desktop_app_info_launch_uris_as_manager:
+ * @appinfo: a #GDesktopAppInfo
+ * @uris: (element-type utf8): List of URIs
+ * @launch_context: a #GAppLaunchContext
+ * @spawn_flags: #GSpawnFlags, used for each process
+ * @user_setup: (scope call): a #GSpawnChildSetupFunc, used once for
+ *     each process.
+ * @user_setup_data: (closure user_setup): User data for @user_setup
+ * @pid_callback: (scope call): Callback for child processes
+ * @pid_callback_data: (closure pid_callback): User data for @callback
+ * @error: a #GError
+ *
+ * This function performs the equivalent of g_app_info_launch_uris(),
+ * but is intended primarily for operating system components that
+ * launch applications.  Ordinary applications should use
+ * g_app_info_launch_uris().
+ *
+ * In contrast to g_app_info_launch_uris(), all processes created will
+ * always be run directly as children as if by the UNIX fork()/exec()
+ * calls.
+ *
+ * This guarantee allows additional control over the exact environment
+ * of the child processes, which is provided via a setup function
+ * @setup, as well as the process identifier of each child process via
+ * @pid_callback.  See g_spawn_async() for more information about the
+ * semantics of the @setup function.
+ */
+gboolean
+g_desktop_app_info_launch_uris_as_manager (GDesktopAppInfo            *appinfo,
+					   GList                      *uris,
+					   GAppLaunchContext          *launch_context,
+					   GSpawnFlags                 spawn_flags,
+					   GSpawnChildSetupFunc        user_setup,
+					   gpointer                    user_setup_data,
+					   GDesktopAppLaunchCallback   pid_callback,
+					   gpointer                    pid_callback_data,
+					   GError                    **error)
+{
+  return _g_desktop_app_info_launch_uris_internal ((GAppInfo*)appinfo,
+						   uris,
+						   launch_context,
+						   spawn_flags,
+						   user_setup,
+						   user_setup_data,
+						   pid_callback,
+						   pid_callback_data,
+						   error);
+}
+
+G_LOCK_DEFINE_STATIC (g_desktop_env);
+static gchar *g_desktop_env = NULL;
+
+/**
+ * g_desktop_app_info_set_desktop_env:
+ * @desktop_env: a string specifying what desktop this is
+ *
+ * Sets the name of the desktop that the application is running in.
+ * This is used by g_app_info_should_show() to evaluate the
+ * <literal>OnlyShowIn</literal> and <literal>NotShowIn</literal>
+ * desktop entry fields.
+ *
+ * The <ulink url="http://standards.freedesktop.org/menu-spec/latest/">Desktop 
+ * Menu specification</ulink> recognizes the following:
+ * <simplelist>
+ *   <member>GNOME</member>
+ *   <member>KDE</member>
+ *   <member>ROX</member>
+ *   <member>XFCE</member>
+ *   <member>Old</member> 
+ * </simplelist>
+ *
+ * Should be called only once; subsequent calls are ignored.
+ */
+void
+g_desktop_app_info_set_desktop_env (const gchar *desktop_env)
+{
+  G_LOCK (g_desktop_env);
+  if (!g_desktop_env)
+    g_desktop_env = g_strdup (desktop_env);
+  G_UNLOCK (g_desktop_env);
+}
+
+static gboolean
+g_desktop_app_info_should_show (GAppInfo *appinfo)
+{
+  GDesktopAppInfo *info = G_DESKTOP_APP_INFO (appinfo);
+  gboolean found;
+  const gchar *desktop_env;
+  int i;
+
+  if (info->nodisplay)
+    return FALSE;
+
+  G_LOCK (g_desktop_env);
+  desktop_env = g_desktop_env;
+  G_UNLOCK (g_desktop_env);
+
+  if (info->only_show_in)
+    {
+      if (desktop_env == NULL)
+	return FALSE;
+      
+      found = FALSE;
+      for (i = 0; info->only_show_in[i] != NULL; i++)
+	{
+	  if (strcmp (info->only_show_in[i], desktop_env) == 0)
+	    {
+	      found = TRUE;
+	      break;
+	    }
+	}
+      if (!found)
+	return FALSE;
+    }
+
+  if (info->not_show_in && desktop_env)
+    {
+      for (i = 0; info->not_show_in[i] != NULL; i++)
+	{
+	  if (strcmp (info->not_show_in[i], desktop_env) == 0)
+	    return FALSE;
+	}
+    }
+  
+  return TRUE;
+}
+
+typedef enum {
+  APP_DIR,
+  MIMETYPE_DIR
+} DirType;
+
+static char *
+ensure_dir (DirType   type,
+            GError  **error)
+{
+  char *path, *display_name;
+  int errsv;
+
+  if (type == APP_DIR)
+    path = g_build_filename (g_get_user_data_dir (), "applications", NULL);
+  else
+    path = g_build_filename (g_get_user_data_dir (), "mime", "packages", NULL);
+
+  errno = 0;
+  if (g_mkdir_with_parents (path, 0700) == 0)
+    return path;
+
+  errsv = errno;
+  display_name = g_filename_display_name (path);
+  if (type == APP_DIR)
+    g_set_error (error, G_IO_ERROR, g_io_error_from_errno (errsv),
+                 _("Can't create user application configuration folder %s: %s"),
+                 display_name, g_strerror (errsv));
+  else
+    g_set_error (error, G_IO_ERROR, g_io_error_from_errno (errsv),
+                 _("Can't create user MIME configuration folder %s: %s"),
+                 display_name, g_strerror (errsv));
+
+  g_free (display_name);
+  g_free (path);
+
+  return NULL;
+}
+
+static gboolean
+update_mimeapps_list (const char  *desktop_id, 
+		      const char  *content_type,
+                      UpdateMimeFlags flags,
+		      GError     **error)
+{
+  char *dirname, *filename, *string;
+  GKeyFile *key_file;
+  gboolean load_succeeded, res, explicit_default;
+  char **old_list, **list;
+  GList *system_list;
+  gsize length, data_size;
+  char *data;
+  int i, j, k;
+  char **content_types;
+
+  /* Don't add both at start and end */
+  g_assert (!((flags & UPDATE_MIME_SET_DEFAULT) &&
+              (flags & UPDATE_MIME_SET_NON_DEFAULT)));
+
+  dirname = ensure_dir (APP_DIR, error);
+  if (!dirname)
+    return FALSE;
+
+  filename = g_build_filename (dirname, "mimeapps.list", NULL);
+  g_free (dirname);
+
+  key_file = g_key_file_new ();
+  load_succeeded = g_key_file_load_from_file (key_file, filename, G_KEY_FILE_NONE, NULL);
+  if (!load_succeeded || !g_key_file_has_group (key_file, ADDED_ASSOCIATIONS_GROUP))
+    {
+      g_key_file_free (key_file);
+      key_file = g_key_file_new ();
+    }
+
+  if (content_type)
+    {
+      content_types = g_new (char *, 2);
+      content_types[0] = g_strdup (content_type);
+      content_types[1] = NULL;
+    }
+  else
+    {
+      content_types = g_key_file_get_keys (key_file, DEFAULT_APPLICATIONS_GROUP, NULL, NULL);
+    }
+
+  explicit_default = FALSE;
+
+  for (k = 0; content_types && content_types[k]; k++)
+    {
+      /* set as default, if requested so */
+      string = g_key_file_get_string (key_file,
+                                      DEFAULT_APPLICATIONS_GROUP,
+                                      content_types[k],
+                                      NULL);
+
+      if (g_strcmp0 (string, desktop_id) != 0 &&
+          (flags & UPDATE_MIME_SET_DEFAULT))
+        {
+          g_free (string);
+          string = g_strdup (desktop_id);
+
+          /* add in the non-default list too, if it's not already there */
+          flags |= UPDATE_MIME_SET_NON_DEFAULT;
+        }
+
+      if (string == NULL || desktop_id == NULL)
+        g_key_file_remove_key (key_file,
+                               DEFAULT_APPLICATIONS_GROUP,
+                               content_types[k],
+                               NULL);
+      else
+        {
+          g_key_file_set_string (key_file,
+                                 DEFAULT_APPLICATIONS_GROUP,
+                                 content_types[k],
+                                 string);
+
+          explicit_default = TRUE;
+        }
+
+      g_free (string);
+    }
+
+  if (content_type)
+    {
+      /* reuse the list from above */
+    }
+  else
+    {
+      g_strfreev (content_types);
+      content_types = g_key_file_get_keys (key_file, ADDED_ASSOCIATIONS_GROUP, NULL, NULL);
+    }
+  
+  for (k = 0; content_types && content_types[k]; k++)
+    { 
+      /* Add to the right place in the list */
+  
+      length = 0;
+      old_list = g_key_file_get_string_list (key_file, ADDED_ASSOCIATIONS_GROUP,
+					     content_types[k], &length, NULL);
+
+      list = g_new (char *, 1 + length + 1);
+
+      i = 0;
+
+      /* if we're adding a last-used hint, just put the application in front of the list */
+      if (flags & UPDATE_MIME_SET_LAST_USED)
+        {
+          /* avoid adding this again as non-default later */
+          if (flags & UPDATE_MIME_SET_NON_DEFAULT)
+            flags ^= UPDATE_MIME_SET_NON_DEFAULT;
+
+          list[i++] = g_strdup (desktop_id);
+        }
+
+      if (old_list)
+        {
+          for (j = 0; old_list[j] != NULL; j++)
+	    {
+	      if (g_strcmp0 (old_list[j], desktop_id) != 0)
+                {
+                  /* rewrite other entries if they're different from the new one */
+                  list[i++] = g_strdup (old_list[j]);
+                }
+	      else if (flags & UPDATE_MIME_SET_NON_DEFAULT)
+		{
+                  /* we encountered an old entry which is equal to the one we're adding as non-default,
+                   * don't change its position in the list.
+                   */
+		  flags ^= UPDATE_MIME_SET_NON_DEFAULT;
+		  list[i++] = g_strdup (old_list[j]);
+		}
+	    }
+        }
+
+      /* add it at the end of the list */
+      if (flags & UPDATE_MIME_SET_NON_DEFAULT)
+        list[i++] = g_strdup (desktop_id);
+
+      list[i] = NULL;
+  
+      g_strfreev (old_list);
+
+      if (list[0] == NULL || desktop_id == NULL)
+        g_key_file_remove_key (key_file,
+			       ADDED_ASSOCIATIONS_GROUP,
+			       content_types[k],
+			       NULL);
+      else
+        {
+          g_key_file_set_string_list (key_file,
+                                      ADDED_ASSOCIATIONS_GROUP,
+                                      content_types[k],
+                                      (const char * const *)list, i);
+
+          /* if we had no explicit default set, we should add the system default to the
+           * list, to avoid overriding it with applications from this list.
+           */
+          if (!explicit_default)
+            {
+              system_list = get_all_desktop_entries_for_mime_type (content_type, (const char **) list, FALSE, NULL);
+
+              if (system_list != NULL)
+                {
+                  string = system_list->data;
+
+                  g_key_file_set_string (key_file,
+                                         DEFAULT_APPLICATIONS_GROUP,
+                                         content_types[k],
+                                         string);
+                }
+
+              g_list_free_full (system_list, g_free);
+            }
+        }
+   
+      g_strfreev (list);
+    }
+  
+  if (content_type)
+    {
+      /* reuse the list from above */
+    }
+  else
+    {
+      g_strfreev (content_types);
+      content_types = g_key_file_get_keys (key_file, REMOVED_ASSOCIATIONS_GROUP, NULL, NULL);
+    }
+
+  for (k = 0; content_types && content_types[k]; k++) 
+    {
+      /* Remove from removed associations group (unless remove) */
+  
+      length = 0;
+      old_list = g_key_file_get_string_list (key_file, REMOVED_ASSOCIATIONS_GROUP,
+					     content_types[k], &length, NULL);
+
+      list = g_new (char *, 1 + length + 1);
+
+      i = 0;
+      if (flags & UPDATE_MIME_REMOVE)
+        list[i++] = g_strdup (desktop_id);
+      if (old_list)
+        {
+          for (j = 0; old_list[j] != NULL; j++)
+	    {
+	      if (g_strcmp0 (old_list[j], desktop_id) != 0)
+	        list[i++] = g_strdup (old_list[j]);
+	    }
+        }
+      list[i] = NULL;
+  
+      g_strfreev (old_list);
+
+      if (list[0] == NULL || desktop_id == NULL)
+        g_key_file_remove_key (key_file,
+			       REMOVED_ASSOCIATIONS_GROUP,
+			       content_types[k],
+			       NULL);
+      else
+        g_key_file_set_string_list (key_file,
+				    REMOVED_ASSOCIATIONS_GROUP,
+				    content_types[k],
+				    (const char * const *)list, i);
+
+      g_strfreev (list);
+    }
+
+  g_strfreev (content_types);  
+
+  data = g_key_file_to_data (key_file, &data_size, error);
+  g_key_file_free (key_file);
+  
+  res = g_file_set_contents (filename, data, data_size, error);
+
+  mime_info_cache_reload (NULL);
+			  
+  g_free (filename);
+  g_free (data);
+  
+  return res;
+}
+
+static gboolean
+g_desktop_app_info_set_as_last_used_for_type (GAppInfo    *appinfo,
+                                              const char  *content_type,
+                                              GError     **error)
+{
+  GDesktopAppInfo *info = G_DESKTOP_APP_INFO (appinfo);
+
+  if (!g_desktop_app_info_ensure_saved (info, error))
+    return FALSE;
+
+  /* both add support for the content type and set as last used */
+  return update_mimeapps_list (info->desktop_id, content_type,
+                               UPDATE_MIME_SET_NON_DEFAULT |
+                               UPDATE_MIME_SET_LAST_USED,
+                               error);
+}
+
+static gboolean
+g_desktop_app_info_set_as_default_for_type (GAppInfo    *appinfo,
+					    const char  *content_type,
+					    GError     **error)
+{
+  GDesktopAppInfo *info = G_DESKTOP_APP_INFO (appinfo);
+
+  if (!g_desktop_app_info_ensure_saved (info, error))
+    return FALSE;  
+  
+  return update_mimeapps_list (info->desktop_id, content_type,
+                               UPDATE_MIME_SET_DEFAULT,
+                               error);
+}
+
+static void
+update_program_done (GPid     pid,
+		     gint     status,
+		     gpointer data)
+{
+  /* Did the application exit correctly */
+  if (WIFEXITED (status) &&
+      WEXITSTATUS (status) == 0)
+    {
+      /* Here we could clean out any caches in use */
+    }
+}
+
+static void
+run_update_command (char *command,
+		    char *subdir)
+{
+	char *argv[3] = {
+		NULL,
+		NULL,
+		NULL,
+	};
+	GPid pid = 0;
+	GError *error = NULL;
+
+	argv[0] = command;
+	argv[1] = g_build_filename (g_get_user_data_dir (), subdir, NULL);
+
+	if (g_spawn_async ("/", argv,
+			   NULL,       /* envp */
+			   G_SPAWN_SEARCH_PATH |
+			   G_SPAWN_STDOUT_TO_DEV_NULL |
+			   G_SPAWN_STDERR_TO_DEV_NULL |
+			   G_SPAWN_DO_NOT_REAP_CHILD,
+			   NULL, NULL, /* No setup function */
+			   &pid,
+			   &error)) 
+	  g_child_watch_add (pid, update_program_done, NULL);
+	else
+	  {
+	    /* If we get an error at this point, it's quite likely the user doesn't
+	     * have an installed copy of either 'update-mime-database' or
+	     * 'update-desktop-database'.  I don't think we want to popup an error
+	     * dialog at this point, so we just do a g_warning to give the user a
+	     * chance of debugging it.
+	     */
+	    g_warning ("%s", error->message);
+	  }
+	
+	g_free (argv[1]);
+}
+
+static gboolean
+g_desktop_app_info_set_as_default_for_extension (GAppInfo    *appinfo,
+						 const char  *extension,
+						 GError     **error)
+{
+  char *filename, *basename, *mimetype;
+  char *dirname;
+  gboolean res;
+
+  if (!g_desktop_app_info_ensure_saved (G_DESKTOP_APP_INFO (appinfo), error))
+    return FALSE;  
+  
+  dirname = ensure_dir (MIMETYPE_DIR, error);
+  if (!dirname)
+    return FALSE;
+  
+  basename = g_strdup_printf ("user-extension-%s.xml", extension);
+  filename = g_build_filename (dirname, basename, NULL);
+  g_free (basename);
+  g_free (dirname);
+
+  mimetype = g_strdup_printf ("application/x-extension-%s", extension);
+  
+  if (!g_file_test (filename, G_FILE_TEST_EXISTS)) 
+    {
+      char *contents;
+
+      contents =
+        g_strdup_printf ("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
+                         "<mime-info xmlns=\"http://www.freedesktop.org/standards/shared-mime-info\">\n"
+                         " <mime-type type=\"%s\">\n"
+                         "  <comment>%s document</comment>\n"
+                         "  <glob pattern=\"*.%s\"/>\n"
+                         " </mime-type>\n"
+                         "</mime-info>\n", mimetype, extension, extension);
+
+      g_file_set_contents (filename, contents, -1, NULL);
+      g_free (contents);
+
+      run_update_command ("update-mime-database", "mime");
+    }
+  g_free (filename);
+  
+  res = g_desktop_app_info_set_as_default_for_type (appinfo,
+						    mimetype,
+						    error);
+
+  g_free (mimetype);
+  
+  return res;
+}
+
+static gboolean
+g_desktop_app_info_add_supports_type (GAppInfo    *appinfo,
+				      const char  *content_type,
+				      GError     **error)
+{
+  GDesktopAppInfo *info = G_DESKTOP_APP_INFO (appinfo);
+
+  if (!g_desktop_app_info_ensure_saved (G_DESKTOP_APP_INFO (info), error))
+    return FALSE;  
+  
+  return update_mimeapps_list (info->desktop_id, content_type,
+                               UPDATE_MIME_SET_NON_DEFAULT,
+                               error);
+}
+
+static gboolean
+g_desktop_app_info_can_remove_supports_type (GAppInfo *appinfo)
+{
+  return TRUE;
+}
+
+static gboolean
+g_desktop_app_info_remove_supports_type (GAppInfo    *appinfo,
+					 const char  *content_type,
+					 GError     **error)
+{
+  GDesktopAppInfo *info = G_DESKTOP_APP_INFO (appinfo);
+
+  if (!g_desktop_app_info_ensure_saved (G_DESKTOP_APP_INFO (info), error))
+    return FALSE;
+  
+  return update_mimeapps_list (info->desktop_id, content_type,
+                               UPDATE_MIME_REMOVE,
+                               error);
+}
+
+static gboolean
+g_desktop_app_info_ensure_saved (GDesktopAppInfo  *info,
+				 GError          **error)
+{
+  GKeyFile *key_file;
+  char *dirname;
+  char *filename;
+  char *data, *desktop_id;
+  gsize data_size;
+  int fd;
+  gboolean res;
+  
+  if (info->filename != NULL)
+    return TRUE;
+
+  /* This is only used for object created with
+   * g_app_info_create_from_commandline. All other
+   * object should have a filename
+   */
+  
+  dirname = ensure_dir (APP_DIR, error);
+  if (!dirname)
+    return FALSE;
+  
+  key_file = g_key_file_new ();
+
+  g_key_file_set_string (key_file, G_KEY_FILE_DESKTOP_GROUP,
+			 "Encoding", "UTF-8");
+  g_key_file_set_string (key_file, G_KEY_FILE_DESKTOP_GROUP,
+			 G_KEY_FILE_DESKTOP_KEY_VERSION, "1.0");
+  g_key_file_set_string (key_file, G_KEY_FILE_DESKTOP_GROUP,
+			 G_KEY_FILE_DESKTOP_KEY_TYPE,
+                         G_KEY_FILE_DESKTOP_TYPE_APPLICATION);
+  if (info->terminal) 
+    g_key_file_set_boolean (key_file, G_KEY_FILE_DESKTOP_GROUP,
+			    G_KEY_FILE_DESKTOP_KEY_TERMINAL, TRUE);
+
+  g_key_file_set_string (key_file, G_KEY_FILE_DESKTOP_GROUP,
+			 G_KEY_FILE_DESKTOP_KEY_EXEC, info->exec);
+
+  g_key_file_set_string (key_file, G_KEY_FILE_DESKTOP_GROUP,
+			 G_KEY_FILE_DESKTOP_KEY_NAME, info->name);
+
+  if (info->fullname != NULL)
+    g_key_file_set_string (key_file, G_KEY_FILE_DESKTOP_GROUP,
+			   FULL_NAME_KEY, info->fullname);
+
+  g_key_file_set_string (key_file, G_KEY_FILE_DESKTOP_GROUP,
+			 G_KEY_FILE_DESKTOP_KEY_COMMENT, info->comment);
+  
+  g_key_file_set_boolean (key_file, G_KEY_FILE_DESKTOP_GROUP,
+			  G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY, TRUE);
+
+  data = g_key_file_to_data (key_file, &data_size, NULL);
+  g_key_file_free (key_file);
+
+  desktop_id = g_strdup_printf ("userapp-%s-XXXXXX.desktop", info->name);
+  filename = g_build_filename (dirname, desktop_id, NULL);
+  g_free (desktop_id);
+  g_free (dirname);
+  
+  fd = g_mkstemp (filename);
+  if (fd == -1)
+    {
+      char *display_name;
+
+      display_name = g_filename_display_name (filename);
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+		   _("Can't create user desktop file %s"), display_name);
+      g_free (display_name);
+      g_free (filename);
+      g_free (data);
+      return FALSE;
+    }
+
+  desktop_id = g_path_get_basename (filename);
+
+  close (fd);
+  
+  res = g_file_set_contents (filename, data, data_size, error);
+  if (!res)
+    {
+      g_free (desktop_id);
+      g_free (filename);
+      return FALSE;
+    }
+
+  info->filename = filename;
+  info->desktop_id = desktop_id;
+  
+  run_update_command ("update-desktop-database", "applications");
+  
+  return TRUE;
+}
+
+static gboolean
+g_desktop_app_info_can_delete (GAppInfo *appinfo)
+{
+  GDesktopAppInfo *info = G_DESKTOP_APP_INFO (appinfo);
+
+  if (info->filename)
+    {
+      if (strstr (info->filename, "/userapp-"))
+        return g_access (info->filename, W_OK) == 0;
+    }
+
+  return FALSE;
+}
+
+static gboolean
+g_desktop_app_info_delete (GAppInfo *appinfo)
+{
+  GDesktopAppInfo *info = G_DESKTOP_APP_INFO (appinfo);
+  
+  if (info->filename)
+    { 
+      if (g_remove (info->filename) == 0)
+        {
+          update_mimeapps_list (info->desktop_id, NULL,
+                                UPDATE_MIME_NONE,
+                                NULL);
+
+          g_free (info->filename);
+          info->filename = NULL;
+          g_free (info->desktop_id);
+          info->desktop_id = NULL;
+
+          return TRUE;
+        }
+    }
+
+  return FALSE;
+}
+
+/**
+ * g_app_info_create_from_commandline:
+ * @commandline: the commandline to use
+ * @application_name: (allow-none): the application name, or %NULL to use @commandline
+ * @flags: flags that can specify details of the created #GAppInfo
+ * @error: a #GError location to store the error occuring, %NULL to ignore.
+ *
+ * Creates a new #GAppInfo from the given information.
+ *
+ * Returns: (transfer full): new #GAppInfo for given command.
+ **/
+GAppInfo *
+g_app_info_create_from_commandline (const char           *commandline,
+				    const char           *application_name,
+				    GAppInfoCreateFlags   flags,
+				    GError              **error)
+{
+  char **split;
+  char *basename;
+  GDesktopAppInfo *info;
+
+  g_return_val_if_fail (commandline, NULL);
+
+  info = g_object_new (G_TYPE_DESKTOP_APP_INFO, NULL);
+
+  info->filename = NULL;
+  info->desktop_id = NULL;
+  
+  info->terminal = (flags & G_APP_INFO_CREATE_NEEDS_TERMINAL) != 0;
+  info->startup_notify = (flags & G_APP_INFO_CREATE_SUPPORTS_STARTUP_NOTIFICATION) != 0;
+  info->hidden = FALSE;
+  if ((flags & G_APP_INFO_CREATE_SUPPORTS_URIS) != 0)
+    info->exec = g_strconcat (commandline, " %u", NULL);
+  else
+    info->exec = g_strconcat (commandline, " %f", NULL);
+  info->nodisplay = TRUE;
+  info->binary = binary_from_exec (info->exec);
+  
+  if (application_name)
+    info->name = g_strdup (application_name);
+  else
+    {
+      /* FIXME: this should be more robust. Maybe g_shell_parse_argv and use argv[0] */
+      split = g_strsplit (commandline, " ", 2);
+      basename = split[0] ? g_path_get_basename (split[0]) : NULL;
+      g_strfreev (split);
+      info->name = basename;
+      if (info->name == NULL)
+	info->name = g_strdup ("custom");
+    }
+  info->comment = g_strdup_printf (_("Custom definition for %s"), info->name);
+  
+  return G_APP_INFO (info);
+}
+
+static void
+g_desktop_app_info_iface_init (GAppInfoIface *iface)
+{
+  iface->dup = g_desktop_app_info_dup;
+  iface->equal = g_desktop_app_info_equal;
+  iface->get_id = g_desktop_app_info_get_id;
+  iface->get_name = g_desktop_app_info_get_name;
+  iface->get_description = g_desktop_app_info_get_description;
+  iface->get_executable = g_desktop_app_info_get_executable;
+  iface->get_icon = g_desktop_app_info_get_icon;
+  iface->launch = g_desktop_app_info_launch;
+  iface->supports_uris = g_desktop_app_info_supports_uris;
+  iface->supports_files = g_desktop_app_info_supports_files;
+  iface->launch_uris = g_desktop_app_info_launch_uris;
+  iface->should_show = g_desktop_app_info_should_show;
+  iface->set_as_default_for_type = g_desktop_app_info_set_as_default_for_type;
+  iface->set_as_default_for_extension = g_desktop_app_info_set_as_default_for_extension;
+  iface->add_supports_type = g_desktop_app_info_add_supports_type;
+  iface->can_remove_supports_type = g_desktop_app_info_can_remove_supports_type;
+  iface->remove_supports_type = g_desktop_app_info_remove_supports_type;
+  iface->can_delete = g_desktop_app_info_can_delete;
+  iface->do_delete = g_desktop_app_info_delete;
+  iface->get_commandline = g_desktop_app_info_get_commandline;
+  iface->get_display_name = g_desktop_app_info_get_display_name;
+  iface->set_as_last_used_for_type = g_desktop_app_info_set_as_last_used_for_type;
+}
+
+static gboolean
+app_info_in_list (GAppInfo *info, 
+                  GList    *list)
+{
+  while (list != NULL)
+    {
+      if (g_app_info_equal (info, list->data))
+	return TRUE;
+      list = list->next;
+    }
+  return FALSE;
+}
+
+/**
+ * g_app_info_get_recommended_for_type:
+ * @content_type: the content type to find a #GAppInfo for
+ * 
+ * Gets a list of recommended #GAppInfos for a given content type, i.e.
+ * those applications which claim to support the given content type exactly,
+ * and not by MIME type subclassing.
+ * Note that the first application of the list is the last used one, i.e.
+ * the last one for which #g_app_info_set_as_last_used_for_type has been
+ * called.
+ *
+ * Returns: (element-type GAppInfo) (transfer full): #GList of #GAppInfos
+ *     for given @content_type or %NULL on error.
+ *
+ * Since: 2.28
+ **/
+GList *
+g_app_info_get_recommended_for_type (const gchar *content_type)
+{
+  GList *desktop_entries, *l;
+  GList *infos;
+  GDesktopAppInfo *info;
+
+  g_return_val_if_fail (content_type != NULL, NULL);
+
+  desktop_entries = get_all_desktop_entries_for_mime_type (content_type, NULL, FALSE, NULL);
+
+  infos = NULL;
+  for (l = desktop_entries; l != NULL; l = l->next)
+    {
+      char *desktop_entry = l->data;
+
+      info = g_desktop_app_info_new (desktop_entry);
+      if (info)
+	{
+	  if (app_info_in_list (G_APP_INFO (info), infos))
+	    g_object_unref (info);
+	  else
+	    infos = g_list_prepend (infos, info);
+	}
+      g_free (desktop_entry);
+    }
+
+  g_list_free (desktop_entries);
+
+  return g_list_reverse (infos);
+}
+
+/**
+ * g_app_info_get_fallback_for_type:
+ * @content_type: the content type to find a #GAppInfo for
+ * 
+ * Gets a list of fallback #GAppInfos for a given content type, i.e.
+ * those applications which claim to support the given content type
+ * by MIME type subclassing and not directly.
+ *
+ * Returns: (element-type GAppInfo) (transfer full): #GList of #GAppInfos
+ *     for given @content_type or %NULL on error.
+ *
+ * Since: 2.28
+ **/
+GList *
+g_app_info_get_fallback_for_type (const gchar *content_type)
+{
+  GList *desktop_entries, *l;
+  GList *infos, *recommended_infos;
+  GDesktopAppInfo *info;
+
+  g_return_val_if_fail (content_type != NULL, NULL);
+
+  desktop_entries = get_all_desktop_entries_for_mime_type (content_type, NULL, TRUE, NULL);
+  recommended_infos = g_app_info_get_recommended_for_type (content_type);
+
+  infos = NULL;
+  for (l = desktop_entries; l != NULL; l = l->next)
+    {
+      char *desktop_entry = l->data;
+
+      info = g_desktop_app_info_new (desktop_entry);
+      if (info)
+	{
+	  if (app_info_in_list (G_APP_INFO (info), infos) ||
+	      app_info_in_list (G_APP_INFO (info), recommended_infos))
+	    g_object_unref (info);
+	  else
+	    infos = g_list_prepend (infos, info);
+	}
+      g_free (desktop_entry);
+    }
+
+  g_list_free (desktop_entries);
+  g_list_free_full (recommended_infos, g_object_unref);
+
+  return g_list_reverse (infos);
+}
+
+/**
+ * g_app_info_get_all_for_type:
+ * @content_type: the content type to find a #GAppInfo for
+ * 
+ * Gets a list of all #GAppInfos for a given content type.
+ *
+ * Returns: (element-type GAppInfo) (transfer full): #GList of #GAppInfos
+ *     for given @content_type or %NULL on error.
+ **/
+GList *
+g_app_info_get_all_for_type (const char *content_type)
+{
+  GList *desktop_entries, *l;
+  GList *infos;
+  char *user_default = NULL;
+  GDesktopAppInfo *info;
+
+  g_return_val_if_fail (content_type != NULL, NULL);
+  
+  desktop_entries = get_all_desktop_entries_for_mime_type (content_type, NULL, TRUE, &user_default);
+  infos = NULL;
+
+  /* put the user default in front of the list, for compatibility */
+  if (user_default != NULL)
+    {
+      info = g_desktop_app_info_new (user_default);
+
+      if (info != NULL)
+        infos = g_list_prepend (infos, info);
+    }
+
+  g_free (user_default);
+
+  for (l = desktop_entries; l != NULL; l = l->next)
+    {
+      char *desktop_entry = l->data;
+
+      info = g_desktop_app_info_new (desktop_entry);
+      if (info)
+	{
+	  if (app_info_in_list (G_APP_INFO (info), infos))
+	    g_object_unref (info);
+	  else
+	    infos = g_list_prepend (infos, info);
+	}
+      g_free (desktop_entry);
+    }
+
+  g_list_free (desktop_entries);
+  
+  return g_list_reverse (infos);
+}
+
+/**
+ * g_app_info_reset_type_associations:
+ * @content_type: a content type 
+ *
+ * Removes all changes to the type associations done by
+ * g_app_info_set_as_default_for_type(), 
+ * g_app_info_set_as_default_for_extension(), 
+ * g_app_info_add_supports_type() or g_app_info_remove_supports_type().
+ *
+ * Since: 2.20
+ */
+void
+g_app_info_reset_type_associations (const char *content_type)
+{
+  update_mimeapps_list (NULL, content_type,
+                        UPDATE_MIME_NONE,
+                        NULL);
+}
+
+/**
+ * g_app_info_get_default_for_type:
+ * @content_type: the content type to find a #GAppInfo for
+ * @must_support_uris: if %TRUE, the #GAppInfo is expected to
+ *     support URIs
+ * 
+ * Gets the #GAppInfo that corresponds to a given content type.
+ *
+ * Returns: (transfer full): #GAppInfo for given @content_type or
+ *     %NULL on error.
+ **/
+GAppInfo *
+g_app_info_get_default_for_type (const char *content_type,
+				 gboolean    must_support_uris)
+{
+  GList *desktop_entries, *l;
+  char *user_default = NULL;
+  GAppInfo *info;
+
+  g_return_val_if_fail (content_type != NULL, NULL);
+  
+  desktop_entries = get_all_desktop_entries_for_mime_type (content_type, NULL, TRUE, &user_default);
+
+  info = NULL;
+
+  if (user_default != NULL)
+    {
+      info = (GAppInfo *) g_desktop_app_info_new (user_default);
+
+      if (info)
+        {
+	  if (must_support_uris && !g_app_info_supports_uris (info))
+	    {
+	      g_object_unref (info);
+	      info = NULL;
+	    }
+        }
+    }
+
+  g_free (user_default);
+
+  if (info != NULL)
+    {
+      g_list_free_full (desktop_entries, g_free);
+      return info;
+    }
+
+  /* pick the first from the other list that matches our URI
+   * requirements.
+   */
+  for (l = desktop_entries; l != NULL; l = l->next)
+    {
+      char *desktop_entry = l->data;
+
+      info = (GAppInfo *)g_desktop_app_info_new (desktop_entry);
+      if (info)
+	{
+	  if (must_support_uris && !g_app_info_supports_uris (info))
+	    {
+	      g_object_unref (info);
+	      info = NULL;
+	    }
+	  else
+	    break;
+	}
+    }
+  
+  g_list_free_full (desktop_entries, g_free);
+
+  return info;
+}
+
+/**
+ * g_app_info_get_default_for_uri_scheme:
+ * @uri_scheme: a string containing a URI scheme.
+ *
+ * Gets the default application for launching applications 
+ * using this URI scheme. A URI scheme is the initial part 
+ * of the URI, up to but not including the ':', e.g. "http", 
+ * "ftp" or "sip".
+ * 
+ * Returns: (transfer full): #GAppInfo for given @uri_scheme or %NULL on error.
+ **/
+GAppInfo *
+g_app_info_get_default_for_uri_scheme (const char *uri_scheme)
+{
+  GAppInfo *app_info;
+  char *content_type, *scheme_down;
+
+  scheme_down = g_ascii_strdown (uri_scheme, -1);
+  content_type = g_strdup_printf ("x-scheme-handler/%s", scheme_down);
+  g_free (scheme_down);
+  app_info = g_app_info_get_default_for_type (content_type, FALSE);
+  g_free (content_type);
+
+  return app_info;
+}
+
+static void
+get_apps_from_dir (GHashTable *apps, 
+                   const char *dirname, 
+                   const char *prefix)
+{
+  GDir *dir;
+  const char *basename;
+  char *filename, *subprefix, *desktop_id;
+  gboolean hidden;
+  GDesktopAppInfo *appinfo;
+  
+  dir = g_dir_open (dirname, 0, NULL);
+  if (dir)
+    {
+      while ((basename = g_dir_read_name (dir)) != NULL)
+	{
+	  filename = g_build_filename (dirname, basename, NULL);
+	  if (g_str_has_suffix (basename, ".desktop"))
+	    {
+	      desktop_id = g_strconcat (prefix, basename, NULL);
+
+	      /* Use _extended so we catch NULLs too (hidden) */
+	      if (!g_hash_table_lookup_extended (apps, desktop_id, NULL, NULL))
+		{
+		  appinfo = g_desktop_app_info_new_from_filename (filename);
+                  hidden = FALSE;
+
+		  if (appinfo && g_desktop_app_info_get_is_hidden (appinfo))
+		    {
+		      g_object_unref (appinfo);
+		      appinfo = NULL;
+		      hidden = TRUE;
+		    }
+				      
+		  if (appinfo || hidden)
+		    {
+		      g_hash_table_insert (apps, g_strdup (desktop_id), appinfo);
+
+		      if (appinfo)
+			{
+			  /* Reuse instead of strdup here */
+			  appinfo->desktop_id = desktop_id;
+			  desktop_id = NULL;
+			}
+		    }
+		}
+	      g_free (desktop_id);
+	    }
+	  else
+	    {
+	      if (g_file_test (filename, G_FILE_TEST_IS_DIR))
+		{
+		  subprefix = g_strconcat (prefix, basename, "-", NULL);
+		  get_apps_from_dir (apps, filename, subprefix);
+		  g_free (subprefix);
+		}
+	    }
+	  g_free (filename);
+	}
+      g_dir_close (dir);
+    }
+}
+
+
+/**
+ * g_app_info_get_all:
+ *
+ * Gets a list of all of the applications currently registered 
+ * on this system.
+ * 
+ * For desktop files, this includes applications that have 
+ * <literal>NoDisplay=true</literal> set or are excluded from 
+ * display by means of <literal>OnlyShowIn</literal> or
+ * <literal>NotShowIn</literal>. See g_app_info_should_show().
+ * The returned list does not include applications which have
+ * the <literal>Hidden</literal> key set. 
+ * 
+ * Returns: (element-type GAppInfo) (transfer full): a newly allocated #GList of references to #GAppInfo<!---->s.
+ **/
+GList *
+g_app_info_get_all (void)
+{
+  const char * const *dirs;
+  GHashTable *apps;
+  GHashTableIter iter;
+  gpointer value;
+  int i;
+  GList *infos;
+
+  dirs = get_applications_search_path ();
+
+  apps = g_hash_table_new_full (g_str_hash, g_str_equal,
+				g_free, NULL);
+
+  
+  for (i = 0; dirs[i] != NULL; i++)
+    get_apps_from_dir (apps, dirs[i], "");
+
+
+  infos = NULL;
+  g_hash_table_iter_init (&iter, apps);
+  while (g_hash_table_iter_next (&iter, NULL, &value))
+    {
+      if (value)
+        infos = g_list_prepend (infos, value);
+    }
+
+  g_hash_table_destroy (apps);
+
+  return g_list_reverse (infos);
+}
+
+/* Cacheing of mimeinfo.cache and defaults.list files */
+
+typedef struct {
+  char *path;
+  GHashTable *mime_info_cache_map;
+  GHashTable *defaults_list_map;
+  GHashTable *mimeapps_list_added_map;
+  GHashTable *mimeapps_list_removed_map;
+  GHashTable *mimeapps_list_defaults_map;
+  time_t mime_info_cache_timestamp;
+  time_t defaults_list_timestamp;
+  time_t mimeapps_list_timestamp;
+} MimeInfoCacheDir;
+
+typedef struct {
+  GList *dirs;                       /* mimeinfo.cache and defaults.list */
+  GHashTable *global_defaults_cache; /* global results of defaults.list lookup and validation */
+  time_t last_stat_time;
+  guint should_ping_mime_monitor : 1;
+} MimeInfoCache;
+
+static MimeInfoCache *mime_info_cache = NULL;
+G_LOCK_DEFINE_STATIC (mime_info_cache);
+
+static void mime_info_cache_dir_add_desktop_entries (MimeInfoCacheDir  *dir,
+						     const char        *mime_type,
+						     char             **new_desktop_file_ids);
+
+static MimeInfoCache * mime_info_cache_new (void);
+
+static void
+destroy_info_cache_value (gpointer  key, 
+                          GList    *value, 
+                          gpointer  data)
+{
+  g_list_foreach (value, (GFunc)g_free, NULL);
+  g_list_free (value);
+}
+
+static void
+destroy_info_cache_map (GHashTable *info_cache_map)
+{
+  g_hash_table_foreach (info_cache_map, (GHFunc)destroy_info_cache_value, NULL);
+  g_hash_table_destroy (info_cache_map);
+}
+
+static gboolean
+mime_info_cache_dir_out_of_date (MimeInfoCacheDir *dir,
+				 const char       *cache_file,
+				 time_t           *timestamp)
+{
+  struct stat buf;
+  char *filename;
+  
+  filename = g_build_filename (dir->path, cache_file, NULL);
+  
+  if (g_stat (filename, &buf) < 0)
+    {
+      g_free (filename);
+      return TRUE;
+    }
+  g_free (filename);
+
+  if (buf.st_mtime != *timestamp) 
+    return TRUE;
+  
+  return FALSE;
+}
+
+/* Call with lock held */
+static gboolean
+remove_all (gpointer  key,
+	    gpointer  value,
+	    gpointer  user_data)
+{
+  return TRUE;
+}
+
+
+static void
+mime_info_cache_blow_global_cache (void)
+{
+  g_hash_table_foreach_remove (mime_info_cache->global_defaults_cache,
+			       remove_all, NULL);
+}
+
+static void
+mime_info_cache_dir_init (MimeInfoCacheDir *dir)
+{
+  GError *load_error;
+  GKeyFile *key_file;
+  gchar *filename, **mime_types;
+  int i;
+  struct stat buf;
+  
+  load_error = NULL;
+  mime_types = NULL;
+  
+  if (dir->mime_info_cache_map != NULL &&
+      !mime_info_cache_dir_out_of_date (dir, "mimeinfo.cache",
+					&dir->mime_info_cache_timestamp))
+    return;
+  
+  if (dir->mime_info_cache_map != NULL)
+    destroy_info_cache_map (dir->mime_info_cache_map);
+  
+  dir->mime_info_cache_map = g_hash_table_new_full (g_str_hash, g_str_equal,
+						    (GDestroyNotify) g_free,
+						    NULL);
+  
+  key_file = g_key_file_new ();
+  
+  filename = g_build_filename (dir->path, "mimeinfo.cache", NULL);
+  
+  if (g_stat (filename, &buf) < 0)
+    goto error;
+  
+  if (dir->mime_info_cache_timestamp > 0) 
+    mime_info_cache->should_ping_mime_monitor = TRUE;
+  
+  dir->mime_info_cache_timestamp = buf.st_mtime;
+  
+  g_key_file_load_from_file (key_file, filename, G_KEY_FILE_NONE, &load_error);
+  
+  g_free (filename);
+  filename = NULL;
+  
+  if (load_error != NULL)
+    goto error;
+  
+  mime_types = g_key_file_get_keys (key_file, MIME_CACHE_GROUP,
+				    NULL, &load_error);
+  
+  if (load_error != NULL)
+    goto error;
+  
+  for (i = 0; mime_types[i] != NULL; i++)
+    {
+      gchar **desktop_file_ids;
+      char *unaliased_type;
+      desktop_file_ids = g_key_file_get_string_list (key_file,
+						     MIME_CACHE_GROUP,
+						     mime_types[i],
+						     NULL,
+						     NULL);
+      
+      if (desktop_file_ids == NULL)
+	continue;
+
+      unaliased_type = _g_unix_content_type_unalias (mime_types[i]);
+      mime_info_cache_dir_add_desktop_entries (dir,
+					       unaliased_type,
+					       desktop_file_ids);
+      g_free (unaliased_type);
+    
+      g_strfreev (desktop_file_ids);
+    }
+  
+  g_strfreev (mime_types);
+  g_key_file_free (key_file);
+  
+  return;
+ error:
+  g_free (filename);
+  g_key_file_free (key_file);
+  
+  if (mime_types != NULL)
+    g_strfreev (mime_types);
+  
+  if (load_error)
+    g_error_free (load_error);
+}
+
+static void
+mime_info_cache_dir_init_defaults_list (MimeInfoCacheDir *dir)
+{
+  GKeyFile *key_file;
+  GError *load_error;
+  gchar *filename, **mime_types;
+  char *unaliased_type;
+  char **desktop_file_ids;
+  int i;
+  struct stat buf;
+
+  load_error = NULL;
+  mime_types = NULL;
+
+  if (dir->defaults_list_map != NULL &&
+      !mime_info_cache_dir_out_of_date (dir, "defaults.list",
+					&dir->defaults_list_timestamp))
+    return;
+  
+  if (dir->defaults_list_map != NULL)
+    g_hash_table_destroy (dir->defaults_list_map);
+  dir->defaults_list_map = g_hash_table_new_full (g_str_hash, g_str_equal,
+						  g_free, (GDestroyNotify)g_strfreev);
+  
+
+  key_file = g_key_file_new ();
+  
+  filename = g_build_filename (dir->path, "defaults.list", NULL);
+  if (g_stat (filename, &buf) < 0)
+    goto error;
+
+  if (dir->defaults_list_timestamp > 0) 
+    mime_info_cache->should_ping_mime_monitor = TRUE;
+
+  dir->defaults_list_timestamp = buf.st_mtime;
+
+  g_key_file_load_from_file (key_file, filename, G_KEY_FILE_NONE, &load_error);
+  g_free (filename);
+  filename = NULL;
+
+  if (load_error != NULL)
+    goto error;
+
+  mime_types = g_key_file_get_keys (key_file, DEFAULT_APPLICATIONS_GROUP,
+				    NULL, NULL);
+  if (mime_types != NULL)
+    {
+      for (i = 0; mime_types[i] != NULL; i++)
+	{
+	  desktop_file_ids = g_key_file_get_string_list (key_file,
+							 DEFAULT_APPLICATIONS_GROUP,
+							 mime_types[i],
+							 NULL,
+							 NULL);
+	  if (desktop_file_ids == NULL)
+	    continue;
+	  
+	  unaliased_type = _g_unix_content_type_unalias (mime_types[i]);
+	  g_hash_table_replace (dir->defaults_list_map,
+				unaliased_type,
+				desktop_file_ids);
+	}
+      
+      g_strfreev (mime_types);
+    }
+
+  g_key_file_free (key_file);
+  return;
+  
+ error:
+  g_free (filename);
+  g_key_file_free (key_file);
+  
+  if (mime_types != NULL)
+    g_strfreev (mime_types);
+  
+  if (load_error)
+    g_error_free (load_error);
+}
+
+static void
+mime_info_cache_dir_init_mimeapps_list (MimeInfoCacheDir *dir)
+{
+  GKeyFile *key_file;
+  GError *load_error;
+  gchar *filename, **mime_types;
+  char *unaliased_type;
+  char **desktop_file_ids;
+  char *desktop_id;
+  int i;
+  struct stat buf;
+
+  load_error = NULL;
+  mime_types = NULL;
+
+  if (dir->mimeapps_list_added_map != NULL &&
+      !mime_info_cache_dir_out_of_date (dir, "mimeapps.list",
+					&dir->mimeapps_list_timestamp))
+    return;
+  
+  if (dir->mimeapps_list_added_map != NULL)
+    g_hash_table_destroy (dir->mimeapps_list_added_map);
+  dir->mimeapps_list_added_map = g_hash_table_new_full (g_str_hash, g_str_equal,
+							g_free, (GDestroyNotify)g_strfreev);
+  
+  if (dir->mimeapps_list_removed_map != NULL)
+    g_hash_table_destroy (dir->mimeapps_list_removed_map);
+  dir->mimeapps_list_removed_map = g_hash_table_new_full (g_str_hash, g_str_equal,
+							  g_free, (GDestroyNotify)g_strfreev);
+
+  if (dir->mimeapps_list_defaults_map != NULL)
+    g_hash_table_destroy (dir->mimeapps_list_defaults_map);
+  dir->mimeapps_list_defaults_map = g_hash_table_new_full (g_str_hash, g_str_equal,
+                                                           g_free, g_free);
+
+  key_file = g_key_file_new ();
+  
+  filename = g_build_filename (dir->path, "mimeapps.list", NULL);
+  if (g_stat (filename, &buf) < 0)
+    goto error;
+
+  if (dir->mimeapps_list_timestamp > 0) 
+    mime_info_cache->should_ping_mime_monitor = TRUE;
+
+  dir->mimeapps_list_timestamp = buf.st_mtime;
+
+  g_key_file_load_from_file (key_file, filename, G_KEY_FILE_NONE, &load_error);
+  g_free (filename);
+  filename = NULL;
+
+  if (load_error != NULL)
+    goto error;
+
+  mime_types = g_key_file_get_keys (key_file, ADDED_ASSOCIATIONS_GROUP,
+				    NULL, NULL);
+  if (mime_types != NULL)
+    {
+      for (i = 0; mime_types[i] != NULL; i++)
+	{
+	  desktop_file_ids = g_key_file_get_string_list (key_file,
+							 ADDED_ASSOCIATIONS_GROUP,
+							 mime_types[i],
+							 NULL,
+							 NULL);
+	  if (desktop_file_ids == NULL)
+	    continue;
+	  
+	  unaliased_type = _g_unix_content_type_unalias (mime_types[i]);
+	  g_hash_table_replace (dir->mimeapps_list_added_map,
+				unaliased_type,
+				desktop_file_ids);
+	}
+      
+      g_strfreev (mime_types);
+    }
+
+  mime_types = g_key_file_get_keys (key_file, REMOVED_ASSOCIATIONS_GROUP,
+				    NULL, NULL);
+  if (mime_types != NULL)
+    {
+      for (i = 0; mime_types[i] != NULL; i++)
+	{
+	  desktop_file_ids = g_key_file_get_string_list (key_file,
+							 REMOVED_ASSOCIATIONS_GROUP,
+							 mime_types[i],
+							 NULL,
+							 NULL);
+	  if (desktop_file_ids == NULL)
+	    continue;
+	  
+	  unaliased_type = _g_unix_content_type_unalias (mime_types[i]);
+	  g_hash_table_replace (dir->mimeapps_list_removed_map,
+				unaliased_type,
+				desktop_file_ids);
+	}
+      
+      g_strfreev (mime_types);
+    }
+
+  mime_types = g_key_file_get_keys (key_file, DEFAULT_APPLICATIONS_GROUP,
+                                    NULL, NULL);
+  if (mime_types != NULL)
+    {
+      for (i = 0; mime_types[i] != NULL; i++)
+        {
+          desktop_id = g_key_file_get_string (key_file,
+                                              DEFAULT_APPLICATIONS_GROUP,
+                                              mime_types[i],
+                                              NULL);
+          if (desktop_id == NULL)
+            continue;
+
+          unaliased_type = _g_unix_content_type_unalias (mime_types[i]);
+          g_hash_table_replace (dir->mimeapps_list_defaults_map,
+                                unaliased_type,
+                                desktop_id);
+        }
+
+      g_strfreev (mime_types);
+    }
+
+  g_key_file_free (key_file);
+  return;
+  
+ error:
+  g_free (filename);
+  g_key_file_free (key_file);
+  
+  if (mime_types != NULL)
+    g_strfreev (mime_types);
+  
+  if (load_error)
+    g_error_free (load_error);
+}
+
+static MimeInfoCacheDir *
+mime_info_cache_dir_new (const char *path)
+{
+  MimeInfoCacheDir *dir;
+
+  dir = g_new0 (MimeInfoCacheDir, 1);
+  dir->path = g_strdup (path);
+  
+  return dir;
+}
+
+static void
+mime_info_cache_dir_free (MimeInfoCacheDir *dir)
+{
+  if (dir == NULL)
+    return;
+  
+  if (dir->mime_info_cache_map != NULL)
+    {
+      destroy_info_cache_map (dir->mime_info_cache_map);
+      dir->mime_info_cache_map = NULL;
+      
+  }
+  
+  if (dir->defaults_list_map != NULL)
+    {
+      g_hash_table_destroy (dir->defaults_list_map);
+      dir->defaults_list_map = NULL;
+    }
+  
+  if (dir->mimeapps_list_added_map != NULL)
+    {
+      g_hash_table_destroy (dir->mimeapps_list_added_map);
+      dir->mimeapps_list_added_map = NULL;
+    }
+  
+  if (dir->mimeapps_list_removed_map != NULL)
+    {
+      g_hash_table_destroy (dir->mimeapps_list_removed_map);
+      dir->mimeapps_list_removed_map = NULL;
+    }
+
+  if (dir->mimeapps_list_defaults_map != NULL)
+    {
+      g_hash_table_destroy (dir->mimeapps_list_defaults_map);
+      dir->mimeapps_list_defaults_map = NULL;
+    }
+
+  g_free (dir);
+}
+
+static void
+mime_info_cache_dir_add_desktop_entries (MimeInfoCacheDir  *dir,
+					 const char        *mime_type,
+					 char             **new_desktop_file_ids)
+{
+  GList *desktop_file_ids;
+  int i;
+  
+  desktop_file_ids = g_hash_table_lookup (dir->mime_info_cache_map,
+					  mime_type);
+  
+  for (i = 0; new_desktop_file_ids[i] != NULL; i++)
+    {
+      if (!g_list_find_custom (desktop_file_ids, new_desktop_file_ids[i], (GCompareFunc) strcmp))
+	desktop_file_ids = g_list_append (desktop_file_ids,
+					  g_strdup (new_desktop_file_ids[i]));
+    }
+  
+  g_hash_table_insert (dir->mime_info_cache_map, g_strdup (mime_type), desktop_file_ids);
+}
+
+static void
+mime_info_cache_init_dir_lists (void)
+{
+  const char * const *dirs;
+  int i;
+  
+  mime_info_cache = mime_info_cache_new ();
+  
+  dirs = get_applications_search_path ();
+  
+  for (i = 0; dirs[i] != NULL; i++)
+    {
+      MimeInfoCacheDir *dir;
+      
+      dir = mime_info_cache_dir_new (dirs[i]);
+      
+      if (dir != NULL)
+	{
+	  mime_info_cache_dir_init (dir);
+	  mime_info_cache_dir_init_defaults_list (dir);
+	  mime_info_cache_dir_init_mimeapps_list (dir);
+	  
+	  mime_info_cache->dirs = g_list_append (mime_info_cache->dirs, dir);
+	}
+    }
+}
+
+static void
+mime_info_cache_update_dir_lists (void)
+{
+  GList *tmp;
+  
+  tmp = mime_info_cache->dirs;
+  
+  while (tmp != NULL)
+    {
+      MimeInfoCacheDir *dir = (MimeInfoCacheDir *) tmp->data;
+
+      /* No need to do this if we had file monitors... */
+      mime_info_cache_blow_global_cache ();
+      mime_info_cache_dir_init (dir);
+      mime_info_cache_dir_init_defaults_list (dir);
+      mime_info_cache_dir_init_mimeapps_list (dir);
+      
+      tmp = tmp->next;
+    }
+}
+
+static void
+mime_info_cache_init (void)
+{
+  G_LOCK (mime_info_cache);
+  if (mime_info_cache == NULL)
+    mime_info_cache_init_dir_lists ();
+  else
+    {
+      time_t now;
+      
+      time (&now);
+      if (now >= mime_info_cache->last_stat_time + 10)
+	{
+	  mime_info_cache_update_dir_lists ();
+	  mime_info_cache->last_stat_time = now;
+	}
+    }
+  
+  if (mime_info_cache->should_ping_mime_monitor)
+    {
+      /* g_idle_add (emit_mime_changed, NULL); */
+      mime_info_cache->should_ping_mime_monitor = FALSE;
+    }
+  
+  G_UNLOCK (mime_info_cache);
+}
+
+static MimeInfoCache *
+mime_info_cache_new (void)
+{
+  MimeInfoCache *cache;
+  
+  cache = g_new0 (MimeInfoCache, 1);
+  
+  cache->global_defaults_cache = g_hash_table_new_full (g_str_hash, g_str_equal,
+							(GDestroyNotify) g_free,
+							(GDestroyNotify) g_free);
+  return cache;
+}
+
+static void
+mime_info_cache_free (MimeInfoCache *cache)
+{
+  if (cache == NULL)
+    return;
+  
+  g_list_foreach (cache->dirs,
+		  (GFunc) mime_info_cache_dir_free,
+		  NULL);
+  g_list_free (cache->dirs);
+  g_hash_table_destroy (cache->global_defaults_cache);
+  g_free (cache);
+}
+
+/**
+ * mime_info_cache_reload:
+ * @dir: directory path which needs reloading.
+ * 
+ * Reload the mime information for the @dir.
+ */
+static void
+mime_info_cache_reload (const char *dir)
+{
+  /* FIXME: just reload the dir that needs reloading,
+   * don't blow the whole cache
+   */
+  if (mime_info_cache != NULL)
+    {
+      G_LOCK (mime_info_cache);
+      mime_info_cache_free (mime_info_cache);
+      mime_info_cache = NULL;
+      G_UNLOCK (mime_info_cache);
+    }
+}
+
+static GList *
+append_desktop_entry (GList      *list, 
+                      const char *desktop_entry,
+		      GList      *removed_entries)
+{
+  /* Add if not already in list, and valid */
+  if (!g_list_find_custom (list, desktop_entry, (GCompareFunc) strcmp) &&
+      !g_list_find_custom (removed_entries, desktop_entry, (GCompareFunc) strcmp))
+    list = g_list_prepend (list, g_strdup (desktop_entry));
+  
+  return list;
+}
+
+/**
+ * get_all_desktop_entries_for_mime_type:
+ * @mime_type: a mime type.
+ * @except: NULL or a strv list
+ *
+ * Returns all the desktop ids for @mime_type. The desktop files
+ * are listed in an order so that default applications are listed before
+ * non-default ones, and handlers for inherited mimetypes are listed
+ * after the base ones.
+ *
+ * Optionally doesn't list the desktop ids given in the @except 
+ *
+ * Return value: a #GList containing the desktop ids which claim
+ *    to handle @mime_type.
+ */
+static GList *
+get_all_desktop_entries_for_mime_type (const char  *base_mime_type,
+				       const char **except,
+				       gboolean     include_fallback,
+                                       char       **explicit_default)
+{
+  GList *desktop_entries, *removed_entries, *list, *dir_list, *tmp;
+  MimeInfoCacheDir *dir;
+  char *mime_type, *default_entry = NULL;
+  const char *entry;
+  char **mime_types;
+  char **default_entries;
+  char **removed_associations;
+  int i, j, k;
+  GPtrArray *array;
+  char **anc;
+  
+  mime_info_cache_init ();
+
+  if (include_fallback)
+    {
+      /* collect all ancestors */
+      mime_types = _g_unix_content_type_get_parents (base_mime_type);
+      array = g_ptr_array_new ();
+      for (i = 0; mime_types[i]; i++)
+	g_ptr_array_add (array, mime_types[i]);
+      g_free (mime_types);
+      for (i = 0; i < array->len; i++)
+	{
+	  anc = _g_unix_content_type_get_parents (g_ptr_array_index (array, i));
+	  for (j = 0; anc[j]; j++)
+	    {
+	      for (k = 0; k < array->len; k++)
+		{
+		  if (strcmp (anc[j], g_ptr_array_index (array, k)) == 0)
+		    break;
+		}
+	      if (k == array->len) /* not found */
+		g_ptr_array_add (array, g_strdup (anc[j]));
+	    }
+	  g_strfreev (anc);
+	}
+      g_ptr_array_add (array, NULL);
+      mime_types = (char **)g_ptr_array_free (array, FALSE);
+    }
+  else
+    {
+      mime_types = g_malloc0 (2 * sizeof (gchar *));
+      mime_types[0] = g_strdup (base_mime_type);
+      mime_types[1] = NULL;
+    }
+
+  G_LOCK (mime_info_cache);
+  
+  removed_entries = NULL;
+  desktop_entries = NULL;
+
+  for (i = 0; except != NULL && except[i] != NULL; i++)
+    removed_entries = g_list_prepend (removed_entries, g_strdup (except[i]));
+  
+  for (i = 0; mime_types[i] != NULL; i++)
+    {
+      mime_type = mime_types[i];
+
+      /* Go through all apps listed in user and system dirs */
+      for (dir_list = mime_info_cache->dirs;
+	   dir_list != NULL;
+	   dir_list = dir_list->next)
+	{
+	  dir = dir_list->data;
+
+          /* Pick the explicit default application if we got no result earlier
+           * (ie, for more specific mime types)
+           */
+          if (desktop_entries == NULL)
+            {
+              entry = g_hash_table_lookup (dir->mimeapps_list_defaults_map, mime_type);
+
+              if (entry != NULL)
+                {
+                  /* Save the default entry if it's the first one we encounter */
+                  if (default_entry == NULL)
+                    default_entry = g_strdup (entry);
+                }
+            }
+
+	  /* Then added associations from mimeapps.list */
+	  default_entries = g_hash_table_lookup (dir->mimeapps_list_added_map, mime_type);
+	  for (j = 0; default_entries != NULL && default_entries[j] != NULL; j++)
+            desktop_entries = append_desktop_entry (desktop_entries, default_entries[j], removed_entries);
+
+	  /* Then removed associations from mimeapps.list */
+	  removed_associations = g_hash_table_lookup (dir->mimeapps_list_removed_map, mime_type);
+	  for (j = 0; removed_associations != NULL && removed_associations[j] != NULL; j++)
+	    removed_entries = append_desktop_entry (removed_entries, removed_associations[j], NULL);
+
+	  /* Then system defaults (or old per-user config) (using removed associations from this dir or earlier) */
+	  default_entries = g_hash_table_lookup (dir->defaults_list_map, mime_type);
+	  for (j = 0; default_entries != NULL && default_entries[j] != NULL; j++)
+	    desktop_entries = append_desktop_entry (desktop_entries, default_entries[j], removed_entries);
+	}
+
+      /* Go through all entries that support the mimetype */
+      for (dir_list = mime_info_cache->dirs;
+	   dir_list != NULL;
+	   dir_list = dir_list->next) 
+        {
+	  dir = dir_list->data;
+	
+	  list = g_hash_table_lookup (dir->mime_info_cache_map, mime_type);
+	  for (tmp = list; tmp != NULL; tmp = tmp->next)
+	    desktop_entries = append_desktop_entry (desktop_entries, tmp->data, removed_entries);
+        }
+    }
+  
+  G_UNLOCK (mime_info_cache);
+
+  g_strfreev (mime_types);
+
+  if (explicit_default != NULL)
+    *explicit_default = default_entry;
+  else
+    g_free (default_entry);
+
+  g_list_foreach (removed_entries, (GFunc)g_free, NULL);
+  g_list_free (removed_entries);
+
+  desktop_entries = g_list_reverse (desktop_entries);
+  
+  return desktop_entries;
+}
+
+/* GDesktopAppInfoLookup interface: */
+
+typedef GDesktopAppInfoLookupIface GDesktopAppInfoLookupInterface;
+G_DEFINE_INTERFACE (GDesktopAppInfoLookup, g_desktop_app_info_lookup, G_TYPE_OBJECT)
+
+static void
+g_desktop_app_info_lookup_default_init (GDesktopAppInfoLookupInterface *iface)
+{
+}
+
+/**
+ * g_desktop_app_info_lookup_get_default_for_uri_scheme:
+ * @lookup: a #GDesktopAppInfoLookup
+ * @uri_scheme: a string containing a URI scheme.
+ *
+ * Gets the default application for launching applications 
+ * using this URI scheme for a particular GDesktopAppInfoLookup
+ * implementation.
+ *
+ * The GDesktopAppInfoLookup interface and this function is used
+ * to implement g_app_info_get_default_for_uri_scheme() backends
+ * in a GIO module. There is no reason for applications to use it
+ * directly. Applications should use g_app_info_get_default_for_uri_scheme().
+ * 
+ * Returns: (transfer full): #GAppInfo for given @uri_scheme or %NULL on error.
+ *
+ * Deprecated: The #GDesktopAppInfoLookup interface is deprecated and unused by gio.
+ */
+GAppInfo *
+g_desktop_app_info_lookup_get_default_for_uri_scheme (GDesktopAppInfoLookup *lookup,
+						      const char            *uri_scheme)
+{
+  GDesktopAppInfoLookupIface *iface;
+  
+  g_return_val_if_fail (G_IS_DESKTOP_APP_INFO_LOOKUP (lookup), NULL);
+
+  iface = G_DESKTOP_APP_INFO_LOOKUP_GET_IFACE (lookup);
+
+  return (* iface->get_default_for_uri_scheme) (lookup, uri_scheme);
+}
diff -uNr glib-2.28.8-orig/gio/gsimpleactiongroup.c glib-2.28.8-new/gio/gsimpleactiongroup.c
--- glib-2.28.8-orig/gio/gsimpleactiongroup.c	2010-12-22 04:33:05.000000000 -0800
+++ glib-2.28.8-new/gio/gsimpleactiongroup.c	2015-06-02 19:03:36.000000000 -0700
@@ -42,25 +42,35 @@
   G_IMPLEMENT_INTERFACE (G_TYPE_ACTION_GROUP,
     g_simple_action_group_iface_init))
 
+typedef struct key_data {
+  gint i;
+  gchar **keys;
+} key_data_t;
+
+static void
+copy_key(gpointer key, gpointer value, gpointer user_data)
+{
+  key_data_t *d = (key_data_t *)user_data;
+  d->keys[d->i++] = g_strdup(key);
+}
+
 static gchar **
 g_simple_action_group_list_actions (GActionGroup *group)
 {
   GSimpleActionGroup *simple = G_SIMPLE_ACTION_GROUP (group);
-  GHashTableIter iter;
-  gint n, i = 0;
-  gchar **keys;
-  gpointer key;
+  gint n;
+  key_data_t d;
 
+  d.i = 0;
   n = g_hash_table_size (simple->priv->table);
-  keys = g_new (gchar *, n + 1);
+  d.keys = g_new (gchar *, n + 1);
+
+  g_hash_table_foreach(simple->priv->table, copy_key, &d);
 
-  g_hash_table_iter_init (&iter, simple->priv->table);
-  while (g_hash_table_iter_next (&iter, &key, NULL))
-    keys[i++] = g_strdup (key);
-  g_assert_cmpint (i, ==, n);
-  keys[n] = NULL;
+  g_assert_cmpint (d.i, ==, n);
+  d.keys[n] = NULL;
 
-  return keys;
+  return d.keys;
 }
 
 static gboolean
diff -uNr glib-2.28.8-orig/glib/ghash.c glib-2.28.8-new/glib/ghash.c
--- glib-2.28.8-orig/glib/ghash.c	2015-06-02 18:08:19.000000000 -0700
+++ glib-2.28.8-new/glib/ghash.c	2015-06-02 18:20:34.000000000 -0700
@@ -30,8 +30,6 @@
 
 #include "config.h"
 
-#include <string.h>  /* memset */
-
 #include "ghash.h"
 
 #include "gatomic.h"
@@ -152,7 +150,10 @@
  * with g_hash_table_iter_init().
  **/
 
-#define HASH_TABLE_MIN_SHIFT 3  /* 1 << 3 == 8 buckets */
+
+#define HASH_TABLE_MIN_SIZE 11
+#define HASH_TABLE_MAX_SIZE 13845163
+
 
 typedef struct _GHashNode      GHashNode;
 
@@ -160,346 +161,45 @@
 {
   gpointer   key;
   gpointer   value;
-
-  /* If key_hash == 0, node is not in use
-   * If key_hash == 1, node is a tombstone
-   * If key_hash >= 2, node contains data */
-  guint      key_hash;
+  GHashNode *next;
 };
 
 struct _GHashTable
 {
   gint             size;
-  gint             mod;
-  guint            mask;
   gint             nnodes;
-  gint             noccupied;  /* nnodes + tombstones */
-  GHashNode       *nodes;
+  GHashNode      **nodes;
   GHashFunc        hash_func;
   GEqualFunc       key_equal_func;
   volatile gint    ref_count;
-#ifndef G_DISABLE_ASSERT
-  /*
-   * Tracks the structure of the hash table, not its contents: is only
-   * incremented when a node is added or removed (is not incremented
-   * when the key or data of a node is modified).
-   */
-  int              version;
-#endif
   GDestroyNotify   key_destroy_func;
   GDestroyNotify   value_destroy_func;
 };
 
-typedef struct
-{
-  GHashTable  *hash_table;
-  gpointer     dummy1;
-  gpointer     dummy2;
-  int          position;
-  gboolean     dummy3;
-  int          version;
-} RealIter;
-
-/* Each table size has an associated prime modulo (the first prime
- * lower than the table size) used to find the initial bucket. Probing
- * then works modulo 2^n. The prime modulo is necessary to get a
- * good distribution with poor hash functions. */
-static const gint prime_mod [] =
-{
-  1,          /* For 1 << 0 */
-  2,
-  3,
-  7,
-  13,
-  31,
-  61,
-  127,
-  251,
-  509,
-  1021,
-  2039,
-  4093,
-  8191,
-  16381,
-  32749,
-  65521,      /* For 1 << 16 */
-  131071,
-  262139,
-  524287,
-  1048573,
-  2097143,
-  4194301,
-  8388593,
-  16777213,
-  33554393,
-  67108859,
-  134217689,
-  268435399,
-  536870909,
-  1073741789,
-  2147483647  /* For 1 << 31 */
-};
-
-static void
-g_hash_table_set_shift (GHashTable *hash_table, gint shift)
-{
-  gint i;
-  guint mask = 0;
-
-  hash_table->size = 1 << shift;
-  hash_table->mod  = prime_mod [shift];
-
-  for (i = 0; i < shift; i++)
-    {
-      mask <<= 1;
-      mask |= 1;
-    }
-
-  hash_table->mask = mask;
-}
-
-static gint
-g_hash_table_find_closest_shift (gint n)
-{
-  gint i;
-
-  for (i = 0; n; i++)
-    n >>= 1;
-
-  return i;
-}
-
-static void
-g_hash_table_set_shift_from_size (GHashTable *hash_table, gint size)
-{
-  gint shift;
-
-  shift = g_hash_table_find_closest_shift (size);
-  shift = MAX (shift, HASH_TABLE_MIN_SHIFT);
-
-  g_hash_table_set_shift (hash_table, shift);
-}
-
-/*
- * g_hash_table_lookup_node:
- * @hash_table: our #GHashTable
- * @key: the key to lookup against (may be %NULL)
- * @hash_return: optional key hash return location
- * Return value: index of the described #GHashNode
- *
- * Performs a lookup in the hash table.
- *
- * Virtually all hash operations will use this function internally.
- *
- * This function first computes the hash value of the key using the
- * user's hash function.
- *
- * If an entry in the table matching @key is found then this function
- * returns the index of that entry in the table, and if not, the
- * index of an empty node (never a tombstone).
- */
-static inline guint
-g_hash_table_lookup_node (GHashTable    *hash_table,
-                          gconstpointer  key)
-{
-  GHashNode *node;
-  guint node_index;
-  guint hash_value;
-  guint step = 0;
-
-  /* Empty buckets have hash_value set to 0, and for tombstones, it's 1.
-   * We need to make sure our hash value is not one of these. */
-
-  hash_value = (* hash_table->hash_func) (key);
-  if (G_UNLIKELY (hash_value <= 1))
-    hash_value = 2;
-
-  node_index = hash_value % hash_table->mod;
-  node = &hash_table->nodes [node_index];
-
-  while (node->key_hash)
-    {
-      /*  We first check if our full hash values
-       *  are equal so we can avoid calling the full-blown
-       *  key equality function in most cases.
-       */
-
-      if (node->key_hash == hash_value)
-        {
-          if (hash_table->key_equal_func)
-            {
-              if (hash_table->key_equal_func (node->key, key))
-                break;
-            }
-          else if (node->key == key)
-            {
-              break;
-            }
-        }
-
-      step++;
-      node_index += step;
-      node_index &= hash_table->mask;
-      node = &hash_table->nodes [node_index];
-    }
-
-  return node_index;
-}
-
-/*
- * g_hash_table_lookup_node_for_insertion:
- * @hash_table: our #GHashTable
- * @key: the key to lookup against
- * @hash_return: key hash return location
- * Return value: index of the described #GHashNode
- *
- * Performs a lookup in the hash table, preserving extra information
- * usually needed for insertion.
- *
- * This function first computes the hash value of the key using the
- * user's hash function.
- *
- * If an entry in the table matching @key is found then this function
- * returns the index of that entry in the table, and if not, the
- * index of an unused node (empty or tombstone) where the key can be
- * inserted.
- *
- * The computed hash value is returned in the variable pointed to
- * by @hash_return. This is to save insertions from having to compute
- * the hash record again for the new record.
- */
-static inline guint
-g_hash_table_lookup_node_for_insertion (GHashTable    *hash_table,
-                                        gconstpointer  key,
-                                        guint         *hash_return)
-{
-  GHashNode *node;
-  guint node_index;
-  guint hash_value;
-  guint first_tombstone;
-  gboolean have_tombstone = FALSE;
-  guint step = 0;
-
-  /* Empty buckets have hash_value set to 0, and for tombstones, it's 1.
-   * We need to make sure our hash value is not one of these. */
-
-  hash_value = (* hash_table->hash_func) (key);
-  if (G_UNLIKELY (hash_value <= 1))
-    hash_value = 2;
-
-  *hash_return = hash_value;
-
-  node_index = hash_value % hash_table->mod;
-  node = &hash_table->nodes [node_index];
-
-  while (node->key_hash)
-    {
-      /*  We first check if our full hash values
-       *  are equal so we can avoid calling the full-blown
-       *  key equality function in most cases.
-       */
-
-      if (node->key_hash == hash_value)
-        {
-          if (hash_table->key_equal_func)
-            {
-              if (hash_table->key_equal_func (node->key, key))
-                return node_index;
-            }
-          else if (node->key == key)
-            {
-              return node_index;
-            }
-        }
-      else if (node->key_hash == 1 && !have_tombstone)
-        {
-          first_tombstone = node_index;
-          have_tombstone = TRUE;
-        }
-
-      step++;
-      node_index += step;
-      node_index &= hash_table->mask;
-      node = &hash_table->nodes [node_index];
-    }
-
-  if (have_tombstone)
-    return first_tombstone;
-
-  return node_index;
-}
-
-/*
- * g_hash_table_remove_node:
- * @hash_table: our #GHashTable
- * @node: pointer to node to remove
- * @notify: %TRUE if the destroy notify handlers are to be called
- *
- * Removes a node from the hash table and updates the node count.
- * The node is replaced by a tombstone. No table resize is performed.
- *
- * If @notify is %TRUE then the destroy notify functions are called
- * for the key and value of the hash node.
- */
-static void
-g_hash_table_remove_node (GHashTable   *hash_table,
-                          GHashNode    *node,
-                          gboolean      notify)
-{
-  if (notify && hash_table->key_destroy_func)
-    hash_table->key_destroy_func (node->key);
-
-  if (notify && hash_table->value_destroy_func)
-    hash_table->value_destroy_func (node->value);
-
-  /* Erect tombstone */
-  node->key_hash = 1;
-
-  /* Be GC friendly */
-  node->key = NULL;
-  node->value = NULL;
-
-  hash_table->nnodes--;
-}
-
-/*
- * g_hash_table_remove_all_nodes:
- * @hash_table: our #GHashTable
- * @notify: %TRUE if the destroy notify handlers are to be called
- *
- * Removes all nodes from the table.  Since this may be a precursor to
- * freeing the table entirely, no resize is performed.
- *
- * If @notify is %TRUE then the destroy notify functions are called
- * for the key and value of the hash node.
- */
-static void
-g_hash_table_remove_all_nodes (GHashTable *hash_table,
-                               gboolean    notify)
-{
-  int i;
-
-  for (i = 0; i < hash_table->size; i++)
-    {
-      GHashNode *node = &hash_table->nodes [i];
-
-      if (node->key_hash > 1)
-        {
-          if (notify && hash_table->key_destroy_func)
-            hash_table->key_destroy_func (node->key);
-
-          if (notify && hash_table->value_destroy_func)
-            hash_table->value_destroy_func (node->value);
-        }
-    }
-
-  /* We need to set node->key_hash = 0 for all nodes - might as well be GC
-   * friendly and clear everything */
-  memset (hash_table->nodes, 0, hash_table->size * sizeof (GHashNode));
-
-  hash_table->nnodes = 0;
-  hash_table->noccupied = 0;
-}
+#define G_HASH_TABLE_RESIZE(hash_table)                         \
+   G_STMT_START {                                               \
+     if ((hash_table->size >= 3 * hash_table->nnodes &&         \
+          hash_table->size > HASH_TABLE_MIN_SIZE) ||            \
+         (3 * hash_table->size <= hash_table->nnodes &&         \
+          hash_table->size < HASH_TABLE_MAX_SIZE))              \
+           g_hash_table_resize (hash_table);                    \
+   } G_STMT_END
+
+static void             g_hash_table_resize       (GHashTable     *hash_table);
+static GHashNode**      g_hash_table_lookup_p_node(GHashTable     *hash_table,
+                                                   gconstpointer   key);
+static GHashNode*       g_hash_node_new           (gpointer        key,
+                                                   gpointer        value);
+static void             g_hash_node_destroy       (GHashNode      *hash_node,
+                                                   GDestroyNotify  key_destroy_func,
+                                                   GDestroyNotify  value_destroy_func);
+static void             g_hash_nodes_destroy     (GHashNode       *hash_node,
+                                                  GDestroyNotify   key_destroy_func,
+                                                  GDestroyNotify   value_destroy_func);
+static guint g_hash_table_foreach_remove_or_steal (GHashTable     *hash_table,
+                                                   GHRFunc         func,
+                                                   gpointer        user_data,
+                                                   gboolean        notify);
 
 /*
  * g_hash_table_resize:
@@ -507,8 +207,7 @@
  *
  * Resizes the hash table to the optimal size based on the number of
  * nodes currently held.  If you call this function then a resize will
- * occur, even if one does not need to occur.  Use
- * g_hash_table_maybe_resize() instead.
+ * occur, even if one does not need to occur.
  *
  * This function may "resize" the hash table to its current size, with
  * the side effect of cleaning up tombstones and otherwise optimizing
@@ -517,75 +216,46 @@
 static void
 g_hash_table_resize (GHashTable *hash_table)
 {
-  GHashNode *new_nodes;
-  gint old_size;
+  GHashNode **new_nodes;
+  GHashNode *node;
+  GHashNode *next;
+  guint hash_val;
+  gint new_size;
   gint i;
 
-  old_size = hash_table->size;
-  g_hash_table_set_shift_from_size (hash_table, hash_table->nnodes * 2);
-
-  new_nodes = g_new0 (GHashNode, hash_table->size);
+  new_size = g_spaced_primes_closest (hash_table->nnodes);
+  new_size = CLAMP (new_size, HASH_TABLE_MIN_SIZE, HASH_TABLE_MAX_SIZE);
 
-  for (i = 0; i < old_size; i++)
-    {
-      GHashNode *node = &hash_table->nodes [i];
-      GHashNode *new_node;
-      guint hash_val;
-      guint step = 0;
+  new_nodes = g_new0 (GHashNode*, new_size);
 
-      if (node->key_hash <= 1)
-        continue;
-
-      hash_val = node->key_hash % hash_table->mod;
-      new_node = &new_nodes [hash_val];
-
-      while (new_node->key_hash)
-        {
-          step++;
-          hash_val += step;
-          hash_val &= hash_table->mask;
-          new_node = &new_nodes [hash_val];
-        }
-
-      *new_node = *node;
-    }
+  for (i = 0; i < hash_table->size; i++)
+    for (node = hash_table->nodes[i]; node; node = next)
+      {
+        next = node->next;
+
+        hash_val = (* hash_table->hash_func) (node->key) % new_size;
+
+        node->next = new_nodes[hash_val];
+        new_nodes[hash_val] = node;
+      }
 
   g_free (hash_table->nodes);
   hash_table->nodes = new_nodes;
-  hash_table->noccupied = hash_table->nnodes;
+  hash_table->size = new_size;
 }
 
-/*
- * g_hash_table_maybe_resize:
- * @hash_table: our #GHashTable
- *
- * Resizes the hash table, if needed.
- *
- * Essentially, calls g_hash_table_resize() if the table has strayed
- * too far from its ideal size for its number of nodes.
- */
-static inline void
-g_hash_table_maybe_resize (GHashTable *hash_table)
-{
-  gint noccupied = hash_table->noccupied;
-  gint size = hash_table->size;
-
-  if ((size > hash_table->nnodes * 4 && size > 1 << HASH_TABLE_MIN_SHIFT) ||
-      (size <= noccupied + (noccupied / 16)))
-    g_hash_table_resize (hash_table);
-}
 
 /**
  * g_hash_table_new:
  * @hash_func: a function to create a hash value from a key.
  *   Hash values are used to determine where keys are stored within the
  *   #GHashTable data structure. The g_direct_hash(), g_int_hash(),
- *   g_int64_hash(), g_double_hash() and g_str_hash() functions are provided
+ *   g_str_hash() functions are provided
  *   for some common types of keys.
  *   If hash_func is %NULL, g_direct_hash() is used.
  * @key_equal_func: a function to check two keys for equality.  This is
  *   used when looking up keys in the #GHashTable.  The g_direct_equal(),
- *   g_int_equal(), g_int64_equal(), g_double_equal() and g_str_equal()
+ *   g_int_equal() and g_str_equal()
  *   functions are provided for the most common types of keys.
  *   If @key_equal_func is %NULL, keys are compared directly in a similar
  *   fashion to g_direct_equal(), but without the overhead of a function call.
@@ -628,188 +298,18 @@
   GHashTable *hash_table;
 
   hash_table = g_slice_new (GHashTable);
-  g_hash_table_set_shift (hash_table, HASH_TABLE_MIN_SHIFT);
+  hash_table->size               = HASH_TABLE_MIN_SIZE;
   hash_table->nnodes             = 0;
-  hash_table->noccupied          = 0;
   hash_table->hash_func          = hash_func ? hash_func : g_direct_hash;
   hash_table->key_equal_func     = key_equal_func;
   hash_table->ref_count          = 1;
-#ifndef G_DISABLE_ASSERT
-  hash_table->version            = 0;
-#endif
   hash_table->key_destroy_func   = key_destroy_func;
   hash_table->value_destroy_func = value_destroy_func;
-  hash_table->nodes              = g_new0 (GHashNode, hash_table->size);
+  hash_table->nodes              = g_new0 (GHashNode*, hash_table->size);
 
   return hash_table;
 }
 
-/**
- * g_hash_table_iter_init:
- * @iter: an uninitialized #GHashTableIter.
- * @hash_table: a #GHashTable.
- *
- * Initializes a key/value pair iterator and associates it with
- * @hash_table. Modifying the hash table after calling this function
- * invalidates the returned iterator.
- * |[
- * GHashTableIter iter;
- * gpointer key, value;
- *
- * g_hash_table_iter_init (&iter, hash_table);
- * while (g_hash_table_iter_next (&iter, &key, &value)) 
- *   {
- *     /&ast; do something with key and value &ast;/
- *   }
- * ]|
- *
- * Since: 2.16
- **/
-void
-g_hash_table_iter_init (GHashTableIter *iter,
-			GHashTable     *hash_table)
-{
-  RealIter *ri = (RealIter *) iter;
-
-  g_return_if_fail (iter != NULL);
-  g_return_if_fail (hash_table != NULL);
-
-  ri->hash_table = hash_table;
-  ri->position = -1;
-#ifndef G_DISABLE_ASSERT
-  ri->version = hash_table->version;
-#endif
-}
-
-/**
- * g_hash_table_iter_next:
- * @iter: an initialized #GHashTableIter.
- * @key: a location to store the key, or %NULL.
- * @value: a location to store the value, or %NULL.
- *
- * Advances @iter and retrieves the key and/or value that are now
- * pointed to as a result of this advancement. If %FALSE is returned,
- * @key and @value are not set, and the iterator becomes invalid.
- *
- * Return value: %FALSE if the end of the #GHashTable has been reached.
- *
- * Since: 2.16
- **/
-gboolean
-g_hash_table_iter_next (GHashTableIter *iter,
-			gpointer       *key,
-			gpointer       *value)
-{
-  RealIter *ri = (RealIter *) iter;
-  GHashNode *node;
-  gint position;
-
-  g_return_val_if_fail (iter != NULL, FALSE);
-#ifndef G_DISABLE_ASSERT
-  g_return_val_if_fail (ri->version == ri->hash_table->version, FALSE);
-#endif
-  g_return_val_if_fail (ri->position < ri->hash_table->size, FALSE);
-
-  position = ri->position;
-
-  do
-    {
-      position++;
-      if (position >= ri->hash_table->size)
-        {
-          ri->position = position;
-          return FALSE;
-        }
-
-      node = &ri->hash_table->nodes [position];
-    }
-  while (node->key_hash <= 1);
-
-  if (key != NULL)
-    *key = node->key;
-  if (value != NULL)
-    *value = node->value;
-
-  ri->position = position;
-  return TRUE;
-}
-
-/**
- * g_hash_table_iter_get_hash_table:
- * @iter: an initialized #GHashTableIter.
- *
- * Returns the #GHashTable associated with @iter.
- *
- * Return value: the #GHashTable associated with @iter.
- *
- * Since: 2.16
- **/
-GHashTable *
-g_hash_table_iter_get_hash_table (GHashTableIter *iter)
-{
-  g_return_val_if_fail (iter != NULL, NULL);
-
-  return ((RealIter *) iter)->hash_table;
-}
-
-static void
-iter_remove_or_steal (RealIter *ri, gboolean notify)
-{
-  g_return_if_fail (ri != NULL);
-#ifndef G_DISABLE_ASSERT
-  g_return_if_fail (ri->version == ri->hash_table->version);
-#endif
-  g_return_if_fail (ri->position >= 0);
-  g_return_if_fail (ri->position < ri->hash_table->size);
-
-  g_hash_table_remove_node (ri->hash_table, &ri->hash_table->nodes [ri->position], notify);
-
-#ifndef G_DISABLE_ASSERT
-  ri->version++;
-  ri->hash_table->version++;
-#endif
-}
-
-/**
- * g_hash_table_iter_remove:
- * @iter: an initialized #GHashTableIter.
- *
- * Removes the key/value pair currently pointed to by the iterator
- * from its associated #GHashTable. Can only be called after
- * g_hash_table_iter_next() returned %TRUE, and cannot be called more
- * than once for the same key/value pair.
- *
- * If the #GHashTable was created using g_hash_table_new_full(), the
- * key and value are freed using the supplied destroy functions, otherwise
- * you have to make sure that any dynamically allocated values are freed 
- * yourself.
- *
- * Since: 2.16
- **/
-void
-g_hash_table_iter_remove (GHashTableIter *iter)
-{
-  iter_remove_or_steal ((RealIter *) iter, TRUE);
-}
-
-/**
- * g_hash_table_iter_steal:
- * @iter: an initialized #GHashTableIter.
- *
- * Removes the key/value pair currently pointed to by the iterator
- * from its associated #GHashTable, without calling the key and value
- * destroy functions. Can only be called after
- * g_hash_table_iter_next() returned %TRUE, and cannot be called more
- * than once for the same key/value pair.
- *
- * Since: 2.16
- **/
-void
-g_hash_table_iter_steal (GHashTableIter *iter)
-{
-  iter_remove_or_steal ((RealIter *) iter, FALSE);
-}
-
 
 /**
  * g_hash_table_ref:
@@ -849,7 +349,12 @@
 
   if (g_atomic_int_exchange_and_add (&hash_table->ref_count, -1) - 1 == 0)
     {
-      g_hash_table_remove_all_nodes (hash_table, TRUE);
+      gint i;
+
+      for (i = 0; i < hash_table->size; i++)
+        g_hash_nodes_destroy (hash_table->nodes[i],
+                              hash_table->key_destroy_func,
+                              hash_table->value_destroy_func);
       g_free (hash_table->nodes);
       g_slice_free (GHashTable, hash_table);
     }
@@ -875,6 +380,30 @@
   g_hash_table_unref (hash_table);
 }
 
+static inline GHashNode**
+g_hash_table_lookup_p_node (GHashTable  *hash_table,
+                          gconstpointer  key)
+{
+  GHashNode **node;
+
+  node = &hash_table->nodes
+    [(* hash_table->hash_func) (key) % hash_table->size];
+
+  /* Hash table lookup needs to be fast.
+   *  We therefore remove the extra conditional of testing
+   *  whether to call the key_equal_func or not from
+   *  the inner loop.
+   */
+  if (hash_table->key_equal_func)
+    while (*node && !(*hash_table->key_equal_func) ((*node)->key, key))
+      node = &(*node)->next;
+  else
+    while (*node && (*node)->key != key)
+      node = &(*node)->next;
+
+  return node;
+}
+
 /**
  * g_hash_table_lookup:
  * @hash_table: a #GHashTable.
@@ -892,32 +421,26 @@
                      gconstpointer key)
 {
   GHashNode *node;
-  guint      node_index;
 
   g_return_val_if_fail (hash_table != NULL, NULL);
 
-  node_index = g_hash_table_lookup_node (hash_table, key);
-  node = &hash_table->nodes [node_index];
+  node = *g_hash_table_lookup_p_node (hash_table, key);
 
-  return node->key_hash ? node->value : NULL;
+  return node ? node->value : NULL;
 }
 
 /**
  * g_hash_table_lookup_extended:
  * @hash_table: a #GHashTable
  * @lookup_key: the key to look up
- * @orig_key: return location for the original key, or %NULL
- * @value: return location for the value associated with the key, or %NULL
+ * @orig_key: returns the original key
+ * @value: returns the value associated with the key
  *
  * Looks up a key in the #GHashTable, returning the original key and the
  * associated value and a #gboolean which is %TRUE if the key was found. This
  * is useful if you need to free the memory allocated for the original key,
  * for example before calling g_hash_table_remove().
  *
- * You can actually pass %NULL for @lookup_key to test
- * whether the %NULL key exists, provided the hash and equal functions
- * of @hash_table are %NULL-safe.
- *
  * Return value: %TRUE if the key was found in the #GHashTable.
  **/
 gboolean
@@ -927,99 +450,22 @@
                               gpointer      *value)
 {
   GHashNode *node;
-  guint      node_index;
 
   g_return_val_if_fail (hash_table != NULL, FALSE);
 
-  node_index = g_hash_table_lookup_node (hash_table, lookup_key);
-  node = &hash_table->nodes [node_index];
+  node = *g_hash_table_lookup_p_node (hash_table, lookup_key);
 
-  if (!node->key_hash)
+  if (node)
+  {
+      if (orig_key)
+        *orig_key = node->key;
+      if (value)
+        *value = node->value;
+  } else
     return FALSE;
-
-  if (orig_key)
-    *orig_key = node->key;
-
-  if (value)
-    *value = node->value;
-
   return TRUE;
 }
 
-/*
- * g_hash_table_insert_internal:
- * @hash_table: our #GHashTable
- * @key: the key to insert
- * @value: the value to insert
- * @keep_new_key: if %TRUE and this key already exists in the table
- *   then call the destroy notify function on the old key.  If %FALSE
- *   then call the destroy notify function on the new key.
- *
- * Implements the common logic for the g_hash_table_insert() and
- * g_hash_table_replace() functions.
- *
- * Do a lookup of @key.  If it is found, replace it with the new
- * @value (and perhaps the new @key).  If it is not found, create a
- * new node.
- */
-static void
-g_hash_table_insert_internal (GHashTable *hash_table,
-                              gpointer    key,
-                              gpointer    value,
-                              gboolean    keep_new_key)
-{
-  GHashNode *node;
-  guint node_index;
-  guint key_hash;
-  guint old_hash;
-
-  g_return_if_fail (hash_table != NULL);
-
-  node_index = g_hash_table_lookup_node_for_insertion (hash_table, key, &key_hash);
-  node = &hash_table->nodes [node_index];
-
-  old_hash = node->key_hash;
-
-  if (old_hash > 1)
-    {
-      if (keep_new_key)
-        {
-          if (hash_table->key_destroy_func)
-            hash_table->key_destroy_func (node->key);
-          node->key = key;
-        }
-      else
-        {
-          if (hash_table->key_destroy_func)
-            hash_table->key_destroy_func (key);
-        }
-
-      if (hash_table->value_destroy_func)
-        hash_table->value_destroy_func (node->value);
-
-      node->value = value;
-    }
-  else
-    {
-      node->key = key;
-      node->value = value;
-      node->key_hash = key_hash;
-
-      hash_table->nnodes++;
-
-      if (old_hash == 0)
-        {
-          /* We replaced an empty node, and not a tombstone */
-          hash_table->noccupied++;
-          g_hash_table_maybe_resize (hash_table);
-        }
-
-#ifndef G_DISABLE_ASSERT
-      hash_table->version++;
-#endif
-    }
-}
-
 /**
  * g_hash_table_insert:
  * @hash_table: a #GHashTable.
@@ -1039,7 +485,35 @@
                      gpointer    key,
                      gpointer    value)
 {
-  g_hash_table_insert_internal (hash_table, key, value, FALSE);
+  GHashNode **node;
+
+  g_return_if_fail (hash_table != NULL);
+  g_return_if_fail (hash_table->ref_count > 0);
+
+  node = g_hash_table_lookup_p_node (hash_table, key);
+
+  if (*node)
+    {
+      /* do not reset node->key in this place, keeping
+       * the old key is the intended behaviour.
+       * g_hash_table_replace() can be used instead.
+       */
+
+      /* free the passed key */
+      if (hash_table->key_destroy_func)
+        hash_table->key_destroy_func (key);
+
+      if (hash_table->value_destroy_func)
+        hash_table->value_destroy_func ((*node)->value);
+
+      (*node)->value = value;
+    }
+  else
+    {
+      *node = g_hash_node_new (key, value);
+      hash_table->nnodes++;
+      G_HASH_TABLE_RESIZE (hash_table);
+    }
 }
 
 /**
@@ -1060,47 +534,25 @@
                       gpointer    key,
                       gpointer    value)
 {
-  g_hash_table_insert_internal (hash_table, key, value, TRUE);
-}
-
-/*
- * g_hash_table_remove_internal:
- * @hash_table: our #GHashTable
- * @key: the key to remove
- * @notify: %TRUE if the destroy notify handlers are to be called
- * Return value: %TRUE if a node was found and removed, else %FALSE
- *
- * Implements the common logic for the g_hash_table_remove() and
- * g_hash_table_steal() functions.
- *
- * Do a lookup of @key and remove it if it is found, calling the
- * destroy notify handlers only if @notify is %TRUE.
- */
-static gboolean
-g_hash_table_remove_internal (GHashTable    *hash_table,
-                              gconstpointer  key,
-                              gboolean       notify)
-{
-  GHashNode *node;
-  guint node_index;
-
-  g_return_val_if_fail (hash_table != NULL, FALSE);
-
-  node_index = g_hash_table_lookup_node (hash_table, key);
-  node = &hash_table->nodes [node_index];
-
-  /* g_hash_table_lookup_node() never returns a tombstone, so this is safe */
-  if (!node->key_hash)
-    return FALSE;
-
-  g_hash_table_remove_node (hash_table, node, notify);
-  g_hash_table_maybe_resize (hash_table);
-
-#ifndef G_DISABLE_ASSERT
-  hash_table->version++;
-#endif
-
-  return TRUE;
+  GHashNode **node;
+  g_return_if_fail (hash_table != NULL);
+  g_return_if_fail (hash_table->ref_count > 0);
+  node = g_hash_table_lookup_p_node (hash_table, key);
+  if (*node)
+    {
+      if (hash_table->key_destroy_func)
+        hash_table->key_destroy_func ((*node)->key);
+      if (hash_table->value_destroy_func)
+        hash_table->value_destroy_func ((*node)->value);
+      (*node)->key   = key;
+      (*node)->value = value;
+    }
+  else
+    {
+      *node = g_hash_node_new (key, value);
+      hash_table->nnodes++;
+      G_HASH_TABLE_RESIZE (hash_table);
+    }
 }
 
 /**
@@ -1121,7 +573,26 @@
 g_hash_table_remove (GHashTable    *hash_table,
                      gconstpointer  key)
 {
-  return g_hash_table_remove_internal (hash_table, key, TRUE);
+  GHashNode **node, *dest;
+
+  g_return_val_if_fail (hash_table != NULL, FALSE);
+
+  node = g_hash_table_lookup_p_node (hash_table, key);
+  if (*node)
+    {
+      dest = *node;
+      (*node) = dest->next;
+      g_hash_node_destroy (dest,
+                           hash_table->key_destroy_func,
+                           hash_table->value_destroy_func);
+      hash_table->nnodes--;
+
+      G_HASH_TABLE_RESIZE (hash_table);
+
+      return TRUE;
+    }
+
+  return FALSE;
 }
 
 /**
@@ -1138,7 +609,24 @@
 g_hash_table_steal (GHashTable    *hash_table,
                     gconstpointer  key)
 {
-  return g_hash_table_remove_internal (hash_table, key, FALSE);
+  GHashNode **node, *dest;
+
+  g_return_val_if_fail (hash_table != NULL, FALSE);
+
+  node = g_hash_table_lookup_p_node (hash_table, key);
+  if (*node)
+    {
+      dest = *node;
+      (*node) = dest->next;
+      g_hash_node_destroy (dest, NULL, NULL);
+      hash_table->nnodes--;
+
+      G_HASH_TABLE_RESIZE (hash_table);
+
+      return TRUE;
+    }
+
+  return FALSE;
 }
 
 /**
@@ -1157,15 +645,20 @@
 void
 g_hash_table_remove_all (GHashTable *hash_table)
 {
+  guint i;
+
   g_return_if_fail (hash_table != NULL);
 
-#ifndef G_DISABLE_ASSERT
-  if (hash_table->nnodes != 0)
-    hash_table->version++;
-#endif
+  for (i = 0; i < hash_table->size; i++)
+    {
+      g_hash_nodes_destroy (hash_table->nodes[i],
+                            hash_table->key_destroy_func,
+                            hash_table->value_destroy_func);
+      hash_table->nodes[i] = NULL;
+    }
+  hash_table->nnodes = 0;
 
-  g_hash_table_remove_all_nodes (hash_table, TRUE);
-  g_hash_table_maybe_resize (hash_table);
+  G_HASH_TABLE_RESIZE (hash_table);
 }
 
 /**
@@ -1180,15 +673,19 @@
 void
 g_hash_table_steal_all (GHashTable *hash_table)
 {
+  guint i;
+
   g_return_if_fail (hash_table != NULL);
 
-#ifndef G_DISABLE_ASSERT
-  if (hash_table->nnodes != 0)
-    hash_table->version++;
-#endif
+  for (i = 0; i < hash_table->size; i++)
+    {
+      g_hash_nodes_destroy (hash_table->nodes[i], NULL, NULL);
+      hash_table->nodes[i] = NULL;
+    }
+
+  hash_table->nnodes = 0;
 
-  g_hash_table_remove_all_nodes (hash_table, FALSE);
-  g_hash_table_maybe_resize (hash_table);
+  G_HASH_TABLE_RESIZE (hash_table);
 }
 
 /*
@@ -1216,24 +713,43 @@
 {
   guint deleted = 0;
   gint i;
+  GHashNode *node, *prev;
 
   for (i = 0; i < hash_table->size; i++)
     {
-      GHashNode *node = &hash_table->nodes [i];
+    restart:
 
-      if (node->key_hash > 1 && (* func) (node->key, node->value, user_data))
+      prev = NULL;
+
+      for (node = hash_table->nodes[i]; node; prev = node, node = node->next)
         {
-          g_hash_table_remove_node (hash_table, node, notify);
-          deleted++;
+          if ((* func) (node->key, node->value, user_data))
+            {
+              deleted += 1;
+
+              hash_table->nnodes -= 1;
+
+              if (prev)
+                {
+                  prev->next = node->next;
+                  g_hash_node_destroy (node,
+                                       notify ? hash_table->key_destroy_func : NULL,
+                                       notify ? hash_table->value_destroy_func : NULL);
+                  node = prev;
+                }
+              else
+                {
+                  hash_table->nodes[i] = node->next;
+                  g_hash_node_destroy (node,
+                                       notify ? hash_table->key_destroy_func : NULL,
+                                       notify ? hash_table->value_destroy_func : NULL);
+                  goto restart;
+                }
+            }
         }
     }
 
-  g_hash_table_maybe_resize (hash_table);
-
-#ifndef G_DISABLE_ASSERT
-  if (deleted > 0)
-    hash_table->version++;
-#endif
+  G_HASH_TABLE_RESIZE (hash_table);
 
   return deleted;
 }
@@ -1261,27 +777,47 @@
 {
   guint deleted = 0;
   gint i;
+  GHashNode *node, *prev;
 
   for (i = 0; i < hash_table->size; i++)
     {
-      if (deleted >= num_entries)
-        break;
+    restart:
 
-      GHashNode *node = &hash_table->nodes [i];
+      prev = NULL;
 
-      if (node->key_hash > 1 && (* func) (node->key, node->value, user_data))
+      for (node = hash_table->nodes[i]; node; prev = node, node = node->next)
         {
-          g_hash_table_remove_node (hash_table, node, TRUE);
-          deleted++;
+
+          if (deleted >= num_entries)
+            goto done;
+          if ((* func) (node->key, node->value, user_data))
+            {
+              deleted += 1;
+
+              hash_table->nnodes -= 1;
+
+              if (prev)
+                {
+                  prev->next = node->next;
+                  g_hash_node_destroy (node,
+                                       hash_table->key_destroy_func,
+                                       hash_table->value_destroy_func);
+                  node = prev;
+                }
+              else
+                {
+                  hash_table->nodes[i] = node->next;
+                  g_hash_node_destroy (node,
+                                       hash_table->key_destroy_func,
+                                       hash_table->value_destroy_func);
+                  goto restart;
+                }
+            }
         }
     }
 
-  g_hash_table_maybe_resize (hash_table);
-
-#ifndef G_DISABLE_ASSERT
-  if (deleted > 0)
-    hash_table->version++;
-#endif
+done:
+  G_HASH_TABLE_RESIZE (hash_table);
 
   return deleted;
 }
@@ -1298,9 +834,6 @@
  * the #GHashTable, they are used to free the memory allocated for the removed
  * keys and values.
  *
- * See #GHashTableIter for an alternative way to loop over the 
- * key/value pairs in the hash table.
- *
  * Return value: the number of key/value pairs removed.
  **/
 guint
@@ -1324,9 +857,6 @@
  * If the function returns %TRUE, then the key/value pair is removed from the
  * #GHashTable, but no key or value destroy functions are called.
  *
- * See #GHashTableIter for an alternative way to loop over the 
- * key/value pairs in the hash table.
- *
  * Return value: the number of key/value pairs removed.
  **/
 guint
@@ -1352,27 +882,21 @@
  * be modified while iterating over it (you can't add/remove
  * items). To remove all items matching a predicate, use
  * g_hash_table_foreach_remove().
- *
- * See g_hash_table_find() for performance caveats for linear
- * order searches in contrast to g_hash_table_lookup().
  **/
 void
 g_hash_table_foreach (GHashTable *hash_table,
                       GHFunc      func,
                       gpointer    user_data)
 {
+  GHashNode *node;
   gint i;
 
   g_return_if_fail (hash_table != NULL);
   g_return_if_fail (func != NULL);
 
   for (i = 0; i < hash_table->size; i++)
-    {
-      GHashNode *node = &hash_table->nodes [i];
-
-      if (node->key_hash > 1)
-        (* func) (node->key, node->value, user_data);
-    }
+    for (node = hash_table->nodes[i]; node; node = node->next)
+      (* func) (node->key, node->value, user_data);
 }
 
 /**
@@ -1386,15 +910,6 @@
  * each pair, and the given @user_data parameter. The hash table may not
  * be modified while iterating over it (you can't add/remove items).
  *
- * Note, that hash tables are really only optimized for forward lookups,
- * i.e. g_hash_table_lookup().
- * So code that frequently issues g_hash_table_find() or
- * g_hash_table_foreach() (e.g. in the order of once per every entry in a
- * hash table) should probably be reworked to use additional or different
- * data structures for reverse lookups (keep in mind that an O(n) find/foreach
- * operation issued for all n values in a hash table ends up needing O(n*n)
- * operations).
- *
  * Return value: The value of the first key/value pair is returned, for which
  * func evaluates to %TRUE. If no pair with the requested property is found,
  * %NULL is returned.
@@ -1406,22 +921,60 @@
                    GHRFunc          predicate,
                    gpointer         user_data)
 {
+  GHashNode *node;
   gint i;
 
   g_return_val_if_fail (hash_table != NULL, NULL);
   g_return_val_if_fail (predicate != NULL, NULL);
 
   for (i = 0; i < hash_table->size; i++)
-    {
-      GHashNode *node = &hash_table->nodes [i];
-
-      if (node->key_hash > 1 && predicate (node->key, node->value, user_data))
+    for (node = hash_table->nodes[i]; node; node = node->next)
+      if (predicate (node->key, node->value, user_data))
         return node->value;
-    }
-
   return NULL;
 }
 
+static GHashNode*
+g_hash_node_new (gpointer key,
+                 gpointer value)
+{
+  GHashNode *hash_node = g_slice_new (GHashNode);
+
+  hash_node->key = key;
+  hash_node->value = value;
+  hash_node->next = NULL;
+  return hash_node;
+}
+
+static void
+g_hash_node_destroy (GHashNode      *hash_node,
+                     GDestroyNotify  key_destroy_func,
+                     GDestroyNotify  value_destroy_func)
+{
+  if (key_destroy_func)
+    key_destroy_func (hash_node->key);
+  if (value_destroy_func)
+    value_destroy_func (hash_node->value);
+  g_slice_free (GHashNode, hash_node);
+}
+
+static void
+g_hash_nodes_destroy (GHashNode *hash_node,
+                      GFreeFunc  key_destroy_func,
+                      GFreeFunc  value_destroy_func)
+{
+  while (hash_node)
+    {
+      GHashNode *next = hash_node->next;
+      if (key_destroy_func)
+        key_destroy_func (hash_node->key);
+      if (value_destroy_func)
+        value_destroy_func (hash_node->value);
+      g_slice_free (GHashNode, hash_node);
+      hash_node = next;
+    }
+}
+
 /**
  * g_hash_table_size:
  * @hash_table: a #GHashTable.
@@ -1438,70 +991,3 @@
   return hash_table->nnodes;
 }
 
-/**
- * g_hash_table_get_keys:
- * @hash_table: a #GHashTable
- *
- * Retrieves every key inside @hash_table. The returned data is valid
- * until @hash_table is modified.
- *
- * Return value: a #GList containing all the keys inside the hash
- *   table. The content of the list is owned by the hash table and
- *   should not be modified or freed. Use g_list_free() when done
- *   using the list.
- *
- * Since: 2.14
- */
-GList *
-g_hash_table_get_keys (GHashTable *hash_table)
-{
-  gint i;
-  GList *retval;
-
-  g_return_val_if_fail (hash_table != NULL, NULL);
-
-  retval = NULL;
-  for (i = 0; i < hash_table->size; i++)
-    {
-      GHashNode *node = &hash_table->nodes [i];
-
-      if (node->key_hash > 1)
-        retval = g_list_prepend (retval, node->key);
-    }
-
-  return retval;
-}
-
-/**
- * g_hash_table_get_values:
- * @hash_table: a #GHashTable
- *
- * Retrieves every value inside @hash_table. The returned data is
- * valid until @hash_table is modified.
- *
- * Return value: a #GList containing all the values inside the hash
- *   table. The content of the list is owned by the hash table and
- *   should not be modified or freed. Use g_list_free() when done
- *   using the list.
- *
- * Since: 2.14
- */
-GList *
-g_hash_table_get_values (GHashTable *hash_table)
-{
-  gint i;
-  GList *retval;
-
-  g_return_val_if_fail (hash_table != NULL, NULL);
-
-  retval = NULL;
-  for (i = 0; i < hash_table->size; i++)
-    {
-      GHashNode *node = &hash_table->nodes [i];
-
-      if (node->key_hash > 1)
-        retval = g_list_prepend (retval, node->value);
-    }
-
-  return retval;
-}
diff -uNr glib-2.28.8-orig/glib/ghash.h glib-2.28.8-new/glib/ghash.h
--- glib-2.28.8-orig/glib/ghash.h	2015-06-02 18:08:19.000000000 -0700
+++ glib-2.28.8-new/glib/ghash.h	2015-06-02 18:20:34.000000000 -0700
@@ -24,15 +24,10 @@
  * GLib at ftp://ftp.gtk.org/pub/gtk/.
  */
 
-#if defined(G_DISABLE_SINGLE_INCLUDES) && !defined (__GLIB_H_INSIDE__) && !defined (GLIB_COMPILATION)
-#error "Only <glib.h> can be included directly."
-#endif
-
 #ifndef __G_HASH_H__
 #define __G_HASH_H__
 
 #include <glib/gtypes.h>
-#include <glib/glist.h>
 
 G_BEGIN_DECLS
 
@@ -42,19 +37,6 @@
                                gpointer  value,
                                gpointer  user_data);
 
-typedef struct _GHashTableIter GHashTableIter;
-
-struct _GHashTableIter
-{
-  /*< private >*/
-  gpointer	dummy1;
-  gpointer	dummy2;
-  gpointer	dummy3;
-  int		dummy4;
-  gboolean	dummy5;
-  gpointer	dummy6;
-};
-
 /* Hash tables
  */
 GHashTable* g_hash_table_new		   (GHashFunc	    hash_func,
@@ -99,17 +81,6 @@
 					    GHRFunc	    func,
 					    gpointer	    user_data);
 guint	    g_hash_table_size		   (GHashTable	   *hash_table);
-GList *     g_hash_table_get_keys          (GHashTable     *hash_table);
-GList *     g_hash_table_get_values        (GHashTable     *hash_table);
-
-void        g_hash_table_iter_init         (GHashTableIter *iter,
-					    GHashTable     *hash_table);
-gboolean    g_hash_table_iter_next         (GHashTableIter *iter,
-					    gpointer       *key,
-					    gpointer       *value);
-GHashTable* g_hash_table_iter_get_hash_table (GHashTableIter *iter);
-void        g_hash_table_iter_remove       (GHashTableIter *iter);
-void        g_hash_table_iter_steal        (GHashTableIter *iter);
 
 /* keeping hash tables alive */
 GHashTable* g_hash_table_ref   		   (GHashTable 	   *hash_table);
diff -uNr glib-2.28.8-orig/glib/glib.symbols glib-2.28.8-new/glib/glib.symbols
--- glib-2.28.8-orig/glib/glib.symbols	2015-06-02 18:08:19.000000000 -0700
+++ glib-2.28.8-new/glib/glib.symbols	2015-06-02 18:20:34.000000000 -0700
@@ -464,8 +464,6 @@
 g_hash_table_foreach_remove
 g_hash_table_foreach_remove_n
 g_hash_table_foreach_steal
-g_hash_table_get_keys
-g_hash_table_get_values
 g_hash_table_insert
 g_hash_table_lookup
 g_hash_table_lookup_extended
@@ -477,11 +475,6 @@
 g_hash_table_size
 g_hash_table_steal
 g_hash_table_steal_all
-g_hash_table_iter_init
-g_hash_table_iter_next
-g_hash_table_iter_get_hash_table
-g_hash_table_iter_remove
-g_hash_table_iter_steal
 #endif
 #endif
 
diff -uNr glib-2.28.8-orig/glib/tests/hash.c glib-2.28.8-new/glib/tests/hash.c
--- glib-2.28.8-orig/glib/tests/hash.c	2011-06-05 16:18:49.000000000 -0700
+++ glib-2.28.8-new/glib/tests/hash.c	2015-06-02 18:33:59.000000000 -0700
@@ -44,50 +44,7 @@
 
 int array[10000];
 
-static void
-fill_hash_table_and_array (GHashTable *hash_table)
-{
-  int i;
-
-  for (i = 0; i < 10000; i++)
-    {
-      array[i] = i;
-      g_hash_table_insert (hash_table, &array[i], &array[i]);
-    }
-}
-
-static void
-init_result_array (int result_array[10000])
-{
-  int i;
-
-  for (i = 0; i < 10000; i++)
-    result_array[i] = -1;
-}
 
-static void
-verify_result_array (int array[10000])
-{
-  int i;
-
-  for (i = 0; i < 10000; i++)
-    g_assert (array[i] == i);
-}
-
-static void
-handle_pair (gpointer key, gpointer value, int result_array[10000])
-{
-  int n;
-
-  g_assert (key == value);
-
-  n = *((int *) value);
-
-  g_assert (n >= 0 && n < 10000);
-  g_assert (result_array[n] == -1);
-
-  result_array[n] = n;
-}
 
 static gboolean
 my_hash_callback_remove (gpointer key,
@@ -118,7 +75,8 @@
                   gpointer value,
                   gpointer user_data)
 {
-  handle_pair (key, value, user_data);
+  int *d = value;
+  *d = 1;
 }
 
 static guint
@@ -276,9 +234,8 @@
 
      crcinit ();
 
-     h = g_hash_table_new_full (simple_hash ? one_hash : honeyman_hash,
-                                second_hash_cmp,
-                                g_free, g_free);
+     h = g_hash_table_new (simple_hash ? one_hash : honeyman_hash,
+                           second_hash_cmp);
      g_assert (h != NULL);
      for (i=0; i<20; i++)
           {
@@ -307,13 +264,14 @@
 
      sprintf (key, "%d", 3);
      g_hash_table_remove (h, key);
-     g_assert (g_hash_table_size (h) == 19);
      g_hash_table_foreach_remove (h, remove_even_foreach, NULL);
-     g_assert (g_hash_table_size (h) == 9);
      g_hash_table_foreach (h, not_even_foreach, NULL);
 
      for (i=0; i<20; i++)
           {
+          if ((i % 2) == 0 || i == 3)
+                continue;
+
           sprintf (key, "%d", i);
           g_assert (atoi(key) == i);
 
@@ -324,19 +282,17 @@
           found = g_hash_table_lookup_extended (h, key,
                                                 (gpointer)&orig_key,
                                                 (gpointer)&orig_val);
-          if ((i % 2) == 0 || i == 3)
-            {
-              g_assert (!found);
-              continue;
-            }
-
           g_assert (found);
 
+          g_hash_table_remove (h, key);
+
           g_assert (orig_key != NULL);
           g_assert (strcmp (key, orig_key) == 0);
+          g_free (orig_key);
 
           g_assert (orig_val != NULL);
           g_assert (strcmp (val, orig_val) == 0);
+          g_free (orig_val);
           }
 
     g_hash_table_destroy (h);
@@ -485,59 +441,31 @@
   gint i;
   gint value = 120;
   gint *pvalue;
-  GList *keys, *values;
-  gint keys_len, values_len;
-  GHashTableIter iter;
-  gpointer ikey, ivalue;
-  int result_array[10000];
 
   hash_table = g_hash_table_new (my_hash, my_hash_equal);
-  fill_hash_table_and_array (hash_table);
+  for (i = 0; i < 10000; i++)
+    {
+      array[i] = i;
+      g_hash_table_insert (hash_table, &array[i], &array[i]);
+    }
   pvalue = g_hash_table_find (hash_table, find_first, &value);
   if (!pvalue || *pvalue != value)
     g_assert_not_reached();
 
-  keys = g_hash_table_get_keys (hash_table);
-  if (!keys)
-    g_assert_not_reached ();
+  g_hash_table_foreach (hash_table, my_hash_callback, NULL);
 
-  values = g_hash_table_get_values (hash_table);
-  if (!values)
-    g_assert_not_reached ();
-
-  keys_len = g_list_length (keys);
-  values_len = g_list_length (values);
-  if (values_len != keys_len &&  keys_len != g_hash_table_size (hash_table))
-    g_assert_not_reached ();
-
-  g_list_free (keys);
-  g_list_free (values);
-
-  init_result_array (result_array);
-  g_hash_table_iter_init (&iter, hash_table);
   for (i = 0; i < 10000; i++)
-    {
-      g_assert (g_hash_table_iter_next (&iter, &ikey, &ivalue));
-
-      handle_pair (ikey, ivalue, result_array);
-
-      if (i % 2)
-        g_hash_table_iter_remove (&iter);
-    }
-  g_assert (! g_hash_table_iter_next (&iter, &ikey, &ivalue));
-  g_assert (g_hash_table_size (hash_table) == 5000);
-  verify_result_array (result_array);
-
-  fill_hash_table_and_array (hash_table);
-
-  init_result_array (result_array);
-  g_hash_table_foreach (hash_table, my_hash_callback, result_array);
-  verify_result_array (result_array);
+    if (array[i] == 0)
+      g_assert_not_reached();
 
   for (i = 0; i < 10000; i++)
     g_hash_table_remove (hash_table, &array[i]);
 
-  fill_hash_table_and_array (hash_table);
+  for (i = 0; i < 10000; i++)
+    {
+      array[i] = i;
+      g_hash_table_insert (hash_table, &array[i], &array[i]);
+    }
 
   if (g_hash_table_foreach_remove (hash_table, my_hash_callback_remove, NULL) != 5000 ||
       g_hash_table_size (hash_table) != 5000)
@@ -555,15 +483,38 @@
   destroy_counter++;
 }
 
+typedef struct test_hash_ref_data {
+  gboolean abc_seen;
+  gboolean cde_seen;
+  gboolean xyz_seen;
+} test_hash_ref_data_t;
+
+static gboolean
+steal_data_handler(gpointer key, gpointer value, gpointer user_data)
+{
+  test_hash_ref_data_t *d = (test_hash_ref_data_t *)user_data;
+  if (strcmp (key, "abc") == 0) {
+      g_assert_cmpstr (value, ==, "ABC");
+      d->abc_seen = TRUE;
+      return TRUE; // Steal
+  } else if (strcmp (key, "cde") == 0) {
+      g_assert_cmpstr (value, ==, "CDE");
+      d->cde_seen = TRUE;
+  } else if (strcmp (key, "xyz") == 0) {
+      g_assert_cmpstr (value, ==, "XYZ");
+      d->xyz_seen = TRUE;
+  }
+  return FALSE; // Keep
+}
+
 static void
 test_hash_ref (void)
 {
   GHashTable *h;
-  GHashTableIter iter;
-  gchar *key, *value;
-  gboolean abc_seen = FALSE;
-  gboolean cde_seen = FALSE;
-  gboolean xyz_seen = FALSE;
+  test_hash_ref_data_t d;
+  d.abc_seen = FALSE;
+  d.cde_seen = FALSE;
+  d.xyz_seen = FALSE;
 
   h = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, value_destroy);
   g_hash_table_insert (h, "abc", "ABC");
@@ -572,31 +523,11 @@
 
   g_assert_cmpint (g_hash_table_size (h), == , 3);
 
-  g_hash_table_iter_init (&iter, h);
+  g_hash_table_foreach_steal(h, steal_data_handler, &d);
 
-  while (g_hash_table_iter_next (&iter, (gpointer*)&key, (gpointer*)&value))
-    {
-      if (strcmp (key, "abc") == 0)
-        {
-          g_assert_cmpstr (value, ==, "ABC");
-          abc_seen = TRUE;
-          g_hash_table_iter_steal (&iter);
-        }
-      else if (strcmp (key, "cde") == 0)
-        {
-          g_assert_cmpstr (value, ==, "CDE");
-          cde_seen = TRUE;
-        }
-      else if (strcmp (key, "xyz") == 0)
-        {
-          g_assert_cmpstr (value, ==, "XYZ");
-          xyz_seen = TRUE;
-        }
-    }
   g_assert_cmpint (destroy_counter, ==, 0);
 
-  g_assert (g_hash_table_iter_get_hash_table (&iter) == h);
-  g_assert (abc_seen && cde_seen && xyz_seen);
+  g_assert (d.abc_seen && d.cde_seen && d.xyz_seen);
   g_assert_cmpint (g_hash_table_size (h), == , 2);
 
   g_hash_table_ref (h);
