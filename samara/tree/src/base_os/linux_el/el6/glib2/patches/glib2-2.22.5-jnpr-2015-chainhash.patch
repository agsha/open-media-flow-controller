diff -uNr glib-2.22.5/gio/gcontenttype.c glib-2.22.5.new/gio/gcontenttype.c
--- glib-2.22.5/gio/gcontenttype.c	2010-03-13 11:20:02.000000000 -0800
+++ glib-2.22.5.new/gio/gcontenttype.c	2015-03-26 12:47:33.000000000 -0700
@@ -1050,6 +1050,17 @@
   g_free (mimedir);
 }
 
+
+
+static void
+list_mime (gpointer     key,
+           gpointer     value,
+           gpointer     user_data)
+{
+        GList ** l = user_data;
+        l = g_list_prepend(*l, key);
+}
+
 /**
  * g_content_types_get_registered:
  * 
@@ -1063,7 +1074,6 @@
 {
   const char * const* dirs;
   GHashTable *mimetypes;
-  GHashTableIter iter;
   gpointer key;
   int i;
   GList *l;
@@ -1077,12 +1087,7 @@
     enumerate_mimetypes_dir (dirs[i], mimetypes);
 
   l = NULL;
-  g_hash_table_iter_init (&iter, mimetypes);
-  while (g_hash_table_iter_next (&iter, &key, NULL))
-    {
-      l = g_list_prepend (l, key);
-      g_hash_table_iter_steal (&iter);
-    }
+  g_hash_table_foreach(mimetypes, list_mime, &l);
 
   g_hash_table_destroy (mimetypes);
 
diff -uNr glib-2.22.5/gio/gdesktopappinfo.c glib-2.22.5.new/gio/gdesktopappinfo.c
--- glib-2.22.5/gio/gdesktopappinfo.c	2010-03-15 19:38:47.000000000 -0700
+++ glib-2.22.5.new/gio/gdesktopappinfo.c	2015-03-26 12:47:33.000000000 -0700
@@ -1892,7 +1892,16 @@
     }
 }
 
-
+static void
+list_info (gpointer     key,
+           gpointer     value,
+           gpointer     user_data)
+{
+        if (value) {
+                GList ** l = user_data;
+                *l = g_list_prepend(*l, value);
+        }
+}
 /**
  * g_app_info_get_all:
  *
@@ -1913,7 +1922,6 @@
 {
   const char * const *dirs;
   GHashTable *apps;
-  GHashTableIter iter;
   gpointer value;
   int i;
   GList *infos;
@@ -1929,12 +1937,7 @@
 
 
   infos = NULL;
-  g_hash_table_iter_init (&iter, apps);
-  while (g_hash_table_iter_next (&iter, NULL, &value))
-    {
-      if (value)
-        infos = g_list_prepend (infos, value);
-    }
+  g_hash_table_foreach(apps, list_info, &infos);
 
   g_hash_table_destroy (apps);
 
diff -uNr glib-2.22.5/glib/galias.h glib-2.22.5.new/glib/galias.h
--- glib-2.22.5/glib/galias.h	2010-03-15 21:06:08.000000000 -0700
+++ glib-2.22.5.new/glib/galias.h	2015-03-26 12:47:33.000000000 -0700
@@ -925,12 +925,6 @@
 extern __typeof (g_hash_table_foreach_steal) IA__g_hash_table_foreach_steal __attribute((visibility("hidden")));
 #define g_hash_table_foreach_steal IA__g_hash_table_foreach_steal
 
-extern __typeof (g_hash_table_get_keys) IA__g_hash_table_get_keys __attribute((visibility("hidden")));
-#define g_hash_table_get_keys IA__g_hash_table_get_keys
-
-extern __typeof (g_hash_table_get_values) IA__g_hash_table_get_values __attribute((visibility("hidden")));
-#define g_hash_table_get_values IA__g_hash_table_get_values
-
 extern __typeof (g_hash_table_insert) IA__g_hash_table_insert __attribute((visibility("hidden")));
 #define g_hash_table_insert IA__g_hash_table_insert
 
@@ -964,20 +958,6 @@
 extern __typeof (g_hash_table_steal_all) IA__g_hash_table_steal_all __attribute((visibility("hidden")));
 #define g_hash_table_steal_all IA__g_hash_table_steal_all
 
-extern __typeof (g_hash_table_iter_init) IA__g_hash_table_iter_init __attribute((visibility("hidden")));
-#define g_hash_table_iter_init IA__g_hash_table_iter_init
-
-extern __typeof (g_hash_table_iter_next) IA__g_hash_table_iter_next __attribute((visibility("hidden")));
-#define g_hash_table_iter_next IA__g_hash_table_iter_next
-
-extern __typeof (g_hash_table_iter_get_hash_table) IA__g_hash_table_iter_get_hash_table __attribute((visibility("hidden")));
-#define g_hash_table_iter_get_hash_table IA__g_hash_table_iter_get_hash_table
-
-extern __typeof (g_hash_table_iter_remove) IA__g_hash_table_iter_remove __attribute((visibility("hidden")));
-#define g_hash_table_iter_remove IA__g_hash_table_iter_remove
-
-extern __typeof (g_hash_table_iter_steal) IA__g_hash_table_iter_steal __attribute((visibility("hidden")));
-#define g_hash_table_iter_steal IA__g_hash_table_iter_steal
 
 #endif
 #endif
diff -uNr glib-2.22.5/glib/galiasdef.c glib-2.22.5.new/glib/galiasdef.c
--- glib-2.22.5/glib/galiasdef.c	2010-03-15 21:06:08.000000000 -0700
+++ glib-2.22.5.new/glib/galiasdef.c	2015-03-26 12:47:33.000000000 -0700
@@ -928,12 +928,6 @@
 #undef g_hash_table_foreach_steal 
 extern __typeof (g_hash_table_foreach_steal) g_hash_table_foreach_steal __attribute((alias("IA__g_hash_table_foreach_steal"), visibility("default")));
 
-#undef g_hash_table_get_keys 
-extern __typeof (g_hash_table_get_keys) g_hash_table_get_keys __attribute((alias("IA__g_hash_table_get_keys"), visibility("default")));
-
-#undef g_hash_table_get_values 
-extern __typeof (g_hash_table_get_values) g_hash_table_get_values __attribute((alias("IA__g_hash_table_get_values"), visibility("default")));
-
 #undef g_hash_table_insert 
 extern __typeof (g_hash_table_insert) g_hash_table_insert __attribute((alias("IA__g_hash_table_insert"), visibility("default")));
 
@@ -967,20 +961,6 @@
 #undef g_hash_table_steal_all 
 extern __typeof (g_hash_table_steal_all) g_hash_table_steal_all __attribute((alias("IA__g_hash_table_steal_all"), visibility("default")));
 
-#undef g_hash_table_iter_init 
-extern __typeof (g_hash_table_iter_init) g_hash_table_iter_init __attribute((alias("IA__g_hash_table_iter_init"), visibility("default")));
-
-#undef g_hash_table_iter_next 
-extern __typeof (g_hash_table_iter_next) g_hash_table_iter_next __attribute((alias("IA__g_hash_table_iter_next"), visibility("default")));
-
-#undef g_hash_table_iter_get_hash_table 
-extern __typeof (g_hash_table_iter_get_hash_table) g_hash_table_iter_get_hash_table __attribute((alias("IA__g_hash_table_iter_get_hash_table"), visibility("default")));
-
-#undef g_hash_table_iter_remove 
-extern __typeof (g_hash_table_iter_remove) g_hash_table_iter_remove __attribute((alias("IA__g_hash_table_iter_remove"), visibility("default")));
-
-#undef g_hash_table_iter_steal 
-extern __typeof (g_hash_table_iter_steal) g_hash_table_iter_steal __attribute((alias("IA__g_hash_table_iter_steal"), visibility("default")));
 
 #endif
 #endif
diff -uNr glib-2.22.5/glib/ghash.c glib-2.22.5.new/glib/ghash.c
--- glib-2.22.5/glib/ghash.c	2015-03-25 13:59:19.000000000 -0700
+++ glib-2.22.5.new/glib/ghash.c	2015-03-26 12:47:33.000000000 -0700
@@ -30,12 +30,13 @@
 
 #include "config.h"
 
-#include <string.h>  /* memset */
-
 #include "glib.h"
 #include "galias.h"
 
-#define HASH_TABLE_MIN_SHIFT 3  /* 1 << 3 == 8 buckets */
+
+#define HASH_TABLE_MIN_SIZE 11
+#define HASH_TABLE_MAX_SIZE 13845163
+
 
 typedef struct _GHashNode      GHashNode;
 
@@ -43,345 +44,45 @@
 {
   gpointer   key;
   gpointer   value;
-
-  /* If key_hash == 0, node is not in use
-   * If key_hash == 1, node is a tombstone
-   * If key_hash >= 2, node contains data */
-  guint      key_hash;
+  GHashNode *next;
 };
 
 struct _GHashTable
 {
   gint             size;
-  gint             mod;
-  guint            mask;
   gint             nnodes;
-  gint             noccupied;  /* nnodes + tombstones */
-  GHashNode       *nodes;
+  GHashNode      **nodes;
   GHashFunc        hash_func;
   GEqualFunc       key_equal_func;
   volatile gint    ref_count;
-#ifndef G_DISABLE_ASSERT
-  /*
-   * Tracks the structure of the hash table, not its contents: is only
-   * incremented when a node is added or removed (is not incremented
-   * when the key or data of a node is modified).
-   */
-  int              version;
-#endif
   GDestroyNotify   key_destroy_func;
   GDestroyNotify   value_destroy_func;
 };
 
-typedef struct
-{
-  GHashTable  *hash_table;
-  gpointer     dummy1;
-  gpointer     dummy2;
-  int          position;
-  gboolean     dummy3;
-  int          version;
-} RealIter;
-
-/* Each table size has an associated prime modulo (the first prime
- * lower than the table size) used to find the initial bucket. Probing
- * then works modulo 2^n. The prime modulo is necessary to get a
- * good distribution with poor hash functions. */
-static const gint prime_mod [] =
-{
-  1,          /* For 1 << 0 */
-  2,
-  3,
-  7,
-  13,
-  31,
-  61,
-  127,
-  251,
-  509,
-  1021,
-  2039,
-  4093,
-  8191,
-  16381,
-  32749,
-  65521,      /* For 1 << 16 */
-  131071,
-  262139,
-  524287,
-  1048573,
-  2097143,
-  4194301,
-  8388593,
-  16777213,
-  33554393,
-  67108859,
-  134217689,
-  268435399,
-  536870909,
-  1073741789,
-  2147483647  /* For 1 << 31 */
-};
-
-static void
-g_hash_table_set_shift (GHashTable *hash_table, gint shift)
-{
-  gint i;
-  guint mask = 0;
-
-  hash_table->size = 1 << shift;
-  hash_table->mod  = prime_mod [shift];
-
-  for (i = 0; i < shift; i++)
-    {
-      mask <<= 1;
-      mask |= 1;
-    }
-
-  hash_table->mask = mask;
-}
-
-static gint
-g_hash_table_find_closest_shift (gint n)
-{
-  gint i;
-
-  for (i = 0; n; i++)
-    n >>= 1;
-
-  return i;
-}
-
-static void
-g_hash_table_set_shift_from_size (GHashTable *hash_table, gint size)
-{
-  gint shift;
-
-  shift = g_hash_table_find_closest_shift (size);
-  shift = MAX (shift, HASH_TABLE_MIN_SHIFT);
-
-  g_hash_table_set_shift (hash_table, shift);
-}
-
-/*
- * g_hash_table_lookup_node:
- * @hash_table: our #GHashTable
- * @key: the key to lookup against
- * @hash_return: optional key hash return location
- * Return value: index of the described #GHashNode
- *
- * Performs a lookup in the hash table.  Virtually all hash operations
- * will use this function internally.
- *
- * This function first computes the hash value of the key using the
- * user's hash function.
- *
- * If an entry in the table matching @key is found then this function
- * returns the index of that entry in the table, and if not, the
- * index of an empty node (never a tombstone).
- */
-static inline guint
-g_hash_table_lookup_node (GHashTable    *hash_table,
-                          gconstpointer  key)
-{
-  GHashNode *node;
-  guint node_index;
-  guint hash_value;
-  guint step = 0;
-
-  /* Empty buckets have hash_value set to 0, and for tombstones, it's 1.
-   * We need to make sure our hash value is not one of these. */
-
-  hash_value = (* hash_table->hash_func) (key);
-  if (G_UNLIKELY (hash_value <= 1))
-    hash_value = 2;
-
-  node_index = hash_value % hash_table->mod;
-  node = &hash_table->nodes [node_index];
-
-  while (node->key_hash)
-    {
-      /*  We first check if our full hash values
-       *  are equal so we can avoid calling the full-blown
-       *  key equality function in most cases.
-       */
-
-      if (node->key_hash == hash_value)
-        {
-          if (hash_table->key_equal_func)
-            {
-              if (hash_table->key_equal_func (node->key, key))
-                break;
-            }
-          else if (node->key == key)
-            {
-              break;
-            }
-        }
-
-      step++;
-      node_index += step;
-      node_index &= hash_table->mask;
-      node = &hash_table->nodes [node_index];
-    }
-
-  return node_index;
-}
-
-/*
- * g_hash_table_lookup_node_for_insertion:
- * @hash_table: our #GHashTable
- * @key: the key to lookup against
- * @hash_return: key hash return location
- * Return value: index of the described #GHashNode
- *
- * Performs a lookup in the hash table, preserving extra information
- * usually needed for insertion.
- *
- * This function first computes the hash value of the key using the
- * user's hash function.
- *
- * If an entry in the table matching @key is found then this function
- * returns the index of that entry in the table, and if not, the
- * index of an unused node (empty or tombstone) where the key can be
- * inserted.
- *
- * The computed hash value is returned in the variable pointed to
- * by @hash_return. This is to save insertions from having to compute
- * the hash record again for the new record.
- */
-static inline guint
-g_hash_table_lookup_node_for_insertion (GHashTable    *hash_table,
-                                        gconstpointer  key,
-                                        guint         *hash_return)
-{
-  GHashNode *node;
-  guint node_index;
-  guint hash_value;
-  guint first_tombstone;
-  gboolean have_tombstone = FALSE;
-  guint step = 0;
-
-  /* Empty buckets have hash_value set to 0, and for tombstones, it's 1.
-   * We need to make sure our hash value is not one of these. */
-
-  hash_value = (* hash_table->hash_func) (key);
-  if (G_UNLIKELY (hash_value <= 1))
-    hash_value = 2;
-
-  *hash_return = hash_value;
-
-  node_index = hash_value % hash_table->mod;
-  node = &hash_table->nodes [node_index];
-
-  while (node->key_hash)
-    {
-      /*  We first check if our full hash values
-       *  are equal so we can avoid calling the full-blown
-       *  key equality function in most cases.
-       */
-
-      if (node->key_hash == hash_value)
-        {
-          if (hash_table->key_equal_func)
-            {
-              if (hash_table->key_equal_func (node->key, key))
-                return node_index;
-            }
-          else if (node->key == key)
-            {
-              return node_index;
-            }
-        }
-      else if (node->key_hash == 1 && !have_tombstone)
-        {
-          first_tombstone = node_index;
-          have_tombstone = TRUE;
-        }
-
-      step++;
-      node_index += step;
-      node_index &= hash_table->mask;
-      node = &hash_table->nodes [node_index];
-    }
-
-  if (have_tombstone)
-    return first_tombstone;
-
-  return node_index;
-}
-
-/*
- * g_hash_table_remove_node:
- * @hash_table: our #GHashTable
- * @node: pointer to node to remove
- * @notify: %TRUE if the destroy notify handlers are to be called
- *
- * Removes a node from the hash table and updates the node count.
- * The node is replaced by a tombstone. No table resize is performed.
- *
- * If @notify is %TRUE then the destroy notify functions are called
- * for the key and value of the hash node.
- */
-static void
-g_hash_table_remove_node (GHashTable   *hash_table,
-                          GHashNode    *node,
-                          gboolean      notify)
-{
-  if (notify && hash_table->key_destroy_func)
-    hash_table->key_destroy_func (node->key);
-
-  if (notify && hash_table->value_destroy_func)
-    hash_table->value_destroy_func (node->value);
-
-  /* Erect tombstone */
-  node->key_hash = 1;
-
-  /* Be GC friendly */
-  node->key = NULL;
-  node->value = NULL;
-
-  hash_table->nnodes--;
-}
-
-/*
- * g_hash_table_remove_all_nodes:
- * @hash_table: our #GHashTable
- * @notify: %TRUE if the destroy notify handlers are to be called
- *
- * Removes all nodes from the table.  Since this may be a precursor to
- * freeing the table entirely, no resize is performed.
- *
- * If @notify is %TRUE then the destroy notify functions are called
- * for the key and value of the hash node.
- */
-static void
-g_hash_table_remove_all_nodes (GHashTable *hash_table,
-                               gboolean    notify)
-{
-  int i;
-
-  for (i = 0; i < hash_table->size; i++)
-    {
-      GHashNode *node = &hash_table->nodes [i];
-
-      if (node->key_hash > 1)
-        {
-          if (notify && hash_table->key_destroy_func)
-            hash_table->key_destroy_func (node->key);
-
-          if (notify && hash_table->value_destroy_func)
-            hash_table->value_destroy_func (node->value);
-        }
-    }
-
-  /* We need to set node->key_hash = 0 for all nodes - might as well be GC
-   * friendly and clear everything */
-  memset (hash_table->nodes, 0, hash_table->size * sizeof (GHashNode));
-
-  hash_table->nnodes = 0;
-  hash_table->noccupied = 0;
-}
+#define G_HASH_TABLE_RESIZE(hash_table)                         \
+   G_STMT_START {                                               \
+     if ((hash_table->size >= 3 * hash_table->nnodes &&         \
+          hash_table->size > HASH_TABLE_MIN_SIZE) ||            \
+         (3 * hash_table->size <= hash_table->nnodes &&         \
+          hash_table->size < HASH_TABLE_MAX_SIZE))              \
+           g_hash_table_resize (hash_table);                    \
+   } G_STMT_END
+
+static void             g_hash_table_resize       (GHashTable     *hash_table);
+static GHashNode**      g_hash_table_lookup_p_node(GHashTable     *hash_table,
+                                                   gconstpointer   key);
+static GHashNode*       g_hash_node_new           (gpointer        key,
+                                                   gpointer        value);
+static void             g_hash_node_destroy       (GHashNode      *hash_node,
+                                                   GDestroyNotify  key_destroy_func,
+                                                   GDestroyNotify  value_destroy_func);
+static void             g_hash_nodes_destroy     (GHashNode       *hash_node,
+                                                  GDestroyNotify   key_destroy_func,
+                                                  GDestroyNotify   value_destroy_func);
+static guint g_hash_table_foreach_remove_or_steal (GHashTable     *hash_table,
+                                                   GHRFunc         func,
+                                                   gpointer        user_data,
+                                                   gboolean        notify);
 
 /*
  * g_hash_table_resize:
@@ -389,8 +90,7 @@
  *
  * Resizes the hash table to the optimal size based on the number of
  * nodes currently held.  If you call this function then a resize will
- * occur, even if one does not need to occur.  Use
- * g_hash_table_maybe_resize() instead.
+ * occur, even if one does not need to occur.
  *
  * This function may "resize" the hash table to its current size, with
  * the side effect of cleaning up tombstones and otherwise optimizing
@@ -399,75 +99,46 @@
 static void
 g_hash_table_resize (GHashTable *hash_table)
 {
-  GHashNode *new_nodes;
-  gint old_size;
+  GHashNode **new_nodes;
+  GHashNode *node;
+  GHashNode *next;
+  guint hash_val;
+  gint new_size;
   gint i;
 
-  old_size = hash_table->size;
-  g_hash_table_set_shift_from_size (hash_table, hash_table->nnodes * 2);
-
-  new_nodes = g_new0 (GHashNode, hash_table->size);
+  new_size = g_spaced_primes_closest (hash_table->nnodes);
+  new_size = CLAMP (new_size, HASH_TABLE_MIN_SIZE, HASH_TABLE_MAX_SIZE);
 
-  for (i = 0; i < old_size; i++)
-    {
-      GHashNode *node = &hash_table->nodes [i];
-      GHashNode *new_node;
-      guint hash_val;
-      guint step = 0;
-
-      if (node->key_hash <= 1)
-        continue;
-
-      hash_val = node->key_hash % hash_table->mod;
-      new_node = &new_nodes [hash_val];
-
-      while (new_node->key_hash)
-        {
-          step++;
-          hash_val += step;
-          hash_val &= hash_table->mask;
-          new_node = &new_nodes [hash_val];
-        }
+  new_nodes = g_new0 (GHashNode*, new_size);
 
-      *new_node = *node;
-    }
+  for (i = 0; i < hash_table->size; i++)
+    for (node = hash_table->nodes[i]; node; node = next)
+      {
+        next = node->next;
+
+        hash_val = (* hash_table->hash_func) (node->key) % new_size;
+
+        node->next = new_nodes[hash_val];
+        new_nodes[hash_val] = node;
+      }
 
   g_free (hash_table->nodes);
   hash_table->nodes = new_nodes;
-  hash_table->noccupied = hash_table->nnodes;
+  hash_table->size = new_size;
 }
 
-/*
- * g_hash_table_maybe_resize:
- * @hash_table: our #GHashTable
- *
- * Resizes the hash table, if needed.
- *
- * Essentially, calls g_hash_table_resize() if the table has strayed
- * too far from its ideal size for its number of nodes.
- */
-static inline void
-g_hash_table_maybe_resize (GHashTable *hash_table)
-{
-  gint noccupied = hash_table->noccupied;
-  gint size = hash_table->size;
-
-  if ((size > hash_table->nnodes * 4 && size > 1 << HASH_TABLE_MIN_SHIFT) ||
-      (size <= noccupied + (noccupied / 16)))
-    g_hash_table_resize (hash_table);
-}
 
 /**
  * g_hash_table_new:
  * @hash_func: a function to create a hash value from a key.
  *   Hash values are used to determine where keys are stored within the
  *   #GHashTable data structure. The g_direct_hash(), g_int_hash(),
- *   g_int64_hash(), g_double_hash() and g_str_hash() functions are provided
+ *   g_str_hash() functions are provided
  *   for some common types of keys.
  *   If hash_func is %NULL, g_direct_hash() is used.
  * @key_equal_func: a function to check two keys for equality.  This is
  *   used when looking up keys in the #GHashTable.  The g_direct_equal(),
- *   g_int_equal(), g_int64_equal(), g_double_equal() and g_str_equal()
+ *   g_int_equal() and g_str_equal()
  *   functions are provided for the most common types of keys.
  *   If @key_equal_func is %NULL, keys are compared directly in a similar
  *   fashion to g_direct_equal(), but without the overhead of a function call.
@@ -510,188 +181,18 @@
   GHashTable *hash_table;
 
   hash_table = g_slice_new (GHashTable);
-  g_hash_table_set_shift (hash_table, HASH_TABLE_MIN_SHIFT);
+  hash_table->size               = HASH_TABLE_MIN_SIZE;
   hash_table->nnodes             = 0;
-  hash_table->noccupied          = 0;
   hash_table->hash_func          = hash_func ? hash_func : g_direct_hash;
   hash_table->key_equal_func     = key_equal_func;
   hash_table->ref_count          = 1;
-#ifndef G_DISABLE_ASSERT
-  hash_table->version            = 0;
-#endif
   hash_table->key_destroy_func   = key_destroy_func;
   hash_table->value_destroy_func = value_destroy_func;
-  hash_table->nodes              = g_new0 (GHashNode, hash_table->size);
+  hash_table->nodes              = g_new0 (GHashNode*, hash_table->size);
 
   return hash_table;
 }
 
-/**
- * g_hash_table_iter_init:
- * @iter: an uninitialized #GHashTableIter.
- * @hash_table: a #GHashTable.
- *
- * Initializes a key/value pair iterator and associates it with
- * @hash_table. Modifying the hash table after calling this function
- * invalidates the returned iterator.
- * |[
- * GHashTableIter iter;
- * gpointer key, value;
- *
- * g_hash_table_iter_init (&iter, hash_table);
- * while (g_hash_table_iter_next (&iter, &key, &value)) 
- *   {
- *     /&ast; do something with key and value &ast;/
- *   }
- * ]|
- *
- * Since: 2.16
- **/
-void
-g_hash_table_iter_init (GHashTableIter *iter,
-			GHashTable     *hash_table)
-{
-  RealIter *ri = (RealIter *) iter;
-
-  g_return_if_fail (iter != NULL);
-  g_return_if_fail (hash_table != NULL);
-
-  ri->hash_table = hash_table;
-  ri->position = -1;
-#ifndef G_DISABLE_ASSERT
-  ri->version = hash_table->version;
-#endif
-}
-
-/**
- * g_hash_table_iter_next:
- * @iter: an initialized #GHashTableIter.
- * @key: a location to store the key, or %NULL.
- * @value: a location to store the value, or %NULL.
- *
- * Advances @iter and retrieves the key and/or value that are now
- * pointed to as a result of this advancement. If %FALSE is returned,
- * @key and @value are not set, and the iterator becomes invalid.
- *
- * Return value: %FALSE if the end of the #GHashTable has been reached.
- *
- * Since: 2.16
- **/
-gboolean
-g_hash_table_iter_next (GHashTableIter *iter,
-			gpointer       *key,
-			gpointer       *value)
-{
-  RealIter *ri = (RealIter *) iter;
-  GHashNode *node;
-  gint position;
-
-  g_return_val_if_fail (iter != NULL, FALSE);
-#ifndef G_DISABLE_ASSERT
-  g_return_val_if_fail (ri->version == ri->hash_table->version, FALSE);
-#endif
-  g_return_val_if_fail (ri->position < ri->hash_table->size, FALSE);
-
-  position = ri->position;
-
-  do
-    {
-      position++;
-      if (position >= ri->hash_table->size)
-        {
-          ri->position = position;
-          return FALSE;
-        }
-
-      node = &ri->hash_table->nodes [position];
-    }
-  while (node->key_hash <= 1);
-
-  if (key != NULL)
-    *key = node->key;
-  if (value != NULL)
-    *value = node->value;
-
-  ri->position = position;
-  return TRUE;
-}
-
-/**
- * g_hash_table_iter_get_hash_table:
- * @iter: an initialized #GHashTableIter.
- *
- * Returns the #GHashTable associated with @iter.
- *
- * Return value: the #GHashTable associated with @iter.
- *
- * Since: 2.16
- **/
-GHashTable *
-g_hash_table_iter_get_hash_table (GHashTableIter *iter)
-{
-  g_return_val_if_fail (iter != NULL, NULL);
-
-  return ((RealIter *) iter)->hash_table;
-}
-
-static void
-iter_remove_or_steal (RealIter *ri, gboolean notify)
-{
-  g_return_if_fail (ri != NULL);
-#ifndef G_DISABLE_ASSERT
-  g_return_if_fail (ri->version == ri->hash_table->version);
-#endif
-  g_return_if_fail (ri->position >= 0);
-  g_return_if_fail (ri->position < ri->hash_table->size);
-
-  g_hash_table_remove_node (ri->hash_table, &ri->hash_table->nodes [ri->position], notify);
-
-#ifndef G_DISABLE_ASSERT
-  ri->version++;
-  ri->hash_table->version++;
-#endif
-}
-
-/**
- * g_hash_table_iter_remove():
- * @iter: an initialized #GHashTableIter.
- *
- * Removes the key/value pair currently pointed to by the iterator
- * from its associated #GHashTable. Can only be called after
- * g_hash_table_iter_next() returned %TRUE, and cannot be called more
- * than once for the same key/value pair.
- *
- * If the #GHashTable was created using g_hash_table_new_full(), the
- * key and value are freed using the supplied destroy functions, otherwise
- * you have to make sure that any dynamically allocated values are freed 
- * yourself.
- *
- * Since: 2.16
- **/
-void
-g_hash_table_iter_remove (GHashTableIter *iter)
-{
-  iter_remove_or_steal ((RealIter *) iter, TRUE);
-}
-
-/**
- * g_hash_table_iter_steal():
- * @iter: an initialized #GHashTableIter.
- *
- * Removes the key/value pair currently pointed to by the iterator
- * from its associated #GHashTable, without calling the key and value
- * destroy functions. Can only be called after
- * g_hash_table_iter_next() returned %TRUE, and cannot be called more
- * than once for the same key/value pair.
- *
- * Since: 2.16
- **/
-void
-g_hash_table_iter_steal (GHashTableIter *iter)
-{
-  iter_remove_or_steal ((RealIter *) iter, FALSE);
-}
-
 
 /**
  * g_hash_table_ref:
@@ -733,7 +234,12 @@
 
   if (g_atomic_int_exchange_and_add (&hash_table->ref_count, -1) - 1 == 0)
     {
-      g_hash_table_remove_all_nodes (hash_table, TRUE);
+      gint i;
+
+      for (i = 0; i < hash_table->size; i++)
+        g_hash_nodes_destroy (hash_table->nodes[i],
+                              hash_table->key_destroy_func,
+                              hash_table->value_destroy_func);
       g_free (hash_table->nodes);
       g_slice_free (GHashTable, hash_table);
     }
@@ -760,6 +266,30 @@
   g_hash_table_unref (hash_table);
 }
 
+static inline GHashNode**
+g_hash_table_lookup_p_node (GHashTable  *hash_table,
+                          gconstpointer  key)
+{
+  GHashNode **node;
+
+  node = &hash_table->nodes
+    [(* hash_table->hash_func) (key) % hash_table->size];
+
+  /* Hash table lookup needs to be fast.
+   *  We therefore remove the extra conditional of testing
+   *  whether to call the key_equal_func or not from
+   *  the inner loop.
+   */
+  if (hash_table->key_equal_func)
+    while (*node && !(*hash_table->key_equal_func) ((*node)->key, key))
+      node = &(*node)->next;
+  else
+    while (*node && (*node)->key != key)
+      node = &(*node)->next;
+
+  return node;
+}
+
 /**
  * g_hash_table_lookup:
  * @hash_table: a #GHashTable.
@@ -777,31 +307,26 @@
                      gconstpointer key)
 {
   GHashNode *node;
-  guint      node_index;
 
   g_return_val_if_fail (hash_table != NULL, NULL);
 
-  node_index = g_hash_table_lookup_node (hash_table, key);
-  node = &hash_table->nodes [node_index];
+  node = *g_hash_table_lookup_p_node (hash_table, key);
 
-  return node->key_hash ? node->value : NULL;
+  return node ? node->value : NULL;
 }
 
 /**
  * g_hash_table_lookup_extended:
  * @hash_table: a #GHashTable
  * @lookup_key: the key to look up
- * @orig_key: return location for the original key, or %NULL
- * @value: return location for the value associated with the key, or %NULL
+ * @orig_key: returns the original key
+ * @value: returns the value associated with the key
  *
  * Looks up a key in the #GHashTable, returning the original key and the
  * associated value and a #gboolean which is %TRUE if the key was found. This
  * is useful if you need to free the memory allocated for the original key,
  * for example before calling g_hash_table_remove().
  *
- * You can actually pass %NULL for @lookup_key to test
- * whether the %NULL key exists.
- *
  * Return value: %TRUE if the key was found in the #GHashTable.
  **/
 gboolean
@@ -811,100 +336,22 @@
                               gpointer      *value)
 {
   GHashNode *node;
-  guint      node_index;
 
   g_return_val_if_fail (hash_table != NULL, FALSE);
 
-  node_index = g_hash_table_lookup_node (hash_table, lookup_key);
-  node = &hash_table->nodes [node_index];
+  node = *g_hash_table_lookup_p_node (hash_table, lookup_key);
 
-  if (!node->key_hash)
+  if (node)
+  {
+      if (orig_key)
+        *orig_key = node->key;
+      if (value)
+        *value = node->value;
+  } else
     return FALSE;
-
-  if (orig_key)
-    *orig_key = node->key;
-
-  if (value)
-    *value = node->value;
-
   return TRUE;
 }
 
-/*
- * g_hash_table_insert_internal:
- * @hash_table: our #GHashTable
- * @key: the key to insert
- * @value: the value to insert
- * @keep_new_key: if %TRUE and this key already exists in the table
- *   then call the destroy notify function on the old key.  If %FALSE
- *   then call the destroy notify function on the new key.
- *
- * Implements the common logic for the g_hash_table_insert() and
- * g_hash_table_replace() functions.
- *
- * Do a lookup of @key.  If it is found, replace it with the new
- * @value (and perhaps the new @key).  If it is not found, create a
- * new node.
- */
-static void
-g_hash_table_insert_internal (GHashTable *hash_table,
-                              gpointer    key,
-                              gpointer    value,
-                              gboolean    keep_new_key)
-{
-  GHashNode *node;
-  guint node_index;
-  guint key_hash;
-  guint old_hash;
-
-  g_return_if_fail (hash_table != NULL);
-  g_return_if_fail (hash_table->ref_count > 0);
-
-  node_index = g_hash_table_lookup_node_for_insertion (hash_table, key, &key_hash);
-  node = &hash_table->nodes [node_index];
-
-  old_hash = node->key_hash;
-
-  if (old_hash > 1)
-    {
-      if (keep_new_key)
-        {
-          if (hash_table->key_destroy_func)
-            hash_table->key_destroy_func (node->key);
-          node->key = key;
-        }
-      else
-        {
-          if (hash_table->key_destroy_func)
-            hash_table->key_destroy_func (key);
-        }
-
-      if (hash_table->value_destroy_func)
-        hash_table->value_destroy_func (node->value);
-
-      node->value = value;
-    }
-  else
-    {
-      node->key = key;
-      node->value = value;
-      node->key_hash = key_hash;
-
-      hash_table->nnodes++;
-
-      if (old_hash == 0)
-        {
-          /* We replaced an empty node, and not a tombstone */
-          hash_table->noccupied++;
-          g_hash_table_maybe_resize (hash_table);
-        }
-
-#ifndef G_DISABLE_ASSERT
-      hash_table->version++;
-#endif
-    }
-}
-
 /**
  * g_hash_table_insert:
  * @hash_table: a #GHashTable.
@@ -924,7 +371,35 @@
                      gpointer    key,
                      gpointer    value)
 {
-  g_hash_table_insert_internal (hash_table, key, value, FALSE);
+  GHashNode **node;
+
+  g_return_if_fail (hash_table != NULL);
+  g_return_if_fail (hash_table->ref_count > 0);
+
+  node = g_hash_table_lookup_p_node (hash_table, key);
+
+  if (*node)
+    {
+      /* do not reset node->key in this place, keeping
+       * the old key is the intended behaviour.
+       * g_hash_table_replace() can be used instead.
+       */
+
+      /* free the passed key */
+      if (hash_table->key_destroy_func)
+        hash_table->key_destroy_func (key);
+
+      if (hash_table->value_destroy_func)
+        hash_table->value_destroy_func ((*node)->value);
+
+      (*node)->value = value;
+    }
+  else
+    {
+      *node = g_hash_node_new (key, value);
+      hash_table->nnodes++;
+      G_HASH_TABLE_RESIZE (hash_table);
+    }
 }
 
 /**
@@ -945,47 +420,25 @@
                       gpointer    key,
                       gpointer    value)
 {
-  g_hash_table_insert_internal (hash_table, key, value, TRUE);
-}
-
-/*
- * g_hash_table_remove_internal:
- * @hash_table: our #GHashTable
- * @key: the key to remove
- * @notify: %TRUE if the destroy notify handlers are to be called
- * Return value: %TRUE if a node was found and removed, else %FALSE
- *
- * Implements the common logic for the g_hash_table_remove() and
- * g_hash_table_steal() functions.
- *
- * Do a lookup of @key and remove it if it is found, calling the
- * destroy notify handlers only if @notify is %TRUE.
- */
-static gboolean
-g_hash_table_remove_internal (GHashTable    *hash_table,
-                              gconstpointer  key,
-                              gboolean       notify)
-{
-  GHashNode *node;
-  guint node_index;
-
-  g_return_val_if_fail (hash_table != NULL, FALSE);
-
-  node_index = g_hash_table_lookup_node (hash_table, key);
-  node = &hash_table->nodes [node_index];
-
-  /* g_hash_table_lookup_node() never returns a tombstone, so this is safe */
-  if (!node->key_hash)
-    return FALSE;
-
-  g_hash_table_remove_node (hash_table, node, notify);
-  g_hash_table_maybe_resize (hash_table);
-
-#ifndef G_DISABLE_ASSERT
-  hash_table->version++;
-#endif
-
-  return TRUE;
+  GHashNode **node;
+  g_return_if_fail (hash_table != NULL);
+  g_return_if_fail (hash_table->ref_count > 0);
+  node = g_hash_table_lookup_p_node (hash_table, key);
+  if (*node)
+    {
+      if (hash_table->key_destroy_func)
+        hash_table->key_destroy_func ((*node)->key);
+      if (hash_table->value_destroy_func)
+        hash_table->value_destroy_func ((*node)->value);
+      (*node)->key   = key;
+      (*node)->value = value;
+    }
+  else
+    {
+      *node = g_hash_node_new (key, value);
+      hash_table->nnodes++;
+      G_HASH_TABLE_RESIZE (hash_table);
+    }
 }
 
 /**
@@ -1006,7 +459,26 @@
 g_hash_table_remove (GHashTable    *hash_table,
                      gconstpointer  key)
 {
-  return g_hash_table_remove_internal (hash_table, key, TRUE);
+  GHashNode **node, *dest;
+
+  g_return_val_if_fail (hash_table != NULL, FALSE);
+
+  node = g_hash_table_lookup_p_node (hash_table, key);
+  if (*node)
+    {
+      dest = *node;
+      (*node) = dest->next;
+      g_hash_node_destroy (dest,
+                           hash_table->key_destroy_func,
+                           hash_table->value_destroy_func);
+      hash_table->nnodes--;
+
+      G_HASH_TABLE_RESIZE (hash_table);
+
+      return TRUE;
+    }
+
+  return FALSE;
 }
 
 /**
@@ -1023,7 +495,24 @@
 g_hash_table_steal (GHashTable    *hash_table,
                     gconstpointer  key)
 {
-  return g_hash_table_remove_internal (hash_table, key, FALSE);
+  GHashNode **node, *dest;
+
+  g_return_val_if_fail (hash_table != NULL, FALSE);
+
+  node = g_hash_table_lookup_p_node (hash_table, key);
+  if (*node)
+    {
+      dest = *node;
+      (*node) = dest->next;
+      g_hash_node_destroy (dest, NULL, NULL);
+      hash_table->nnodes--;
+
+      G_HASH_TABLE_RESIZE (hash_table);
+
+      return TRUE;
+    }
+
+  return FALSE;
 }
 
 /**
@@ -1042,15 +531,20 @@
 void
 g_hash_table_remove_all (GHashTable *hash_table)
 {
+  guint i;
+
   g_return_if_fail (hash_table != NULL);
 
-#ifndef G_DISABLE_ASSERT
-  if (hash_table->nnodes != 0)
-    hash_table->version++;
-#endif
+  for (i = 0; i < hash_table->size; i++)
+    {
+      g_hash_nodes_destroy (hash_table->nodes[i],
+                            hash_table->key_destroy_func,
+                            hash_table->value_destroy_func);
+      hash_table->nodes[i] = NULL;
+    }
+  hash_table->nnodes = 0;
 
-  g_hash_table_remove_all_nodes (hash_table, TRUE);
-  g_hash_table_maybe_resize (hash_table);
+  G_HASH_TABLE_RESIZE (hash_table);
 }
 
 /**
@@ -1065,15 +559,19 @@
 void
 g_hash_table_steal_all (GHashTable *hash_table)
 {
+  guint i;
+
   g_return_if_fail (hash_table != NULL);
 
-#ifndef G_DISABLE_ASSERT
-  if (hash_table->nnodes != 0)
-    hash_table->version++;
-#endif
+  for (i = 0; i < hash_table->size; i++)
+    {
+      g_hash_nodes_destroy (hash_table->nodes[i], NULL, NULL);
+      hash_table->nodes[i] = NULL;
+    }
+
+  hash_table->nnodes = 0;
 
-  g_hash_table_remove_all_nodes (hash_table, FALSE);
-  g_hash_table_maybe_resize (hash_table);
+  G_HASH_TABLE_RESIZE (hash_table);
 }
 
 /*
@@ -1099,26 +597,45 @@
                                       gpointer    user_data,
                                       gboolean    notify)
 {
-  guint deleted = 0;
+  GHashNode *node, *prev;
   gint i;
+  guint deleted = 0;
 
   for (i = 0; i < hash_table->size; i++)
     {
-      GHashNode *node = &hash_table->nodes [i];
+    restart:
 
-      if (node->key_hash > 1 && (* func) (node->key, node->value, user_data))
+      prev = NULL;
+
+      for (node = hash_table->nodes[i]; node; prev = node, node = node->next)
         {
-          g_hash_table_remove_node (hash_table, node, notify);
-          deleted++;
+          if ((* func) (node->key, node->value, user_data))
+            {
+              deleted += 1;
+
+              hash_table->nnodes -= 1;
+
+              if (prev)
+                {
+                  prev->next = node->next;
+                  g_hash_node_destroy (node,
+                                       notify ? hash_table->key_destroy_func : NULL,
+                                       notify ? hash_table->value_destroy_func : NULL);
+                  node = prev;
+                }
+              else
+                {
+                  hash_table->nodes[i] = node->next;
+                  g_hash_node_destroy (node,
+                                       notify ? hash_table->key_destroy_func : NULL,
+                                       notify ? hash_table->value_destroy_func : NULL);
+                  goto restart;
+                }
+            }
         }
     }
 
-  g_hash_table_maybe_resize (hash_table);
-
-#ifndef G_DISABLE_ASSERT
-  if (deleted > 0)
-    hash_table->version++;
-#endif
+  G_HASH_TABLE_RESIZE (hash_table);
 
   return deleted;
 }
@@ -1144,29 +661,49 @@
                                       gpointer    user_data,
                                       gint        num_entries)
 {
-  guint deleted = 0;
+  GHashNode *node, *prev;
   gint i;
+  guint deleted = 0;
 
   for (i = 0; i < hash_table->size; i++)
     {
-      if (deleted >= num_entries)
-        break;
-      
-      GHashNode *node = &hash_table->nodes [i];
+    restart:
+
+      prev = NULL;
 
-      if (node->key_hash > 1 && (* func) (node->key, node->value, user_data))
+      for (node = hash_table->nodes[i]; node; prev = node, node = node->next)
         {
-          g_hash_table_remove_node (hash_table, node, TRUE);
-          deleted++;
+
+          if (deleted >= num_entries)
+            goto done;
+          if ((* func) (node->key, node->value, user_data))
+            {
+              deleted += 1;
+
+              hash_table->nnodes -= 1;
+
+              if (prev)
+                {
+                  prev->next = node->next;
+                  g_hash_node_destroy (node,
+                                       hash_table->key_destroy_func,
+                                       hash_table->value_destroy_func);
+                  node = prev;
+                }
+              else
+                {
+                  hash_table->nodes[i] = node->next;
+                  g_hash_node_destroy (node,
+                                       hash_table->key_destroy_func,
+                                       hash_table->value_destroy_func);
+                  goto restart;
+                }
+            }
         }
     }
 
-  g_hash_table_maybe_resize (hash_table);
-
-#ifndef G_DISABLE_ASSERT
-  if (deleted > 0)
-    hash_table->version++;
-#endif
+done:
+  G_HASH_TABLE_RESIZE (hash_table);
 
   return deleted;
 }
@@ -1183,9 +720,6 @@
  * the #GHashTable, they are used to free the memory allocated for the removed
  * keys and values.
  *
- * See #GHashTableIter for an alternative way to loop over the 
- * key/value pairs in the hash table.
- *
  * Return value: the number of key/value pairs removed.
  **/
 guint
@@ -1209,9 +743,6 @@
  * If the function returns %TRUE, then the key/value pair is removed from the
  * #GHashTable, but no key or value destroy functions are called.
  *
- * See #GHashTableIter for an alternative way to loop over the 
- * key/value pairs in the hash table.
- *
  * Return value: the number of key/value pairs removed.
  **/
 guint
@@ -1237,27 +768,21 @@
  * be modified while iterating over it (you can't add/remove
  * items). To remove all items matching a predicate, use
  * g_hash_table_foreach_remove().
- *
- * See g_hash_table_find() for performance caveats for linear
- * order searches in contrast to g_hash_table_lookup().
  **/
 void
 g_hash_table_foreach (GHashTable *hash_table,
                       GHFunc      func,
                       gpointer    user_data)
 {
+  GHashNode *node;
   gint i;
 
   g_return_if_fail (hash_table != NULL);
   g_return_if_fail (func != NULL);
 
   for (i = 0; i < hash_table->size; i++)
-    {
-      GHashNode *node = &hash_table->nodes [i];
-
-      if (node->key_hash > 1)
-        (* func) (node->key, node->value, user_data);
-    }
+    for (node = hash_table->nodes[i]; node; node = node->next)
+      (* func) (node->key, node->value, user_data);
 }
 
 /**
@@ -1271,15 +796,6 @@
  * each pair, and the given @user_data parameter. The hash table may not
  * be modified while iterating over it (you can't add/remove items).
  *
- * Note, that hash tables are really only optimized for forward lookups,
- * i.e. g_hash_table_lookup().
- * So code that frequently issues g_hash_table_find() or
- * g_hash_table_foreach() (e.g. in the order of once per every entry in a
- * hash table) should probably be reworked to use additional or different
- * data structures for reverse lookups (keep in mind that an O(n) find/foreach
- * operation issued for all n values in a hash table ends up needing O(n*n)
- * operations).
- *
  * Return value: The value of the first key/value pair is returned, for which
  * func evaluates to %TRUE. If no pair with the requested property is found,
  * %NULL is returned.
@@ -1291,22 +807,60 @@
                    GHRFunc          predicate,
                    gpointer         user_data)
 {
+  GHashNode *node;
   gint i;
 
   g_return_val_if_fail (hash_table != NULL, NULL);
   g_return_val_if_fail (predicate != NULL, NULL);
 
   for (i = 0; i < hash_table->size; i++)
-    {
-      GHashNode *node = &hash_table->nodes [i];
-
-      if (node->key_hash > 1 && predicate (node->key, node->value, user_data))
+    for (node = hash_table->nodes[i]; node; node = node->next)
+      if (predicate (node->key, node->value, user_data))
         return node->value;
-    }
-
   return NULL;
 }
 
+static GHashNode*
+g_hash_node_new (gpointer key,
+                 gpointer value)
+{
+  GHashNode *hash_node = g_slice_new (GHashNode);
+
+  hash_node->key = key;
+  hash_node->value = value;
+  hash_node->next = NULL;
+  return hash_node;
+}
+
+static void
+g_hash_node_destroy (GHashNode      *hash_node,
+                     GDestroyNotify  key_destroy_func,
+                     GDestroyNotify  value_destroy_func)
+{
+  if (key_destroy_func)
+    key_destroy_func (hash_node->key);
+  if (value_destroy_func)
+    value_destroy_func (hash_node->value);
+  g_slice_free (GHashNode, hash_node);
+}
+
+static void
+g_hash_nodes_destroy (GHashNode *hash_node,
+                      GFreeFunc  key_destroy_func,
+                      GFreeFunc  value_destroy_func)
+{
+  while (hash_node)
+    {
+      GHashNode *next = hash_node->next;
+      if (key_destroy_func)
+        key_destroy_func (hash_node->key);
+      if (value_destroy_func)
+        value_destroy_func (hash_node->value);
+      g_slice_free (GHashNode, hash_node);
+      hash_node = next;
+    }
+}
+
 /**
  * g_hash_table_size:
  * @hash_table: a #GHashTable.
@@ -1323,73 +877,6 @@
   return hash_table->nnodes;
 }
 
-/**
- * g_hash_table_get_keys:
- * @hash_table: a #GHashTable
- *
- * Retrieves every key inside @hash_table. The returned data is valid
- * until @hash_table is modified.
- *
- * Return value: a #GList containing all the keys inside the hash
- *   table. The content of the list is owned by the hash table and
- *   should not be modified or freed. Use g_list_free() when done
- *   using the list.
- *
- * Since: 2.14
- */
-GList *
-g_hash_table_get_keys (GHashTable *hash_table)
-{
-  gint i;
-  GList *retval;
-
-  g_return_val_if_fail (hash_table != NULL, NULL);
-
-  retval = NULL;
-  for (i = 0; i < hash_table->size; i++)
-    {
-      GHashNode *node = &hash_table->nodes [i];
-
-      if (node->key_hash > 1)
-        retval = g_list_prepend (retval, node->key);
-    }
-
-  return retval;
-}
-
-/**
- * g_hash_table_get_values:
- * @hash_table: a #GHashTable
- *
- * Retrieves every value inside @hash_table. The returned data is
- * valid until @hash_table is modified.
- *
- * Return value: a #GList containing all the values inside the hash
- *   table. The content of the list is owned by the hash table and
- *   should not be modified or freed. Use g_list_free() when done
- *   using the list.
- *
- * Since: 2.14
- */
-GList *
-g_hash_table_get_values (GHashTable *hash_table)
-{
-  gint i;
-  GList *retval;
-
-  g_return_val_if_fail (hash_table != NULL, NULL);
-
-  retval = NULL;
-  for (i = 0; i < hash_table->size; i++)
-    {
-      GHashNode *node = &hash_table->nodes [i];
-
-      if (node->key_hash > 1)
-        retval = g_list_prepend (retval, node->value);
-    }
-
-  return retval;
-}
 
 #define __G_HASH_C__
 #include "galiasdef.c"
diff -uNr glib-2.22.5/glib/ghash.h glib-2.22.5.new/glib/ghash.h
--- glib-2.22.5/glib/ghash.h	2015-03-25 13:59:19.000000000 -0700
+++ glib-2.22.5.new/glib/ghash.h	2015-03-26 12:47:33.000000000 -0700
@@ -24,15 +24,10 @@
  * GLib at ftp://ftp.gtk.org/pub/gtk/.
  */
 
-#if defined(G_DISABLE_SINGLE_INCLUDES) && !defined (__GLIB_H_INSIDE__) && !defined (GLIB_COMPILATION)
-#error "Only <glib.h> can be included directly."
-#endif
-
 #ifndef __G_HASH_H__
 #define __G_HASH_H__
 
 #include <glib/gtypes.h>
-#include <glib/glist.h>
 
 G_BEGIN_DECLS
 
@@ -42,19 +37,6 @@
                                gpointer  value,
                                gpointer  user_data);
 
-typedef struct _GHashTableIter GHashTableIter;
-
-struct _GHashTableIter
-{
-  /*< private >*/
-  gpointer	dummy1;
-  gpointer	dummy2;
-  gpointer	dummy3;
-  int		dummy4;
-  gboolean	dummy5;
-  gpointer	dummy6;
-};
-
 /* Hash tables
  */
 GHashTable* g_hash_table_new		   (GHashFunc	    hash_func,
@@ -99,17 +81,6 @@
 					    GHRFunc	    func,
 					    gpointer	    user_data);
 guint	    g_hash_table_size		   (GHashTable	   *hash_table);
-GList *     g_hash_table_get_keys          (GHashTable     *hash_table);
-GList *     g_hash_table_get_values        (GHashTable     *hash_table);
-
-void        g_hash_table_iter_init         (GHashTableIter *iter,
-					    GHashTable     *hash_table);
-gboolean    g_hash_table_iter_next         (GHashTableIter *iter,
-					    gpointer       *key,
-					    gpointer       *value);
-GHashTable* g_hash_table_iter_get_hash_table (GHashTableIter *iter);
-void        g_hash_table_iter_remove       (GHashTableIter *iter);
-void        g_hash_table_iter_steal        (GHashTableIter *iter);
 
 /* keeping hash tables alive */
 GHashTable* g_hash_table_ref   		   (GHashTable 	   *hash_table);
diff -uNr glib-2.22.5/glib/glib.symbols glib-2.22.5.new/glib/glib.symbols
--- glib-2.22.5/glib/glib.symbols	2015-03-25 13:59:19.000000000 -0700
+++ glib-2.22.5.new/glib/glib.symbols	2015-03-26 12:47:33.000000000 -0700
@@ -399,8 +399,6 @@
 g_hash_table_foreach_remove
 g_hash_table_foreach_remove_n
 g_hash_table_foreach_steal
-g_hash_table_get_keys
-g_hash_table_get_values
 g_hash_table_insert
 g_hash_table_lookup
 g_hash_table_lookup_extended
@@ -412,11 +410,6 @@
 g_hash_table_size
 g_hash_table_steal
 g_hash_table_steal_all
-g_hash_table_iter_init
-g_hash_table_iter_next
-g_hash_table_iter_get_hash_table
-g_hash_table_iter_remove
-g_hash_table_iter_steal
 #endif
 #endif
 
diff -uNr glib-2.22.5/tests/hash-test.c glib-2.22.5.new/tests/hash-test.c
--- glib-2.22.5/tests/hash-test.c	2009-03-31 16:04:20.000000000 -0700
+++ glib-2.22.5.new/tests/hash-test.c	2015-03-26 12:47:33.000000000 -0700
@@ -44,50 +44,7 @@
 
 int array[10000];
 
-static void
-fill_hash_table_and_array (GHashTable *hash_table)
-{
-  int i;
-
-  for (i = 0; i < 10000; i++)
-    {
-      array[i] = i;
-      g_hash_table_insert (hash_table, &array[i], &array[i]);
-    }
-}
-
-static void
-init_result_array (int result_array[10000])
-{
-  int i;
 
-  for (i = 0; i < 10000; i++)
-    result_array[i] = -1;
-}
-
-static void
-verify_result_array (int array[10000])
-{
-  int i;
-
-  for (i = 0; i < 10000; i++)
-    g_assert (array[i] == i);
-}
-
-static void
-handle_pair (gpointer key, gpointer value, int result_array[10000])
-{
-  int n;
-
-  g_assert (key == value);
-
-  n = *((int *) value);
-
-  g_assert (n >= 0 && n < 10000);
-  g_assert (result_array[n] == -1);
-
-  result_array[n] = n;
-}
 
 static gboolean
 my_hash_callback_remove (gpointer key,
@@ -118,7 +75,8 @@
 		  gpointer value,
 		  gpointer user_data)
 {
-  handle_pair (key, value, user_data);
+  int *d = value;
+  *d = 1;
 }
 
 static guint
@@ -274,9 +232,8 @@
 
      crcinit ();
 
-     h = g_hash_table_new_full (simple_hash ? one_hash : honeyman_hash,
-     			        second_hash_cmp,
-                                g_free, g_free);
+     h = g_hash_table_new (simple_hash ? one_hash : honeyman_hash,
+     			   second_hash_cmp);
      g_assert (h != NULL);
      for (i=0; i<20; i++)
           {
@@ -305,13 +262,14 @@
 
      sprintf (key, "%d", 3);
      g_hash_table_remove (h, key);
-     g_assert (g_hash_table_size (h) == 19);
      g_hash_table_foreach_remove (h, remove_even_foreach, NULL);
-     g_assert (g_hash_table_size (h) == 9);
      g_hash_table_foreach (h, not_even_foreach, NULL);
 
      for (i=0; i<20; i++)
           {
+	  if ((i % 2) == 0 || i == 3)
+  	      continue;
+
           sprintf (key, "%d", i);
 	  g_assert (atoi(key) == i);
 
@@ -322,19 +280,17 @@
           found = g_hash_table_lookup_extended (h, key,
 	  					(gpointer)&orig_key,
 						(gpointer)&orig_val);
-	  if ((i % 2) == 0 || i == 3)
-            {
-              g_assert (!found);
-  	      continue;
-            }
-
 	  g_assert (found);
 
+	  g_hash_table_remove (h, key);
+
 	  g_assert (orig_key != NULL);
 	  g_assert (strcmp (key, orig_key) == 0);
+	  g_free (orig_key);
 
 	  g_assert (orig_val != NULL);
 	  g_assert (strcmp (val, orig_val) == 0);
+	  g_free (orig_val);
           }
 
     g_hash_table_destroy (h);
@@ -386,60 +342,32 @@
   GHashTable *hash_table;
   gint i;
   gint value = 120;
-  gint *pvalue;
-  GList *keys, *values;
-  gint keys_len, values_len;
-  GHashTableIter iter;
-  gpointer ikey, ivalue;
-  int result_array[10000];
+  gint *pvalue; 
   
   hash_table = g_hash_table_new (my_hash, my_hash_equal);
-  fill_hash_table_and_array (hash_table);
+  for (i = 0; i < 10000; i++)
+    {
+      array[i] = i;
+      g_hash_table_insert (hash_table, &array[i], &array[i]);
+    }
   pvalue = g_hash_table_find (hash_table, find_first, &value);
   if (!pvalue || *pvalue != value)
     g_assert_not_reached();
+  
+  g_hash_table_foreach (hash_table, my_hash_callback, NULL);
 
-  keys = g_hash_table_get_keys (hash_table);
-  if (!keys)
-    g_assert_not_reached ();
-
-  values = g_hash_table_get_values (hash_table);
-  if (!values)
-    g_assert_not_reached ();
-
-  keys_len = g_list_length (keys);
-  values_len = g_list_length (values);
-  if (values_len != keys_len &&  keys_len != g_hash_table_size (hash_table))
-    g_assert_not_reached ();
-
-  g_list_free (keys);
-  g_list_free (values);
-
-  init_result_array (result_array);
-  g_hash_table_iter_init (&iter, hash_table);
   for (i = 0; i < 10000; i++)
-    {
-      g_assert (g_hash_table_iter_next (&iter, &ikey, &ivalue));
-
-      handle_pair (ikey, ivalue, result_array);
-
-      if (i % 2)
-	g_hash_table_iter_remove (&iter);
-    }
-  g_assert (! g_hash_table_iter_next (&iter, &ikey, &ivalue));
-  g_assert (g_hash_table_size (hash_table) == 5000);
-  verify_result_array (result_array);
-
-  fill_hash_table_and_array (hash_table);
-
-  init_result_array (result_array);
-  g_hash_table_foreach (hash_table, my_hash_callback, result_array);
-  verify_result_array (result_array);
+    if (array[i] == 0)
+      g_assert_not_reached();
 
   for (i = 0; i < 10000; i++)
     g_hash_table_remove (hash_table, &array[i]);
 
-  fill_hash_table_and_array (hash_table);
+  for (i = 0; i < 10000; i++)
+    {
+      array[i] = i;
+      g_hash_table_insert (hash_table, &array[i], &array[i]);
+    }
 
   if (g_hash_table_foreach_remove (hash_table, my_hash_callback_remove, NULL) != 5000 ||
       g_hash_table_size (hash_table) != 5000)
