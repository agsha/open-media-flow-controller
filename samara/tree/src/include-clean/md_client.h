/*
 *
 * md_client.h
 *
 *
 *
 */

#ifndef __MD_CLIENT_H_
#define __MD_CLIENT_H_


#ifdef __cplusplus
extern "C" {
#endif
#if 0 /* for emacs */
}
#endif

/* XXX/EMT: move non-request-sending utilities into another header? */

/**
 * \file md_client.h Utilities for management daemon clients.
 * \ingroup gcl
 *
 * This API provides a synchronous interface to communication with
 * mgmtd.  It provides helper functions for constructing mgmtd request
 * messages, and extracting information out of the responses.
 *
 * This API does not take care of establishing a GCL connection with
 * mgmtd, or sending request messages or receiving replies.  It
 * expects the connection to be already set up when it is initialized,
 * and uses a callback provided by the caller to send messages and
 * receive replies.  You can handle these things yourself, or you can
 * use the API in mdc_wrapper.h, which does these things for you.  If
 * you are going to use mdc_wrapper.h, do not initialize this API with
 * mdc_init(), as that will be done for you.
 *
 * By a "synchronous interface" we mean that the calls into this API
 * for sending requests to mgmtd do not return until the response is
 * received.  Note that although synchronous, it may not necessarily
 * be completely blocking.  While the caller awaiting the reply is
 * blocked, the management message handler may reenter the event loop
 * and dispatch other events that occur while waiting for the reply.
 * The management message handler provided for you by the
 * mdc_wrapper.h API works this way.
 *
 * For an examle of a basic mgmtd client that uses this API in
 * conjunction with mdc_wrapper.h, see the test program in
 * test/lib/libgcl/mdc_wrapper.  For an example of a client that
 * uses this API directly without mdc_wrapper.h (not recommended),
 * see test/lib/libgcl/md_client. 
 *
 * CAUTION: if you call mdc_init() directly rather than using the
 * mdc_wrapper.h API, be careful with your management message handler
 * and multiple outstanding requests.  A lot of the earlier examples
 * of these handlers did not handle multiple outstanding requests
 * correctly.
 */

/*
 * XXX/EMT: the order of the parameters in this file should be
 * revisited for consistency.  In some cases, the binding name was put
 * at the end so we could later add printf-style varargs to construct
 * the name, but then the db_name was added after it so this is no
 * longer possible.  Should fix all of these, but cannot change 
 * existing APIs unless we have a trustworthy way of automatically
 * reordering parameters in existing calls.
 */

#include "common.h"
#include "bnode.h"
#include "bnode_proto.h"
#include "tree.h"

/* ========================================================================= */
/* Typedefs and Constants
 * =========================================================================
 */

/* ------------------------------------------------------------------------- */
/** The total time in seconds that mgmtd will wait for a response to a
 * monitoring query it has made to an external provider before giving
 * up.  There are three possible timeouts; one is chosen depending on
 * the circumstances:
 *   - md_waitfor_timeout is used for queries made synchronously. 
 *     (In fact, these are not done at all anymore by default...)
 *   - md_waitfor_timeout_async is used for queries made asynchronously,
 *     i.e. where mgmtd is not itself blocked on the response.
 *   - md_waitfor_timeout_apply is used for queries made while mgmtd is
 *     in the middle of doing a commit (i.e. processing a set request,
 *     doing the initial commit, or a db switch).
 */
enum {md_waitfor_timeout =         15,
      md_waitfor_timeout_async =   60,
      md_waitfor_timeout_commit =  15};

#define MD_PASSWD_GROUP_MAX_USERNAMES 8

/* ------------------------------------------------------------------------- */
/** A function which takes a GCL message, sends it to the management
 * daemon on the session provided, waits for a response, and then
 * returns the response.  The session used to construct the message is
 * also passed.
 */
typedef int (*mdc_msg_handler_func_ptr)(void *data, gcl_session *session,
                                        bn_request *request,
                                        bn_response **ret_response);

/* ------------------------------------------------------------------------- */
/** A function to handle an additional user response message generated
 * by the md_client library.
 *
 * Background: normally user response messages are generated by the
 * management daemon.  These messages are passed back to the md_client
 * caller in the ret_msg parameter, if the caller provided a pointer.
 * Some clients (e.g. the web UI) print these messages by looking at
 * the return value in ret_msg, while others (e.g. the CLI and Wizard)
 * print them in the management message handlers, in order to relieve
 * each caller of having to deal with the return message.  If the
 * md_client library has something of its own to say, it will both
 * (a) call the user response message handler, and
 * (b) append the message to whatever is in ret_msg, if it was 
 * passed in.  Clients of the first type probably won't want to 
 * supply a message handler at all, since they will get the message
 * through ret_msg; clients of the second type should.
 */
typedef int (*mdc_user_msg_handler_func_ptr)(void *data, const char *msg);

/* ------------------------------------------------------------------------- */
/** A function to handle a monitoring GET request for a particular
 * node name.
 *
 * NOTE: although you are passed a binding array, you are only expected
 * to return ONE binding, and its name is expected to match the name you
 * were asked for!
 *
 * \param binding_name Name of binding being requested.
 * \param binding_name_parts Name of binding, broken down into its
 * component parts (tokenized with '/' as the separator).
 * \param data The data that was provided when this callback was 
 * registered.
 * \param resp_bindings A pre-allocated binding array to which you should
 * append your answer.  Note that this array may already have other
 * bindings in it, which you should not disturb.  Create a binding,
 * then call bn_binding_array_append_takeover() to append it and 
 * transfer memory ownership to the array.
 */
typedef int (*mdc_mon_request_get_handler)(const char *binding_name,
                                          const tstr_array *binding_name_parts,
                                          void *data,
                                          bn_binding_array *resp_bindings);

/* ------------------------------------------------------------------------- */
/** A function to handle a monitoring ITERATE request for the children
 * of a particular node name.
 *
 * \param binding_name Name of binding whose children are being requested.
 * \param binding_name_parts Name of binding, broken down into its
 * component parts (tokenized with '/' as the separator).
 * \param data The data that was provided when this callback was 
 * registered.
 * \param resp_names A pre-allocated string array to which you should
 * append the names of all of your children using the API in tstring.h.
 */
typedef int (*mdc_mon_request_iterate_handler)(const char *binding_name,
                                          const tstr_array *binding_name_parts,
                                          void *data,
                                          tstr_array *resp_names);

typedef struct mdc_remote_node_reg mdc_remote_node_reg;


/* ========================================================================= */
/** GID allocation, capability groups, etc.
 */

/* ------------------------------------------------------------------------- */
/** A mapping structure to map some name (e.g.\ a group name or a capability
 * group name) to a gid.  We use this to create a typed array which will
 * be sorted (instead of using an lc_enum_string_map).
 */
typedef struct mdc_name_gid_map {
    const char *mpgm_name;
    uint32 mpgm_gid;
    const char *mpgm_usernames[MD_PASSWD_GROUP_MAX_USERNAMES + 1];
} mdc_name_gid_map;

/* ------------------------------------------------------------------------- */
/** A enum of group ids. These enums should be used both in mapping
 * user visible capability names to gids AND mapping gids to mgmtd
 * capabilities (i.e. mcf_cap_admin_caps). The former mapping is
 * below (mdc_capability_gid_map), the latter is in (md_mod_reg.h).
 *
 * NOTE: none of these numbers, including the low and high of the 
 * reserved range, can be changed without having outside impact.
 * Upgrades to our code, and possibly customer code, would be required
 * if any of this was changed.
 */
typedef enum {
    mgt_admin =      0,

/* ========================================================================= */
/* TMS reserved GIDs for use with PROD_FEATURE_CAPABILITIES
 * 
 * These are GIDs which map to a capability class.
 */
    mgt_reserved_range_low = 1000,

    mgt_radmin =  1000, /* Only used for reserved accounts */
    mgt_monitor = 1001,
    mgt_unpriv =  1002,
    mgt_cmcrendv = 1003,

    mgt_reserved_range_high = 1999,

/* ========================================================================= */
/* Customer-specific graft point 1: GIDs
 *
 * NOTE: Samara reserves the gids in the range [1000..1999] for its own
 * purposes.  Customer GIDs may be in the range [2000..2999].
 * =========================================================================
 */
#ifdef INC_MD_CLIENT_INC_GRAFT_POINT
#undef MD_CLIENT_INC_GRAFT_POINT
#define MD_CLIENT_INC_GRAFT_POINT 1
#include "../include/md_client.inc.h"
#endif /* INC_MD_CLIENT_INC_GRAFT_POINT */

/* ========================================================================= */
/* GIDs in the range [3000..9999] are reserved for other Samara
 * infrastructure use, either now or in the future.
 *
 * XXX/EMT: note that some of the numbers below are replicated in two places
 * because their corresponding groups aer likely not defined in /etc/group 
 * at the timethey are to be referenced.  Other reference points are:
 *   - src/base_os/linux_el/el5/image_files/Makefile
 *   - src/base_os/common/script_files/var_upgrade.sh (44-to-45 and 
 *     45-to-46 steps)
 *   - some other places... NOTE: when we hardcode these values, we try
 *     to at least put the enum name in a comment nearby.  So if you need
 *     to change these, don't assume the compiler will catch references...
 *     do a global search for the enum name!
 *
 * NOTE: some of these may be hardwired elsewhere out of necessity,
 * e.g. 3002 is in tpaths.h and virt_sync_pools.sh.
 */
    mgt_diag =           3000,
    mgt_stats =          3001,
    mgt_virt =           3002,

/* ========================================================================= */
/* GIDs from 10000 and upwards are assigned to non-superuser accounts when
 * PROD_FEATURE_ACLS is enabled.  For the most part there is no significance
 * to a particular GID; the only important thing is that they be unique.
 *
 * However, specific ones are chosen for use in the initial database,
 * and these must all be unique.  Samara assigns some starting from
 * 10000.  Customers should assign GIDs in the initial database in the
 * range of [20000..20999].
 */
    mgt_acl_range_low = 10000,

    mgt_acl_admin =     10000,
    mgt_acl_monitor =   10001,
    mgt_acl_cmcrendv =  10002,
    mgt_acl_cmcclient = 10003,

    mgt_LAST
} mdc_gid_type;

/* 
 * Valid capability names, but the user doesn't really need
 * to see or set these.
 */
#define MDC_RESV_ADMIN_NAME     "radmin"
#define MDC_RESV_CMCRENDV_NAME  "cmcrendv"

extern const char mdc_resv_admin_name[];
extern const char mdc_resv_cmcrendv_name[];

/*
 * There is no graft point to add more of these, but that could be
 * done from customer.h.
 */
#define MDC_ADMIN_GID_STR       "0"
#define MDC_RESV_ADMIN_GID_STR  "1000"
#define MDC_MONITOR_GID_STR     "1001"
#define MDC_UNPRIV_GID_STR      "1002"
#define MDC_CMCRENDV_GID_STR    "1003"

#define MDC_ACL_SUPERUSER_GID_STR        "0"
#define MDC_ACL_ADMIN_NONSUPER_GID_STR   "10000"
#define MDC_ACL_MONITOR_GID_STR          "10001"
#define MDC_ACL_CMCRENDV_GID_STR         "10002"
#define MDC_ACL_CMCCLIENT_GID_STR        "10003"
#define MDC_ACL_OPERATOR_GID_STR         "10004"

/*
 * If you want to launch a process as a user other than root,
 * presumably the main thing is the uid, which should be stable.
 * Under CAPABS, your gid will also be stable, as the capability class
 * the process should have with mgmtd.  However, under ACLS, the account's
 * gid cannot be guaranteed since it is chosen arbitrarily to be unique.
 * So it's best to run your process with some other stable gid, like this.
 */
#define MDC_ACL_USERS_GID           100
#define MDC_ACL_USERS_GID_STR      "100"

/* ------------------------------------------------------------------------- */
/** A global mapping of user visible capability group names to gids (that
 * will be written to /etc/group) that define a user's capability group.
 *
 * Note that the GIDs used under ACLs are not applicable here.
 */
static const lc_enum_string_map mdc_capability_gid_map[] = {
    {mgt_admin,      "admin"},
    {mgt_radmin,     "radmin"},
    {mgt_monitor,    "monitor"},
    {mgt_unpriv,     "unpriv"},

    /*
     * It's good to define this even if PROD_FEATURE_CMC_... are not
     * defined, lest someone introduce another gid that overlaps with
     * this.  As long as this is defined, overlapping ones will be 
     * caught at init time.
     */
    {mgt_cmcrendv,   "cmcrendv"},

/* ========================================================================= */
/* Customer-specific graft point 2: additional capability groups
 * =========================================================================
 */
#ifdef INC_MD_CLIENT_INC_GRAFT_POINT
#undef MD_CLIENT_INC_GRAFT_POINT
#define MD_CLIENT_INC_GRAFT_POINT 2
#include "../include/md_client.inc.h"
#endif /* INC_MD_CLIENT_INC_GRAFT_POINT */

    {0,      NULL}
};

/* ========================================================================= */
/** UID allocation
 */

typedef enum {
    mut_admin =          0,
    mut_statsd =      2001,
    mut_cmcrendv =    2002,
    mut_cmcclient =   2003,
} mdc_uid_type;

#define MDC_UID_STATSD_STR     "2001"
#define MDC_UID_CMCRENDV_STR   "2002"
#define MDC_UID_CMCCLIENT_STR  "2003"

extern const char mdc_uid_statsd_str[];
extern const char mdc_uid_cmcrendv_str[];
extern const char mdc_uid_cmcclient_str[];


/* ========================================================================= */
/* Other definitions
 */

typedef struct md_client_context md_client_context;

/**
 * This is the standard database change notification event.
 * If PROD_FEATURE_SECURE_NODES is enabled, the values of secure nodes
 * will be obfuscated.
 */
#define MDC_EVENT_DBCHANGE "/mgmtd/notify/dbchange"
extern const char mdc_event_dbchange[];

/*
 * This is the guaranteed cleartext version of the database change
 * notification event.  It is guaranteed not to have obfuscated values.
 * If PROD_FEATURE_SECURE_NODES is not enabled, it will be the same as
 * mdc_event_dbchange, since that will be the only event available.
 */
#ifdef PROD_FEATURE_SECURE_NODES
#define MDC_EVENT_DBCHANGE_CLEARTEXT "/mgmtd/notify/dbchange/cleartext"
#else
#define MDC_EVENT_DBCHANGE_CLEARTEXT "/mgmtd/notify/dbchange"
#endif

extern const char mdc_event_dbchange_cleartext[];

/*
 * This is the "as-saved" version of the database change notification
 * event.  It is always available, although it only does encryption if
 * PROD_FEATURE_SECURE_NODES is enabled.
 */
#define MDC_EVENT_DBCHANGE_AS_SAVED "/mgmtd/notify/dbchange/as_saved"
extern const char mdc_event_dbchange_as_saved[];


/**
 * This is the binding inside the dbchange events which tells the 
 * db revision id AFTER the change in question was made.
 */
#define MDC_EVENT_DBCHANGE_REVISION_ID \
    "/mgmtd/notification/dbchange_global/db_revision_id"
extern const char mdc_event_dbchange_revision_id[];


/* ========================================================================= */
/** @name Initialization and deinitialization
 */

/*@{*/

/* ------------------------------------------------------------------------- */
/** Initialize the md_client library.
 *
 * NOTE: if you are using libevent in your program, it is recommended
 * that you use mdc_wrapper_init() to initialize this API instead.
 * See mdc_wrapper.h for details.  mdc_init() is mostly maintained for
 * backward compatibility, and for callers who do not link with
 * libevent.
 *
 * \param msg_handler_func Function to be called when the library wants
 * to send a mgmtd message and wait for a reply.
 * \param msg_handler_data Data to be passed to msg_handler_func whenever
 * it is called.
 * \param user_msg_handler_func Function to be called if the md_client
 * library wants to supply a user-visible message of its own.
 * \param usr_msg_handler_data Data to be passed to user_msg_handler_func
 * whenever it is called.
 * \param session The GCL session to be used in this md_client context.
 * \param ret_mcc Returns the md_client context pointer, which must be
 * passed back to all future calls to the md_client API.
 */
int mdc_init(mdc_msg_handler_func_ptr msg_handler_func,
             void *msg_handler_data,
             mdc_user_msg_handler_func_ptr user_msg_handler_func, 
             void *usr_msg_handler_data,
             gcl_session *session,
             md_client_context **ret_mcc);


/* ------------------------------------------------------------------------- */
/** Deinitialize the md_client library and deallocate the md_client
 * context.
 *
 * NOTE: only call this if you initialized with mdc_init().  If you
 * initialized with mdc_wrapper_init(), use mdc_wrapper_disconnect()
 * and mdc_wrapper_deinit() instead.
 */
int mdc_deinit(md_client_context **inout_mcc);

/*@}*/

/* ========================================================================= */
/** @name Basic binding message shortcuts
 */

/*@{*/

/* ------------------------------------------------------------------------- */
/** Send a message to the management daemon and return the reply
 * broken down into bindings, a return code, and a return message.
 */
int mdc_send_mgmt_msg(md_client_context *mcc,
                      bn_request *request, tbool want_binding_name_parts,
                      bn_binding_array **ret_bindings,
                      uint32 *ret_code, tstring **ret_msg);

/* ------------------------------------------------------------------------- */
/** Send a message to the management daemon and return the response
 * message as is, without extracting anything from it.
 */
int mdc_send_mgmt_msg_raw(md_client_context *mcc,
                          bn_request *request, bn_response **ret_response);


/* ------------------------------------------------------------------------- */
/** Send a query message to the management daemon for a single binding,
 * and return the result, if any.
 *
 * \param mcc Md_client library context, returned from mdc_init().
 *
 * \param want_binding_name_parts Should the binding returned have 
 * the binding name also broken down into parts for quicker access.
 *
 * \param binding_name Name of binding to retrieve.
 *
 * \param db_name Name of config database to fetch from, or NULL to use
 * the current active database.
 *
 * \retval ret_code Return code from the request.
 *
 * \retval ret_msg User-friendly return message from the request.
 *
 * \retval ret_binding The binding returned from the request, if any.
 * This is dynamically allocated and should be freed by the caller.
 */

int mdc_get_binding(md_client_context *mcc,
                    uint32 *ret_code, tstring **ret_msg, 
                    tbool want_binding_name_parts,
                    bn_binding **ret_binding,
                    const char *binding_name, const char *db_name);


/* ------------------------------------------------------------------------- */
/** Same as mdc_get_binding(), except takes query flags and query node 
 * flags too.  query_flags is a bit field of ::bn_query_flags.
 */
int mdc_get_binding_ex(md_client_context *mcc,
                       uint32 *ret_code, tstring **ret_msg, 
                       tbool want_binding_name_parts,
                       bn_binding **ret_binding,
                       uint32 query_flags, 
                       bn_query_node_flags_bf query_node_flags,
                       const char *binding_name, const char *db_name);

#ifdef PROD_FEATURE_CMC_SERVER
/**
 * Like mdc_get_config except it's focused use is with cmc proxy
 * bindings. Since multiple bindings may be returned from a get of
 * a single binding with the cmc, return all bindings in the answer.
 * Also, if specified by the bool 'strip_group_info', remove from the
 * binding name in the response the portions of the group binding names
 * that have the 'appliance' and 'group' keywords as well as the
 * associated ids. Otherwise, do not modify the binding name.
 */
int mdc_get_cmc_bindings(md_client_context *mcc,
                         uint32 *ret_code, tstring **ret_msg, 
                         tbool want_binding_name_parts,
                         tbool strip_group_info,
                         bn_binding_array **ret_bindings,
                         const char *binding_name, const char *db_name);
#endif /* PROD_FEATURE_CMC_SERVER */

int mdc_get_binding_fmt(md_client_context *mcc,
                        uint32 *ret_code, tstring **ret_msg,
                        tbool want_binding_name_parts,
                        bn_binding **ret_binding,
                        const char *db_name, const char *binding_name_fmt, ...)
     __attribute__ ((format (printf, 7, 8)));


/* ------------------------------------------------------------------------- */
/** Query the value of a single binding from the management daemon and
 * return the value of the response in the form of a string.  If there
 * is a message returned with the response, the message is printed
 * automatically.
 *
 * \param mcc Md_client library context, returned from mdc_init().
 *
 * \param binding_name The name of the binding to query.
 *
 * \param db_name Name of config database to fetch from, or NULL to use
 * the current active database.
 *
 * \retval ret_code The error code from the management daemon's
 * response; 0 indicates success, any other number indicates failure.
 * NULL may be passed if the caller is not interested.
 *
 * \retval ret_msg User-friendly return message from the request.
 *
 * \retval ret_type The type of the node queried.  NULL may be passed if
 * the caller is not interested.
 *
 * \retval ret_value The value of the node queried.  This parameter
 * is mandatory.
 */
int mdc_get_binding_tstr(md_client_context *mcc,
                         uint32 *ret_code, tstring **ret_msg,
                         bn_type *ret_type, tstring **ret_value,
                         const char *binding_name, const char *db_name);

/**
 * Get a binding as a boolean.  If it is not a boolean, we return
 * lc_err_bad_type.
 */
int mdc_get_binding_tbool(md_client_context *mcc,
                          uint32 *ret_code, tstring **ret_msg,
                          tbool *ret_found, tbool *ret_value,
                          const char *binding_name, const char *db_name);

/* ------------------------------------------------------------------------- */
/** Same as mdc_get_binding_tstr() except that binding name is taken 
 * as a printf-style format string and variable-length argument list.
 */
int mdc_get_binding_tstr_fmt(md_client_context *mcc,
                             uint32 *ret_code, tstring **ret_msg,
                             bn_type *ret_type,
                             tstring **ret_value, const char *db_name,
                             const char *binding_name_fmt, ...)
     __attribute__ ((format (printf, 7, 8)));


/* ------------------------------------------------------------------------- */
/** Retrieve nodes underneath a specified binding node in the
 * management tree.  If there is a message returned with the response,
 * the message is printed automatically.
 *
 * \param mcc Md_client library context, returned from mdc_init().
 *
 * \param want_binding_name_parts Should the binding returned have 
 * the binding name also broken down into parts for quicker access.
 *
 * \param include_self If \c true, the node named by \c binding_name
 * will be returned in the results; otherwise it will not.
 *
 * \param subtree If \c true, retrieve all nodes underneath the root.
 * If \c false, retrieve only its immediate children.
 *
 * \param binding_name Name of the root node of the subtree to retrieve,
 * in the form of a printf-style format string and arguments.
 *
 * \retval ret_code Return code from the request.
 *
 * \retval ret_msg User-friendly return message from the request.
 *
 * \retval ret_bindings The bindings returned from the query.
 *
 * \retval ret_resp The raw response from the query.
 */
int mdc_get_binding_children(md_client_context *mcc,
                             uint32 *ret_code, tstring **ret_msg,
                             tbool want_binding_name_parts,
                             bn_binding_array **ret_bindings,
                             tbool include_self, tbool subtree,
                             const char *binding_name);

/*
 * 'query_node_flags' field is a bit field of ::bn_query_node_flags.
 */
int mdc_get_binding_children_ex(md_client_context *mcc,
                                uint32 *ret_code, tstring **ret_msg,
                                tbool want_binding_name_parts,
                                bn_binding_array **ret_bindings,
                                bn_query_node_flags_bf query_node_flags,
                                const char *binding_name, const char *db_name,
                                int32 rev_before, int32 *ret_rev_after);


/* ------------------------------------------------------------------------- */
/** Get the last components of the names of the specified binding's
 * immediate children in the form of a tstr_array.
 */
int mdc_get_binding_children_tstr_array(md_client_context *mcc,
                                        uint32 *ret_code, 
                                        tstring **ret_msg,
                                        tstr_array **ret_children,
                                        const char *binding_name,
                                        const char *db_name);
                                        

/* ------------------------------------------------------------------------- */
/** Get the nth child of the specified node.
 */
int mdc_get_nth_binding_child(md_client_context *mcc,
                              uint32 *ret_code, tstring **ret_msg,
                              tbool want_binding_name_parts,
                              bn_binding **ret_binding,
                              bn_type expected_type, uint32 child_num,
                              const char *parent_node_name,
                              const char *db_name);


/* ------------------------------------------------------------------------- */
/** Get the next child of the specified node.
 * Returns a NULL binding with success if the child specified was the
 * last one.  Returns the lc_err_not_found error if the child specified
 * was not really a child.
 */
int mdc_get_next_binding_child(md_client_context *mcc,
                               uint32 *ret_code, tstring **ret_msg,
                               tbool want_binding_name_parts,
                               bn_binding **ret_binding,
                               bn_type expected_type, 
                               const char *parent_node_name,
                               const char *child_name, const char *db_name);


/* ------------------------------------------------------------------------- */
/** Send a set request to the management daemon and wait for the
 * response.  If there is a message returned with the response, the
 * message is printed automatically.
 *
 * \param mcc Md_client library context, returned from mdc_init().
 *
 * \param set_subop The set suboperation to perform.  Valid values are
 * \c bsso_create, \c bsso_delete, \c bsso_reset, or \c bsso_modify.
 * Note that \c bsso_reparent is not supported with this function;
 * use mdc_reparent_binding for that.
 *
 * \param binding_type The type to set the binding to.
 *
 * \param binding_value A string representation of the value to set
 * the binding to.
 *
 * \param binding_name The name of the binding to set.
 *
 * \retval ret_code Return code from the request.  0 indicates success,
 * any other number indicates failure.  NULL may be passed if the caller
 * is not interested.
 *
 * \retval ret_msg User-friendly return message from the request.
 */
int mdc_set_binding(md_client_context *mcc,
                    uint32 *ret_code, tstring **ret_msg,
                    bn_set_subop set_subop, bn_type binding_type,
                    const char *binding_value,
                    const char *binding_name);

int mdc_set_binding_ex(md_client_context *mcc,
                       uint32 *ret_code, tstring **ret_msg,
                       bn_set_subop set_subop, bn_type binding_type,
                       uint32 binding_type_flags,
                       const char *binding_value,
                       const char *binding_name);

int mdc_set_binding_native_takeover(md_client_context *mcc,
                                    uint32 *ret_code, tstring **ret_msg,
                                    bn_set_subop set_subop,
                                    bn_binding **inout_binding);

int mdc_modify_binding(md_client_context *mcc,
                       uint32 *ret_code, tstring **ret_msg,
                       bn_type binding_type,
                       const char *binding_value, const char *binding_name);

int mdc_create_binding(md_client_context *mcc,
                       uint32 *ret_code, tstring **ret_msg,
                       bn_type binding_type,
                       const char *binding_value, const char *binding_name);

/**
 * Delete a binding, and the entire subtree rooted under it.
 * The binding name passed must be the name of a wildcard instance.
 * e.g. if "/a/b/ *" is registered, then you could pass "/a/b/1",
 * which would delete the instance named "1", along with all of its
 * descendants.
 *
 * Note that you cannot delete a literal node directly, whether or not
 * it's underneath a wildcard, since that would violate the database
 * schema expressed by the node registrations.
 */
int mdc_delete_binding(md_client_context *mcc,
                       uint32 *ret_code, tstring **ret_msg,
                       const char *binding_name);

/* ------------------------------------------------------------------------- */
/** Delete all children of a specified node.  The node name passed must be
 * the parent of a wildcard registration, such that all nodes to be deleted
 * would be wildcard instances.  e.g. if "/a/b/ *" is registered, then you
 * could pass "/a/b", which would delete all instances of "/a/b/ *".
 *
 * \param mcc Md_client library context, returned from mdc_init().
 *
 * \param root_name Name of parent of wildcard node, whose children are to
 * be deleted.
 *
 * \retval ret_code The return code from the last management request made.
 * If more than one request is needed, and the first request returns a
 * nonzero code, this function aborts and returns that code and message.
 *
 * \retval ret_msg The return message from the last management request made.
 */
int mdc_delete_binding_children(md_client_context *mcc,
                                uint32 *ret_code, tstring **ret_msg,
                                const char *root_name);


int mdc_reset_binding(md_client_context *mcc,
                      uint32 *ret_code, tstring **ret_msg,
                      const char *binding_name);

/* ------------------------------------------------------------------------- */
/** Send a reparent request to the management daemon.
 *
 * \param mcc Md_client library context, returned from mdc_init().
 *
 * \param binding_name The absolute name of the binding that is to be
 * renamed and/or moved (i.e. the root of the subtree to be reparented).
 *
 * \param graft_under_name The absolute name of the node under which the 
 * node named in 'binding_name' (and the subtree under it, if any) should 
 * be moved.  If you do not want to move the subtree to a new parent 
 * (i.e. you are just renaming it), this may be NULL.
 *
 * \param new_self_name The new last name part to be given to the node
 * named by 'binding_name' during the reparent operation.  If you want
 * it to keep its own name (e.g. you are just moving it to a new parent),
 * this may be NULL.  But at least one of graft_under_name or new_self_name
 * must be specified, or else this function would do nothing.
 *
 * \retval ret_code The error code from the management daemon's
 * response; 0 indicates success, any other number indicates failure.
 * NULL may be passed if the caller is not interested.
 *
 * \retval ret_msg User-friendly return message from the request.
 */
int mdc_reparent_binding(md_client_context *mcc,
                         uint32 *ret_code, tstring **ret_msg,
                         const char *binding_name,
                         const char *graft_under_name,
                         const char *new_self_name);

/**
 * Like mdc_reparent_binding(), except that it takes flags (both 
 * message-wide, and per-node) to include in the request.
 */
int mdc_reparent_binding_ex(md_client_context *mcc,
                            uint32 *ret_code, tstring **ret_msg,
                            const char *binding_name,
                            const char *graft_under_name,
                            const char *new_self_name,
                            bn_set_flags_bf overall_flags,
                            bn_set_node_flags_bf node_flags);


/* ------------------------------------------------------------------------- */
/* (XXX/EMT document)
 */
int mdc_send_action(md_client_context *mcc,
                    uint32 *ret_code, tstring **ret_msg,
                    const char *action_name);

/**
 * Send an action request with one or more bindings.  Each binding takes
 * three parameters: a name, type, and value.
 *
 * Note that for any given binding, if the value is NULL, the binding
 * will simply be skipped.  This can be useful for cases where you may
 * or may not have certain parameters under various conditions.
 */
int mdc_send_action_with_bindings_str_va(md_client_context *mcc,
                                         uint32 *ret_code,
                                         tstring **ret_msg,
                                         const char *action_name,
                                         uint32 num_bindings,
                                         const char *binding_name,
                                         bn_type binding_type,
                                         const char *binding_value, ...);

/**
 * Like mdc_send_action_with_bindings_str_va(), except returns a
 * binding array containing the bindings in the response message.
 */
int mdc_send_action_with_bindings_and_results_va(md_client_context *mcc,
                                                 uint32 *ret_code,
                                                 tstring **ret_msg,
                                                 const char *action_name,
                                                 bn_binding_array **ret_result,
                                                 uint32 num_bindings,
                                                 const char *binding_name,
                                                 bn_type binding_type,
                                                 const char *binding_value,
                                                 ...);

int mdc_send_action_with_bindings_and_results(md_client_context *mcc,
                                              uint32 *ret_code,
                                              tstring **ret_msg,
                                              const char *action_name,
                                              bn_binding_array *bindings,
                                              bn_binding_array **ret_results);

/*
 *  Create, but do not send an action message.  You can later call
 *  mdc_send_mgmt_msg() on the returned request. 
 */
int mdc_create_action_with_bindings_str_va(bn_request **ret_request,
                                           const char *action_name,
                                           uint32 num_bindings,
                                           const char *binding_name,
                                           bn_type binding_type,
                                           const char *binding_value, ...);

/**
 * Shortened version of mdc_send_event_with_bindings_str_va() which
 * does not take any bindings to include in the event.
 */
int mdc_send_event(md_client_context *mcc,
                   uint32 *ret_code, tstring **ret_msg,
                   const char *event_name);

/* ------------------------------------------------------------------------- */
/** Send an event request message, with one or more bindings included.
 * 
 * Note that if you initialized this API using mdc_wrapper_init(),
 * this call will not block on getting an event response from mgmtd,
 * or even on fully sending the event message on the session.  It will
 * return immediately, with no error code or message.  The message
 * will still be sent, as soon as the program returns to its event
 * loop, and the session becomes and remains writable long enough for
 * us to send it.  But the main caution here is that if you exit
 * shortly after sending an event, there is a chance that the event
 * may not go out at all.  See mdc_wrapper_params::mwp_request_complete_func
 * and mdc_wrapper_get_num_outstanding_events() for suggestions on how
 * to deal with this.
 *
 * If instead you initialized this API with mdc_init(), then it is
 * your own callback that determines whether events are sent
 * synchronously or asynchronously.  Sending them synchronously is
 * certainly the simpler approach; it just means that your
 * event-sending code may have to block for a while.  Note that events
 * are considered "barriers" by mgmtd, so if another long-running
 * request is already being processed, the event will not be able to
 * be accepted and acknowledged until all prior requests have
 * completed.
 */
int mdc_send_event_with_bindings_str_va(md_client_context *mcc,
                                        uint32 *ret_code,
                                        tstring **ret_msg,
                                        const char *event_name,
                                        uint32 num_bindings,
                                        const char *binding_name,
                                        bn_type binding_type,
                                        const char *binding_value, ...);

/*@}*/

/* ------------------------------------------------------------------------- */
/** A function to be called once for each binding in the result of an 
 * iterate query.  See mdc_foreach_binding() for details.
 *
 * \param bindings A binding response which is guaranteed to have all
 * of the descendants of the parent in the iterate query, and thus all of
 * the descendants of the binding named by \c name_components.
 *
 * \param idx The index number for the iteration.  This is 0 for the
 * first callback from any given call to mdc_foreach_binding(), and
 * increases by 1 for each subsequent call.
 *
 * \param name The name of the binding for this iteration, a child of
 * the parent specified in mdc_foreach_binding().
 *
 * \param name_components The name of the binding split into
 * components.  This is generated naturally by the matching process so
 * it is virtually free to provide.
 *
 * \param name_last_part The last component of the name of the binding
 * for this iteration.  This is simply the last element of
 * name_components, passed separately as a convenience.
 *
 * \param value
 * 
 * \param callback_data The data passed to mdc_foreach_binding() as
 * callback_data.
 *
 * \return NOTE: iteration is halted for any nonzero return code;
 * we do not honor the lc_err_foreach_... values.
 */
typedef int (*mdc_foreach_binding_func)(const bn_binding_array *bindings,
                                        uint32 idx, const bn_binding *binding,
                                        const tstring *name,
                                        const tstr_array *name_components,
                                        const tstring *name_last_part,
                                        const tstring *value,
                                        void *callback_data);

/** @name Iterators */

/*@{*/

/* ------------------------------------------------------------------------- */
/** Call a specified function once for each binding matching a binding
 * specification.  A binding spec is a binding name, optionally with:
 *
 * \li an asterisk "*" in place of one or more of the name components,
 * serves as a wildcard, matching any value for that component.  An
 * asterisk mixed in with other literal characters is taken literally;
 * only a lone asterisk is special.
 *
 * \li a double asterisk "**" in the last component means to match all
 * descendants of the binding name preceding it, regardless of how
 * many levels deep the nodes go.  Note that it will NOT match a 
 * binding whose name matches the pattern before the asterisk: at
 * least one additional binding name component must match the "**".
 * A double asterisk in a component other than the last one is taken
 * literally.
 *
 * This function performs a single subtree iterate query against the
 * root node of the smallest subtree that contains all of the 
 * matching nodes (i.e. the pattern chopped off at the first wildcard).
 * It then walks the resulting list and then calls your function for
 * each matching binding.
 *
 * \param mcc Md_client library context, returned from mdc_init().
 *
 * \param binding_spec Specification of which bindings to iterate over.
 *
 * \param db_name Name of config database to fetch from, or NULL to use
 * the current active database.
 *
 * \param callback A function to call for each binding matching the
 * specification.
 *
 * \param callback_data A piece of data to pass the callback function
 * on every call.
 *
 * \retval ret_num_matches The number of child nodes that were matched.
 * Pass NULL if you don't care.
 */
int mdc_foreach_binding(md_client_context *mcc,
                        const char *binding_spec, const char *db_name,
                        mdc_foreach_binding_func callback, void *callback_data,
                        uint32 *ret_num_matches);

/* ------------------------------------------------------------------------- */
/** Same as mdc_foreach_binding() except that all of the nodes to be
 * queried from the management daemon are expected to be found in the
 * provided bn_binding_array.
 */
int mdc_foreach_binding_prequeried(const bn_binding_array *bindings,
                                   const char *binding_spec, 
                                   const char *db_name,
                                   mdc_foreach_binding_func callback,
                                   void *callback_data,
                                   uint32 *ret_num_matches);

/* ------------------------------------------------------------------------- */
/** Same as mdc_foreach_binding_prequeried() except that the binding
 * specification is already broken down into components for easier
 * comparison.
 */
int mdc_foreach_binding_prequeried_parsed(const bn_binding_array *bindings,
                                          const tstr_array *spec_components,
                                          const char *db_name,
                                          mdc_foreach_binding_func callback,
                                          void *callback_data,
                                          uint32 *ret_num_matches);

/* ------------------------------------------------------------------------- */
/* An mdc_foreach_binding_func which does nothing.  This can be passed
 * to mdc_foreach_binding[_prequeried]() by a caller who simply wants
 * to count the number of matches against the specified pattern, since
 * those APIs will return this number even if the callback does nothing.
 */
int mdc_foreach_binding_nop(const bn_binding_array *bindings,
                            uint32 idx, const bn_binding *binding,
                            const tstring *name,
                            const tstr_array *name_components,
                            const tstring *name_last_part,
                            const tstring *value,
                            void *callback_data);

/* ------------------------------------------------------------------------- */
/* An mdc_foreach_binding_func which accepts a (tstr_array **) as its
 * callback_data.  If this points to a NULL (tstr_array *), we allocate
 * an array; otherwise we use the one that's already there.  We append
 * the string form of the value for each matched binding to this array.
 */
int mdc_foreach_binding_save_value(const bn_binding_array *bindings,
                                   uint32 idx, const bn_binding *binding,
                                   const tstring *name,
                                   const tstr_array *name_components,
                                   const tstring *name_last_part,
                                   const tstring *value,
                                   void *callback_data);

/*@}*/


/* ========================================================================= */
/** @name Node array manipulation
 *
 * These are functions for manipulating logical arrays of objects in the
 * binding hierarchy.  They work with sets of nodes where each object
 * instance is rooted by a wildcard node of an integer type, where the
 * value of the wildcard is the index into the logical array of
 * elements.  The descendants of each wildcard are the fields of the
 * array element.
 *
 * For example, the nodes "/resolver/domain_search/ * /domainname"
 * represent an array of domain names where the third part of the name
 * is an integer index.  Arrays may also have multiple children per
 * wildcard, simply meaning each logical object has more than one
 * field.
 *
 * The functions use the previously-registered callback to send
 * requests to the management daemon.  When a change to the database
 * is called for, two requests will generally be sent: a query to see
 * what indices there are and possibly what values their children
 * have, followed by a set which was constructed based on the query
 * and on what was originally requested in the function call.
 *
 * The 'root name' field is the parent of the wildcard node; in the
 * example above, it would be "/resolver/domain_search".
 *
 * When index numbers are automatically chosen, it is assumed that the
 * type of the index is an unsigned integer, and the lowest available
 * index is chosen, starting from 0.
 *
 * Each of them requires a session pointer to use to create messages.
 * It also passes the session back to the message handling function as
 * a convenience.  (XXX/EMT: is this necessary?)
 *
 * XXX/EMT: in the future we could let the caller specify the maximum
 * number of items that could fit, and if the range is full, whether
 * or not to overwrite the last item.  The config check function could
 * take care of the former, but not necessarily the latter.  Holding
 * off on implementing that (and all other bells and whistles) because
 * eventually we'd like to do this in a different manner altogether,
 * using side effect processing on the mgmt daemon side.
 */

/*@{*/

/**
 * Flags that can be applied to various mdc_array APIs.
 */
typedef enum {
    maf_none = 0,

    /**
     * For mdc_array_insert_ex(): if an element being added already
     * matches the one in the array, delete all matching elements
     * first before inserting (shifting other elements down to take
     * their place).
     */
    maf_resist_dups = 1 << 0,

    /**
     * For mdc_array_insert_ex(): do not clamp the index at the upper
     * bound of the range.  e.g. if there are indices [1..10], and
     * someone tries to insert at 16, it will normally clamp to 11;
     * but this flag will mean the insert will go at index 16.
     */ 
    maf_no_upperbound_clamp = 1 << 1,

} mdc_array_flags;

/** Bit field of ::mdc_array_flags ORed together. */
typedef uint32 mdc_array_flags_bf;


/* ------------------------------------------------------------------------- */
/** Append a new element to the end of the array.  The lowest available
 * non-negative index is used.
 *
 * \param mcc Md_client library context, returned from mdc_init().
 *
 * \param root_name Name of parent node of wildcard for the array.
 *
 * \param children Array of child nodes for the new element to be
 * added to the array.  Names of these nodes are relative to the
 * wildcard instance, which is a child of \c root_name.  In the
 * example above, the name of the child node would be "domainname".
 *
 * \param resist_dups What to do if there is already an element in the
 * array matching the one being added.  If \c true then delete all
 * matching elements first before appending, shifting other elements
 * down to take their place.  If \c false then don't check for
 * duplicates.
 *
 * \param rev_before Required revision ID.  If the revision ID of the
 * database is different from what is specified here, the operation
 * will fail.
 *
 * \retval ret_rev_after Resulting revision ID.  This is the revision
 * ID of the database after the set requests have completed.
 *
 * \retval ret_dup_deleted If resist_dups was true, this tells whether
 * or not a duplicate was found and deleted before appending the
 * specified array element.
 *
 * \retval ret_code The return code from the last management request made.
 * If more than one request is needed, and the first request returns a
 * nonzero code, this function aborts and returns that code and message.
 *
 * \retval ret_msg The return message from the last management request made.
 */
int mdc_array_append(md_client_context *mcc,
                     const char *root_name, const bn_binding_array *children,
                     tbool resist_dups, int32 rev_before, int32 *ret_rev_after,
                     tbool *ret_dup_deleted,
                     uint32 *ret_code, tstring **ret_msg);


/* ------------------------------------------------------------------------- */
/** A wrapper to mdc_array_append() that simplifies the API for the
 * case when the array element to be added has only a single binding.
 * Again, the child name is relative to the wildcard node.
 */
int mdc_array_append_single(md_client_context *mcc,
                            const char *root_name, const char *child_name, 
                            bn_type child_type, const char *child_value,
                            tbool resist_dups, tbool *ret_dup_deleted,
                            uint32 *ret_code, tstring **ret_msg);


/* ------------------------------------------------------------------------- */
/** Insert a new element into the array at the specified index.  Shift
 * all higher-numbered elements down to make room.
 *
 * \param mcc Md_client library context, returned from mdc_init().
 *
 * \param root_name Name of parent node of wildcard for the array.
 *
 * \param idx Index number in array at which to insert.  This will
 * become the value of the wildcard instance under which all of the
 * new nodes are inserted.
 *
 * \param children Array of child nodes for the new element to be
 * added to the array.  Names of these nodes are relative to the
 * wildcard instance, which is a child of \c root_name.  In the
 * example above, the name of the child node would be "domainname".
 *
 * \param flags Option flags.
 *
 * \retval ret_dup_deleted If the maf_resist_dups flag was passed,
 * this tells whether or not a duplicate was found and deleted before
 * inserting the specified array element.
 *
 * \retval ret_code The return code from the last management request made.
 * If more than one request is needed, and the first request returns a
 * nonzero code, this function aborts and returns that code and message.
 *
 * \retval ret_msg The return message from the last management request made.
 */
int mdc_array_insert_ex(md_client_context *mcc,
                        const char *root_name, uint32 idx,
                        const bn_binding_array *children,
                        mdc_array_flags_bf flags,
                        tbool *ret_dup_deleted,
                        uint32 *ret_code, tstring **ret_msg);

/**
 * Special case of mdc_array_insert_ex(), for backward compatibility.
 * Passes the maf_resist_dups flag iff resist_dups is true; and no
 * other flags are passed.
 */
int mdc_array_insert(md_client_context *mcc,
                     const char *root_name, uint32 idx,
                     const bn_binding_array *children,
                     tbool resist_dups, tbool *ret_dup_deleted,
                     uint32 *ret_code, tstring **ret_msg);


/* ------------------------------------------------------------------------- */
/** Delete one element from the array, specified by index number.
 *
 * \param mcc Md_client library context, returned from mdc_init().
 *
 * \param root_name Name of parent of wildcard node.
 *
 * \param idx Value of wildcard instance to delete.
 *
 * \param shift_to_cover If \c true elements with higher indices will
 * be shifted up (have their indices decremented) to cover the space
 * left by deleting this element.  Note that if there were already
 * holes in the index number space before the deletion, they are not
 * filled, as items are only shifted down by one index per prior item
 * deleted.
 *
 * \retval ret_code The return code from the last management request made.
 * If more than one request is needed, and the first request returns a
 * nonzero code, this function aborts and returns that code and message.
 *
 * \retval ret_msg The return message from the last management request made.
 */
int mdc_array_delete(md_client_context *mcc,
                     const char *root_name, uint32 idx,
                     tbool shift_to_cover, 
                     uint32 *ret_code, tstring **ret_msg);


/* ------------------------------------------------------------------------- */
/** Delete one or more elements from the array, specified by index
 * numbers.  This is the same as mdc_array_delete(), except that it
 * takes a uint32_array instead of a uint32 to specify the indices
 * of the elements to be deleted; and it takes rev_before and returns
 * rev_after, to support making multiple operations atomic.
 */
int mdc_array_delete_multiple_ex(md_client_context *mcc,
                                 const char *root_name,
                                 const uint32_array *indices,
                                 tbool shift_to_cover,
                                 int32 rev_before, int32 *ret_rev_after,
                                 uint32 *ret_code, tstring **ret_msg);

/* ------------------------------------------------------------------------- */
/** Backward compatibility wrapper for mdc_array_delete_multiple_ex();
 * does not take rev_before and return rev_after.
 */
int mdc_array_delete_multiple(md_client_context *mcc,
                              const char *root_name,
                              const uint32_array *indices,
                              tbool shift_to_cover,
                              uint32 *ret_code, tstring **ret_msg);


/* ------------------------------------------------------------------------- */
/** Move one element in the array to another position.
 *
 * \param mcc Md_client library context, returned from mdc_init().
 *
 * \param root_name Name of parent of wildcard node.
 *
 * \param idx Index of wildcard instance to move.
 *
 * \param dest Index to which to move the wildcard instance.
 *
 * \param flags Option flags.
 *
 * \retval ret_code The return code from the last management request made.
 * If more than one request is needed, and the first request returns a
 * nonzero code, this function aborts and returns that code and message.
 *
 * \retval ret_msg The return message from the last management request made.
 */
int mdc_array_move_ex(md_client_context *mcc,
                      const char *root_name, uint32 idx, uint32 dest,
                      mdc_array_flags flags,
                      uint32 *ret_code, tstring **ret_msg);

/**
 * A special case of mdc_array_move_ex() for backward compatibility.
 * No flags are passed.
 */
int mdc_array_move(md_client_context *mcc,
                   const char *root_name, uint32 idx, uint32 dest,
                   uint32 *ret_code, tstring **ret_msg);


/* ------------------------------------------------------------------------- */
/** Delete one or more elements from the array.  Each element in the
 * array is compared to the model values in the 'children' array.  If
 * all of the values specified in the 'children' array exactly match
 * the fields of the same name in the array element in question, that
 * array element is deleted.  (Note that this represents a logical AND
 * match on the criteria; no logical OR match is currently supported)
 *
 * \param mcc Md_client library context, returned from mdc_init().
 *
 * \param root_name Name of parent of wildcard node.
 *
 * \param shift_to_cover See mdc_array_delete().
 * 
 * \param children A set of criteria for matching nodes to be deleted.
 * The names in these bindings are considered relative to the wildcard
 * node.  In order for a wildcard instance to be deleted, all nodes in
 * the \c children array must have matching nodes underneath the
 * wildcard instance.
 *
 * \param rev_before Required revision ID.  If the revision ID of the
 * database is different from what is specified here, the operation
 * will fail.
 *
 * \retval ret_rev_after Resulting revision ID.  This is the revision
 * ID of the database after the set requests have completed.
 *
 * \retval ret_num_deleted The number of children that were deleted as
 * a result of this request.
 *
 * \retval ret_code The return code from the last management request made.
 * If more than one request is needed, and the first request returns a
 * nonzero code, this function aborts and returns that code and message.
 *
 * \retval ret_msg The return message from the last management request made.
 */
int mdc_array_delete_by_value(md_client_context *mcc,
                              const char *root_name, tbool shift_to_cover,
                              const bn_binding_array *children,
                              int32 rev_before, int32 *ret_rev_after,
                              uint32 *ret_num_deleted,
                              uint32 *ret_code, tstring **ret_msg);


/* ------------------------------------------------------------------------- */
/** A wrapper to mdc_array_delete_by_value() that simplifies the API
 * for the case when there is only a single criterion for matching
 * elements in the array.
 */
int mdc_array_delete_by_value_single(md_client_context *mcc,
                                     const char *root_name,
                                     tbool shift_to_cover,
                                     const char *child_name,
                                     bn_type child_type,
                                     const char *child_value,
                                     uint32 *ret_num_deleted,
                                     uint32 *ret_code, tstring **ret_msg);


/* ------------------------------------------------------------------------- */
/** A helper function to the main ones listed in this file, exposed
 * because it could also be helpful to a client.  Get a list of all of
 * the index numbers under a specified binding (assuming that its
 * child is a wildcard of an unsigned integer data type).
 * Note that this is really just a degenerate case of
 * mdc_array_get_matching_indices().
 */
int mdc_array_get_indices(md_client_context *mcc,
                          const char *root_name, const char *db_name, 
                          int32 rev_before, int32 *ret_rev_after,
                          uint32_array **ret_indices,
                          uint32 *ret_code, tstring **ret_msg);


/* ------------------------------------------------------------------------- */
/** Get an array of the index numbers of elements that match all of the
 * criteria specified by the 'children' array.  The names in the
 * bindings in the 'children' array are considered relative to the
 * wildcard node.  Note that if the 'children' array is empty,
 * all elements will match and this will behave the same as
 * mdc_array_get_indices(), though it will be less efficient because
 * it queries the entire subtree under the root instead of just the
 * immediate children.
 */
int mdc_array_get_matching_indices(md_client_context *mcc,
                                   const char *root_name, const char *db_name, 
                                   const bn_binding_array *children,
                                   int32 rev_before, int32 *ret_rev_after,
                                   uint32_array **ret_indices,
                                   uint32 *ret_code, tstring **ret_msg);


/* ------------------------------------------------------------------------- */
/** Set a specified element in an array.  The nodes set will have
 * names \<root\>/\<idx\>/\<names from children array\>, with types and
 * values taken from the children array.
 */
int mdc_array_set_element(md_client_context *mcc,
                          const char *root_name, uint32 idx,
                          const bn_binding_array *children,
                          int32 rev_before, int32 *ret_rev_after,
                          uint32 *ret_code, tstring **ret_msg);


/* ------------------------------------------------------------------------- */
/** Set a specified list of values on every existing element in the
 * specified node array.  The names in the binding array are relative
 * to the wildcard node.
 */
int mdc_array_set_fields(md_client_context *mcc,
                         const char *root_name, 
                         const bn_binding_array *children,
                         uint32 *ret_code, tstring **ret_msg);


/* ------------------------------------------------------------------------- */
/** Helper function to create a binding array out of a single binding,
 * whose value is given in string form.
 */
int
mdc_array_create_binding_array(bn_binding_array **ret_barr,
                               const char *bname,
                               bn_attribute_id attrib_id,
                               bn_type btype,
                               uint32 btype_flags,
                               const char *value);

/* ------------------------------------------------------------------------- */
/** Same as mdc_array_set_fields(), except that it sets only a single
 * field, with a correspondingly more lightweight API.
 */
int mdc_array_set_fields_single(md_client_context *mcc,
                                const char *root_name, 
                                const char *child_name, bn_type child_type,
                                const char *child_value,
                                uint32 *ret_code, tstring **ret_msg);

/*@}*/

/* ========================================================================= */
/** @name Miscellaneous
 */

/*@{*/

/* ------------------------------------------------------------------------- */
/** Interpret an incoming query request, and dispatch it to provided
 * iterate and get handlers, as appropriate.
 *
 * The structure of the monitoring requests sent from mgmtd to
 * external providers is behind the curtain of abstraction, so this
 * call is pretty much your only option for your query request
 * handler.  The get and iterate callbacks you provide work much like
 * the get and iterate handlers a mgmtd module provides to mgmtd for
 * internal monitoring nodes.
 *
 * Note: you may only call this ONCE per incoming request.  This call
 * will assemble whatever response it can get from your get and
 * iterate callbacks, and then send a response.  Any subsequent calls
 * would only be sending additional response messages to the same
 * request, which would be ignored by mgmtd.
 *
 * XXXX/EMT: bug 12956: add extended version, with extended handlers,
 * where they get told the user's credentials for custom enforcement.
 * NOTE: we *could* have separate permissions check functions, and this
 * would be philosophically cleaner.  BUT there might be a performance
 * advantage to combining them this way, especially if the code has to do
 * some lookups to know which object it is, etc., so might as well leave
 * it combined.
 */
int
mdc_dispatch_mon_request(gcl_session *sess, const bn_request *req,
                         mdc_mon_request_get_handler get_handler,
                         void *get_data,
                         mdc_mon_request_iterate_handler iterate_handler,
                         void *iterate_data);


/* ------------------------------------------------------------------------- */
/** Same as mdc_dispatch_mon_request(), except instead of sending the
 * response directly, we return it to the caller.  (Consequently, we
 * do not need the session, since it was only used for sending the
 * response.)
 */
int
mdc_dispatch_mon_request_nosend(const bn_request *req,
                               mdc_mon_request_get_handler get_handler,
                               void *get_data,
                               mdc_mon_request_iterate_handler iterate_handler,
                               void *iterate_data,
                               bn_response **ret_resp);


/* ------------------------------------------------------------------------- */
/** Given a binding name specification with possible wildcards, return
 * the root node underneath which all such wildcards will fall.
 * Also return whether or not a wildcard was found at all.  If one
 * was not, the spec will be returned as the name.
 */
int mdc_get_root_name(const char *binding_spec, char **ret_root_name,
                      tbool *ret_found_wildcard);

/* ------------------------------------------------------------------------- */
/** Like mdc_get_root_name(), except also optionally can return the 
 * root name parts.
 */
int mdc_get_root_name_ex(const char *binding_spec, char **ret_root_name,
                         tbool *ret_found_wildcard, 
                         tstr_array **ret_root_name_parts, 
                         tbool *ret_root_name_is_abs);

/* ------------------------------------------------------------------------- */
/** Takes an array of bindings from a management node change
 * notification (the /mgmtd/notify/dbchange event).  Transforms them
 * into two binding arrays and a string array.  Each binding array has
 * a single binding per changed binding; one has the old values as
 * they were before the change, and the other has their new values.
 * The string array lists all of the binding names that were provided
 * as "unspecified" changes, as a result of nodes being registered
 * with the mrf_change_no_notify flag.
 *
 *   - Modified bindings exist in both arrays and their old and new
 *     values are represented.
 *
 *   - Added bindings exist only in the new array.
 *
 *   - Deleted bindings exist in both arrays.  In the new array, they have
 *     no value, and have the ::btf_deleted type flag set.
 *
 *   - "Unspecified" changes do not exist in either binding array.
 *     Instead, they show up as an entry in the string array, since there
 *     are no attributes included, only the name.
 *
 * Note that you can pass NULL for any of these arrays if you don't
 * care about the answer.
 *
 * Has the side effect of sorting the array of bindings that is passed in.
 */
int mdc_event_config_change_notif_extract(bn_binding_array *notif_bindings,
                                          bn_binding_array **ret_old_bindings,
                                          bn_binding_array **ret_new_bindings,
                                          tstr_array **ret_unspec_changes);

/* ------------------------------------------------------------------------- */
/** Like mdc_event_config_change_notif_extract(), except with two
 * differences:
 *
 *   1. It takes a bn_request instead of a binding array, and it takes
 *      over ownership of this request.  This allows us to avoid
 *      unnecessary copies of data (mostly binding names and attribute
 *      values) which was just going to be freed anyway.  The request
 *      provided will be freed before we return, and the caller's pointer
 *      set to NULL.
 *
 *   2. It optionally takes a set of binding name prefixes, which serves
 *      as a filter for changes we are interested in.  If -1 is passed 
 *      here, no filtering is done, as in 
 *      mdc_event_config_change_notif_extract(), and ret_unmatched_changes
 *      returns -1.  If 0 or higher is passed, then we expect that number
 *      of 'const char *' parameters to follow, which are binding name 
 *      prefixes to be used in filtering the change records.  Only
 *      changes matching one (or more) of these prefixes will be
 *      included in ret_old_bindings, ret_new_bindings, and
 *      ret_unspec_changes.  Changes not matching any of these
 *      prefixes are excluded, though their count is returned in
 *      ret_unmatched_changes.
 *
 *      (We do not accept patterns here, because we do not already have 
 *      the binding name in parts form, and getting each one that way 
 *      would add considerably more expense than the filtering saves!)
 *
 * NOTE: passing 0 for num_prefixes does NOT mean to do no filtering!
 * It means essentially to filter out all changes.  The result will be
 * empty arrays for the first three return values, and
 * ret_unmatched_changes will have the total number of changes in the
 * event.  Callers who want no filtering should be careful to pass -1
 * instead of 0.
 */
int mdc_event_config_change_notif_extract_takeover
    (bn_request **inout_req,
     bn_binding_array **ret_old_bindings,
     bn_binding_array **ret_new_bindings,
     tstr_array **ret_unspec_changes,
     int32 *ret_unmatched_changes,
     int32 num_prefixes, ...);
     

/* ------------------------------------------------------------------------- */
/** Variant of mdc_event_config_change_notif_extract_takeover() which 
 * accepts only the array of bindings taken out of the event request,
 * rather than the whole event request.  We take the callers word
 * that the bindings came from a dbchange event request.  The binding
 * array will be freed before we return, and the caller's pointer will
 * be set to NULL.
 *
 * This may be useful in cases where the caller needed to look at the
 * bindings in the request before calling us.  So they may have called
 * bn_request_get_takeover(), leaving the request unsuitable for
 * passing to mdc_event_config_change_notif_extract_takeover().
 *
 * Note, however, that mdc_event_config_change_notif_extract_takeover()
 * is likely to be more efficient.  (Even if it is not now, it will 
 * become so in the future, as it provides more opportunities for
 * optimization.)
 */
int mdc_event_config_change_notif_extract_takeover_bindings
    (bn_binding_array **inout_bindings,
     bn_binding_array **ret_old_bindings,
     bn_binding_array **ret_new_bindings,
     tstr_array **ret_unspec_changes,
     int32 *ret_unmatched_changes,
     int32 num_prefixes, ...);


/* ------------------------------------------------------------------------- */
/** Takes an array of bindings from a management action notification
 * (the /mgmtd/notify/action event).  Transforms them into an array of
 * bindings as accompanied the action, and extracts the action name.
 *
 * Has the side effect of sorting the array of bindings that is passed in.
 */
int mdc_event_action_notif_extract(bn_binding_array *notif_bindings,
                                   tstring **ret_action_name,
                                   bn_binding_array **ret_action_bindings);


/* ------------------------------------------------------------------------- */
/** Get the sequence number of a binding among its peers. Do a
 * non-recursive iterate of the specified binding's parents to get all
 * of its peers.  Search the list of peers (in the order it was
 * returned) until the binding itself is found, and return the index
 * number at which it was found.
 *
 * \param mcc Md_client library context, returned from mdc_init().
 *
 * \param binding_name The name of the binding whose sequence number
 * to find.
 *
 * \retval ret_seq The ordering of this binding relative to its peers,
 * starting from 0.  If the binding is not found, -1 is placed here,
 * and an error code is returned.
 */
int mdc_get_sequence_among_peers(md_client_context *mcc,
                                 const char *binding_name, int32 *ret_seq);


/* ------------------------------------------------------------------------- */
/** Count the number of children of a parent configuration node.
 * Note that this cannot be used on monitoring nodes.
 *
 * \param mcc Md_client library context, returned from mdc_init().
 *
 * \param parent_name The name of the parent configuration node whose
 * children to count.
 *
 * \param db_name Name of config database to fetch from, or NULL to use
 * the current active database.
 *
 * \retval ret_code Response code.
 *
 * \retval ret_msg Response message.
 *
 * \retval ret_count The number of children found, or -1 if there was 
 * a problem.  If the parent node simply does not exist, this is not
 * considered an error, so 0 is returned.
 */
int mdc_count_children(md_client_context *mcc, const char *parent_name,
                       const char *db_name, uint32 *ret_code, 
                       tstring **ret_msg, int64 *ret_count);


/* ------------------------------------------------------------------------- */
/** Take a 32-bit response code, taken from a set response message
 * from mgmtd, and break it apart into the two 16-bit values that were
 * synthesized to make it.  Note that this is only applicable to set
 * responses, as the structure pertains specifically to attempts to
 * modify the configuration database.
 *
 * \param response_code 32-bit response code taken from a set response
 * message from mgmtd.
 *
 * \retval ret_commit_response_code The 16-bit response code from the
 * commit check phase.  If this number is nonzero, it means that check
 * (validate) phase failed, and no changes were made to the
 * configuration database.  If it is zero, it means that the check phase
 * succeeded, and the changes were applied to the database.
 *
 * \retval ret_apply_response_code The 16-bit response code from the
 * commit apply phase.  Once mgmtd gets to the apply phase, the change
 * has already been accepted to the database, so a nonzero number here
 * does NOT mean that the change was rejected.  It means that the change
 * was accepted, but there was some problem in applying the changes to
 * the system.  All of the changes are present in the database, but some
 * or all of the changes may have failed to be applied to the system.
 */
int mdc_response_code_components(uint32 response_code,
                                 uint16 *ret_commit_response_code,
                                 uint16 *ret_apply_response_code);


/* ------------------------------------------------------------------------- */
/** Given a string describing the origin of a user login, add an
 * appropriate binding to the provided request, which is assumed to be
 * a request against the action node "/mgmtd/session/actions/login".
 *
 * \param req The request to which to add the binding.
 *
 * \param origin_str A string describing the origin of a login.
 * It may be an IP address or a hostname.
 *
 * \param flags Reserved for future use.  For now, callers must pass 0.
 *
 * XXX/EMT: one possible future use for 'flags' would be to indicate
 * whether a string is a hostname or another kind of string such as a
 * TTY name.  Because we don't apply hostname validation rules (and 
 * because TTY names would validate as hostnames anyway), we can't rely
 * on being able to figure it out for ourselves.
 */
int mdc_login_action_add_origin(bn_request *req, const char *origin_str,
                                uint32 flags);


/*@}*/

/* ------------------------------------------------------------------------- */
/** @name Remote registration tree manipulation */

/*@{*/

int mdc_remote_reg_get_node_tree(tree *remote_tree,
                                 const tstr_array *node_name_parts,
                                 tree_node **ret_tree_node,
                                 mdc_remote_node_reg **ret_reg_node);

int mdc_remote_reg_free(mdc_remote_node_reg **ret_node);

void mdc_remote_reg_free_for_tree(void *value);

int mdc_remote_reg_add_node(tree *reg_tree, mdc_remote_node_reg *node);

int mdc_remote_reg_new_node(mdc_remote_node_reg **ret_node,
                            const char *node_name, uint32 node_reg_flags, uint32 cap_mask);

int mdc_remote_reg_get_name(mdc_remote_node_reg *reg_node,
                            const char **ret_name);

int mdc_remote_reg_get_node_reg_flags(mdc_remote_node_reg *reg_node,
                                      uint32 *ret_node_reg_flags);

int mdc_remote_reg_get_cap_mask(mdc_remote_node_reg *reg_node, 
                                uint32 *ret_cap_mask);

/*@}*/

/** @name String operations */

/*@{*/


/* ------------------------------------------------------------------------- */
/** Assess whether file spec bindings supplied with names of the form:
 *
 *  {prefix}local_path, or {prefix}local_dir and/or {prefix}local_filename
 *
 *  constitutes a valid file or directory specification, then populate return
 *  variables of the same name so that they all contain that specification,
 *  regardless of which variables were used to specify it.
 *
 * \param params The array of bindings among which the file bindings may be
 * found
 *
 * \param prefix (optional) A binding name prefix (e.g. use "src_" for
 * bindings named src_local_path, src_local_dir, src_local_filename)
 *
 * \param ret_local_dir (optional) Return variable for the local_dir value
 *
 * \param ret_local_filename (optional) Return variable for the
 * local_filename value
 *
 * \param ret_local_path (optional) Return variable for the local_path value
 *
 * \param ret_success (optional) Return whether a valid file spec was
 * systhesized
 *
 * \param ret_message (optional) Return Error message explaining what was
 * wrong with the params provided
 */
int
mdc_path_synth_from_bindings(const bn_binding_array *params,
                             const char *prefix, tstring **ret_local_dir,
                             tstring **ret_local_filename,
                             tstring **ret_local_path, tbool *ret_success,
                             tstring **ret_message);


/* ------------------------------------------------------------------------- */
/** Choose a hopefully-unique operation ID, by appending a string
 * representation of a 64-bit random number to a specified prefix.
 * The prefix should be unique to the caller's context (e.g. one might
 * use the name of a module such as "web_image").
 */
int mdc_progress_choose_oper_id(md_client_context *mcc, const char *prefix, 
                                char **ret_oper_id);


/* ------------------------------------------------------------------------- */
/** Infer the progress operation ID which would automatically be chosen 
 * by mgmtd for the request provided.  This will be:
 *
 *     "<peername>-<peerpid>-<reqid>"
 */
int mdc_progress_infer_oper_id(md_client_context *mcc, const bn_request *req,
                               char **ret_oper_id);


/* ------------------------------------------------------------------------- */
/** Substitute parameters into a template string and return the
 * result.  The following substitutions are supported:
 *
 *   - All instances of "$n$" (where n is a positive integer) in
 *     'tmpl' will be substituted out for the nth element in the
 *     'params' array, starting counting from 1.  (e.g. $1$ retrieves
 *     the element with index 0, etc.)
 *
 *   - All instances of "$n$" (where n is a literal 'n') will be
 *     substituted out for the string in the 'name' parameter.
 *     If 'name' is NULL, the empty string will be used.
 *
 *   - All instances of "$v$" (where v is a literal 'v') will be
 *     substituted out for the string in the 'value' parameter.
 *     If 'value' is NULL, the empty string will be used.
 *
 *   - All instances of "$i$" (where i is a literal 'i') will be
 *     substituted out for a string form of the 'idx' parameter.
 *
 *   - The '^' character may be used in place of '$' to the same effect.
 *     It is supported for backward compatibility.
 *
 * The '$', '^', and '\' characters may be backslash-escaped to use
 * them as literal characters.
 *
 * The 'for_name' parameter specifies whether or not the substitution
 * is building a mgmtd node name.  If it is set to true, anything
 * being substituted in from the params array is escaped for use in a
 * name.  The 'name', 'value', and 'idx' fields are never escaped.
 */
int mdc_subst_params(const char *tmpl, const tstr_array *params,
                     uint32 idx, const char *name, const char *value,
                     tbool for_name, tstring **ret_result);

/*
 * XXX/EMT: should migrate comments from cli_printf_query()
 * and cli_printf_prequeried().
 */

int mdc_smprintf_query(md_client_context *mcc,
                       char **ret_str, const char *format, ...)
     __attribute__ ((format (printf, 3, 4)));

int mdc_vsmprintf_query(md_client_context *mcc,
                        char **ret_str, const char *format, va_list ap)
     __attribute__ ((format (printf, 3, 0)));


int mdc_smprintf_prequeried(char **ret_str, const bn_binding_array *bindings,
                            const char *format, ...)
     __attribute__ ((format (printf, 3, 4)));

int mdc_vsmprintf_prequeried(char **ret_str,
                             const bn_binding_array *bindings,
                             const char *format, va_list ap)
     __attribute__ ((format (printf, 3, 0)));

/*@}*/

int mdc_get_gcl_session(md_client_context *mcc, gcl_session **ret_sess);

#ifdef __cplusplus
}
#endif

#endif /* __MD_CLIENT_H_ */
