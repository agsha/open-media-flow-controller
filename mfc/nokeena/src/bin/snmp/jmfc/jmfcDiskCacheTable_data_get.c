/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 12088 $ of $ 
 *
 * $Id:$
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "jmfcDiskCacheTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement jmfcDiskCacheTable get routines.
 * TODO:240:M: Implement jmfcDiskCacheTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table jmfcDiskCacheTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * JUNIPER-MFC-MIB::jmfcDiskCacheTable is subid 1 of jmfcDiskCaches.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.2636.1.2.1.2.1.1, length: 13
*/

/* ---------------------------------------------------------------------
 * TODO:200:r: Implement jmfcDiskCacheTable data context functions.
 */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 * @param jmfcDiskCacheIndex_val
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
jmfcDiskCacheTable_indexes_set_tbl_idx(jmfcDiskCacheTable_mib_index *tbl_idx, u_long jmfcDiskCacheIndex_val)
{
    DEBUGMSGTL(("verbose:jmfcDiskCacheTable:jmfcDiskCacheTable_indexes_set_tbl_idx","called\n"));

    /* jmfcDiskCacheIndex(1)/UNSIGNED32/ASN_UNSIGNED/u_long(u_long)//l/A/w/e/r/d/h */
    tbl_idx->jmfcDiskCacheIndex = jmfcDiskCacheIndex_val;
    

    return MFD_SUCCESS;
} /* jmfcDiskCacheTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
jmfcDiskCacheTable_indexes_set(jmfcDiskCacheTable_rowreq_ctx *rowreq_ctx, u_long jmfcDiskCacheIndex_val)
{
    DEBUGMSGTL(("verbose:jmfcDiskCacheTable:jmfcDiskCacheTable_indexes_set","called\n"));

    if(MFD_SUCCESS != jmfcDiskCacheTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx
                                   , jmfcDiskCacheIndex_val
           ))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if(0 != jmfcDiskCacheTable_index_to_oid(&rowreq_ctx->oid_idx,
                                    &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* jmfcDiskCacheTable_indexes_set */


/*---------------------------------------------------------------------
 * JUNIPER-MFC-MIB::jmfcDiskCacheEntry.jmfcDiskCacheSerialNumber
 * jmfcDiskCacheSerialNumber is subid 3 of jmfcDiskCacheEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2636.1.2.1.2.1.1.1.3
 * Description:
The serial number read from the physical disk.

		If no serial number was read from the physical disk, then this field
		is empty.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is OCTETSTR (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.
 */
/**
 * Extract the current value of the jmfcDiskCacheSerialNumber data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param jmfcDiskCacheSerialNumber_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param jmfcDiskCacheSerialNumber_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by jmfcDiskCacheSerialNumber.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*jmfcDiskCacheSerialNumber_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update jmfcDiskCacheSerialNumber_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
jmfcDiskCacheSerialNumber_get( jmfcDiskCacheTable_rowreq_ctx *rowreq_ctx, char **jmfcDiskCacheSerialNumber_val_ptr_ptr, size_t *jmfcDiskCacheSerialNumber_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != jmfcDiskCacheSerialNumber_val_ptr_ptr) && (NULL != *jmfcDiskCacheSerialNumber_val_ptr_ptr));
   netsnmp_assert( NULL != jmfcDiskCacheSerialNumber_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:jmfcDiskCacheTable:jmfcDiskCacheSerialNumber_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the jmfcDiskCacheSerialNumber data.
 * copy (* jmfcDiskCacheSerialNumber_val_ptr_ptr ) data and (* jmfcDiskCacheSerialNumber_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for jmfcDiskCacheSerialNumber data
     */
    if ((NULL == (* jmfcDiskCacheSerialNumber_val_ptr_ptr )) ||
        ((* jmfcDiskCacheSerialNumber_val_ptr_len_ptr ) <
         (rowreq_ctx->data.jmfcDiskCacheSerialNumber_len* sizeof(rowreq_ctx->data.jmfcDiskCacheSerialNumber[0])))) {
        /*
         * allocate space for jmfcDiskCacheSerialNumber data
         */
        (* jmfcDiskCacheSerialNumber_val_ptr_ptr ) = malloc(rowreq_ctx->data.jmfcDiskCacheSerialNumber_len* sizeof(rowreq_ctx->data.jmfcDiskCacheSerialNumber[0]));
        if(NULL == (* jmfcDiskCacheSerialNumber_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* jmfcDiskCacheSerialNumber_val_ptr_len_ptr ) = rowreq_ctx->data.jmfcDiskCacheSerialNumber_len* sizeof(rowreq_ctx->data.jmfcDiskCacheSerialNumber[0]);
    memcpy( (* jmfcDiskCacheSerialNumber_val_ptr_ptr ), rowreq_ctx->data.jmfcDiskCacheSerialNumber, rowreq_ctx->data.jmfcDiskCacheSerialNumber_len* sizeof(rowreq_ctx->data.jmfcDiskCacheSerialNumber[0]) );

    return MFD_SUCCESS;
} /* jmfcDiskCacheSerialNumber_get */

/*---------------------------------------------------------------------
 * JUNIPER-MFC-MIB::jmfcDiskCacheEntry.jmfcDiskCacheName
 * jmfcDiskCacheName is subid 5 of jmfcDiskCacheEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2636.1.2.1.2.1.1.1.5
 * Description:
A symbolic, internally generated cache name for the
		disk. For example, dc_1, dc_3, etc
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is OCTETSTR (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.
 */
/**
 * Extract the current value of the jmfcDiskCacheName data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param jmfcDiskCacheName_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param jmfcDiskCacheName_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by jmfcDiskCacheName.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*jmfcDiskCacheName_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update jmfcDiskCacheName_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
jmfcDiskCacheName_get( jmfcDiskCacheTable_rowreq_ctx *rowreq_ctx, char **jmfcDiskCacheName_val_ptr_ptr, size_t *jmfcDiskCacheName_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != jmfcDiskCacheName_val_ptr_ptr) && (NULL != *jmfcDiskCacheName_val_ptr_ptr));
   netsnmp_assert( NULL != jmfcDiskCacheName_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:jmfcDiskCacheTable:jmfcDiskCacheName_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the jmfcDiskCacheName data.
 * copy (* jmfcDiskCacheName_val_ptr_ptr ) data and (* jmfcDiskCacheName_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for jmfcDiskCacheName data
     */
    if ((NULL == (* jmfcDiskCacheName_val_ptr_ptr )) ||
        ((* jmfcDiskCacheName_val_ptr_len_ptr ) <
         (rowreq_ctx->data.jmfcDiskCacheName_len* sizeof(rowreq_ctx->data.jmfcDiskCacheName[0])))) {
        /*
         * allocate space for jmfcDiskCacheName data
         */
        (* jmfcDiskCacheName_val_ptr_ptr ) = malloc(rowreq_ctx->data.jmfcDiskCacheName_len* sizeof(rowreq_ctx->data.jmfcDiskCacheName[0]));
        if(NULL == (* jmfcDiskCacheName_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* jmfcDiskCacheName_val_ptr_len_ptr ) = rowreq_ctx->data.jmfcDiskCacheName_len* sizeof(rowreq_ctx->data.jmfcDiskCacheName[0]);
    memcpy( (* jmfcDiskCacheName_val_ptr_ptr ), rowreq_ctx->data.jmfcDiskCacheName, rowreq_ctx->data.jmfcDiskCacheName_len* sizeof(rowreq_ctx->data.jmfcDiskCacheName[0]) );

    return MFD_SUCCESS;
} /* jmfcDiskCacheName_get */

/*---------------------------------------------------------------------
 * JUNIPER-MFC-MIB::jmfcDiskCacheEntry.jmfcDiskCacheTierType
 * jmfcDiskCacheTierType is subid 6 of jmfcDiskCacheEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2636.1.2.1.2.1.1.1.6
 * Description:
The tier type for this disk cache. At present,
		three tier types are available -
		SSD  (Solid State Device)
		SAS  (Serial Attached SCSI)
		SATA (Serial Attached ATA)

		If the disk type is not known, then this field returns
		UNKNOWN.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is OCTETSTR (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.
 */
/**
 * Extract the current value of the jmfcDiskCacheTierType data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param jmfcDiskCacheTierType_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param jmfcDiskCacheTierType_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by jmfcDiskCacheTierType.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*jmfcDiskCacheTierType_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update jmfcDiskCacheTierType_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
jmfcDiskCacheTierType_get( jmfcDiskCacheTable_rowreq_ctx *rowreq_ctx, char **jmfcDiskCacheTierType_val_ptr_ptr, size_t *jmfcDiskCacheTierType_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != jmfcDiskCacheTierType_val_ptr_ptr) && (NULL != *jmfcDiskCacheTierType_val_ptr_ptr));
   netsnmp_assert( NULL != jmfcDiskCacheTierType_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:jmfcDiskCacheTable:jmfcDiskCacheTierType_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the jmfcDiskCacheTierType data.
 * copy (* jmfcDiskCacheTierType_val_ptr_ptr ) data and (* jmfcDiskCacheTierType_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for jmfcDiskCacheTierType data
     */
    if ((NULL == (* jmfcDiskCacheTierType_val_ptr_ptr )) ||
        ((* jmfcDiskCacheTierType_val_ptr_len_ptr ) <
         (rowreq_ctx->data.jmfcDiskCacheTierType_len* sizeof(rowreq_ctx->data.jmfcDiskCacheTierType[0])))) {
        /*
         * allocate space for jmfcDiskCacheTierType data
         */
        (* jmfcDiskCacheTierType_val_ptr_ptr ) = malloc(rowreq_ctx->data.jmfcDiskCacheTierType_len* sizeof(rowreq_ctx->data.jmfcDiskCacheTierType[0]));
        if(NULL == (* jmfcDiskCacheTierType_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* jmfcDiskCacheTierType_val_ptr_len_ptr ) = rowreq_ctx->data.jmfcDiskCacheTierType_len* sizeof(rowreq_ctx->data.jmfcDiskCacheTierType[0]);
    memcpy( (* jmfcDiskCacheTierType_val_ptr_ptr ), rowreq_ctx->data.jmfcDiskCacheTierType, rowreq_ctx->data.jmfcDiskCacheTierType_len* sizeof(rowreq_ctx->data.jmfcDiskCacheTierType[0]) );

    return MFD_SUCCESS;
} /* jmfcDiskCacheTierType_get */

/*---------------------------------------------------------------------
 * JUNIPER-MFC-MIB::jmfcDiskCacheEntry.jmfcDiskCacheState
 * jmfcDiskCacheState is subid 7 of jmfcDiskCacheEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2636.1.2.1.2.1.1.1.7
 * Description:
A disk cache can be in either of the following states.
		1. Cache disabled
		   In this case, the disk is not used as a cache. No reads or
		   writes are done to the disk.
		2. Cache enabled.
		   In this state, the disk is used as a cache.

		TODO: Tell me more!
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is OCTETSTR (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.
 */
/**
 * Extract the current value of the jmfcDiskCacheState data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param jmfcDiskCacheState_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param jmfcDiskCacheState_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by jmfcDiskCacheState.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*jmfcDiskCacheState_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update jmfcDiskCacheState_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
jmfcDiskCacheState_get( jmfcDiskCacheTable_rowreq_ctx *rowreq_ctx, char **jmfcDiskCacheState_val_ptr_ptr, size_t *jmfcDiskCacheState_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != jmfcDiskCacheState_val_ptr_ptr) && (NULL != *jmfcDiskCacheState_val_ptr_ptr));
   netsnmp_assert( NULL != jmfcDiskCacheState_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:jmfcDiskCacheTable:jmfcDiskCacheState_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the jmfcDiskCacheState data.
 * copy (* jmfcDiskCacheState_val_ptr_ptr ) data and (* jmfcDiskCacheState_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for jmfcDiskCacheState data
     */
    if ((NULL == (* jmfcDiskCacheState_val_ptr_ptr )) ||
        ((* jmfcDiskCacheState_val_ptr_len_ptr ) <
         (rowreq_ctx->data.jmfcDiskCacheState_len* sizeof(rowreq_ctx->data.jmfcDiskCacheState[0])))) {
        /*
         * allocate space for jmfcDiskCacheState data
         */
        (* jmfcDiskCacheState_val_ptr_ptr ) = malloc(rowreq_ctx->data.jmfcDiskCacheState_len* sizeof(rowreq_ctx->data.jmfcDiskCacheState[0]));
        if(NULL == (* jmfcDiskCacheState_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* jmfcDiskCacheState_val_ptr_len_ptr ) = rowreq_ctx->data.jmfcDiskCacheState_len* sizeof(rowreq_ctx->data.jmfcDiskCacheState[0]);
    memcpy( (* jmfcDiskCacheState_val_ptr_ptr ), rowreq_ctx->data.jmfcDiskCacheState, rowreq_ctx->data.jmfcDiskCacheState_len* sizeof(rowreq_ctx->data.jmfcDiskCacheState[0]) );

    return MFD_SUCCESS;
} /* jmfcDiskCacheState_get */

/*---------------------------------------------------------------------
 * JUNIPER-MFC-MIB::jmfcDiskCacheEntry.jmfcDiskCacheBlockSize
 * jmfcDiskCacheBlockSize is subid 8 of jmfcDiskCacheEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2636.1.2.1.2.1.1.1.8
 * Description:
The block size configured for this disk cache.

		For example, a value of 2048 denotes 2MBytes.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the jmfcDiskCacheBlockSize data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param jmfcDiskCacheBlockSize_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
jmfcDiskCacheBlockSize_get( jmfcDiskCacheTable_rowreq_ctx *rowreq_ctx, u_long * jmfcDiskCacheBlockSize_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != jmfcDiskCacheBlockSize_val_ptr );


    DEBUGMSGTL(("verbose:jmfcDiskCacheTable:jmfcDiskCacheBlockSize_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the jmfcDiskCacheBlockSize data.
 * copy (* jmfcDiskCacheBlockSize_val_ptr ) from rowreq_ctx->data
 */
    (* jmfcDiskCacheBlockSize_val_ptr ) = rowreq_ctx->data.jmfcDiskCacheBlockSize;

    return MFD_SUCCESS;
} /* jmfcDiskCacheBlockSize_get */

/*---------------------------------------------------------------------
 * JUNIPER-MFC-MIB::jmfcDiskCacheEntry.jmfcdiskCacheTotalSize
 * jmfcdiskCacheTotalSize is subid 9 of jmfcDiskCacheEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2636.1.2.1.2.1.1.1.9
 * Description:
The total cache-able size of the disk. This does not include the
		space reserved for meta-data.

		For example, a value of 536870912 indicates a disk size of
		512 MegaBytes of cache space.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the jmfcdiskCacheTotalSize data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param jmfcdiskCacheTotalSize_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
jmfcdiskCacheTotalSize_get( jmfcDiskCacheTable_rowreq_ctx *rowreq_ctx, u_long * jmfcdiskCacheTotalSize_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != jmfcdiskCacheTotalSize_val_ptr );


    DEBUGMSGTL(("verbose:jmfcDiskCacheTable:jmfcdiskCacheTotalSize_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the jmfcdiskCacheTotalSize data.
 * copy (* jmfcdiskCacheTotalSize_val_ptr ) from rowreq_ctx->data
 */
    (* jmfcdiskCacheTotalSize_val_ptr ) = rowreq_ctx->data.jmfcdiskCacheTotalSize;

    return MFD_SUCCESS;
} /* jmfcdiskCacheTotalSize_get */

/*---------------------------------------------------------------------
 * JUNIPER-MFC-MIB::jmfcDiskCacheEntry.jmfcDiskCacheBlocksUsed
 * jmfcDiskCacheBlocksUsed is subid 10 of jmfcDiskCacheEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2636.1.2.1.2.1.1.1.10
 * Description:
The number of blocks used for storing objects
		that are cached. Objects that have expired are NOT
		accounted for.

		TODO: Get this clarified.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is GAUGE (based on perltype GAUGE)
 * The net-snmp type is ASN_GAUGE. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the jmfcDiskCacheBlocksUsed data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param jmfcDiskCacheBlocksUsed_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
jmfcDiskCacheBlocksUsed_get( jmfcDiskCacheTable_rowreq_ctx *rowreq_ctx, u_long * jmfcDiskCacheBlocksUsed_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != jmfcDiskCacheBlocksUsed_val_ptr );


    DEBUGMSGTL(("verbose:jmfcDiskCacheTable:jmfcDiskCacheBlocksUsed_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the jmfcDiskCacheBlocksUsed data.
 * copy (* jmfcDiskCacheBlocksUsed_val_ptr ) from rowreq_ctx->data
 */
    (* jmfcDiskCacheBlocksUsed_val_ptr ) = rowreq_ctx->data.jmfcDiskCacheBlocksUsed;

    return MFD_SUCCESS;
} /* jmfcDiskCacheBlocksUsed_get */

/*---------------------------------------------------------------------
 * JUNIPER-MFC-MIB::jmfcDiskCacheEntry.jmfcDiskCacheFreeSpace
 * jmfcDiskCacheFreeSpace is subid 11 of jmfcDiskCacheEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.2636.1.2.1.2.1.1.1.11
 * Description:
Total free space that is available for caching objects.
		Objects that have expired are also accounted as space that
		is free and available for caching.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is GAUGE (based on perltype GAUGE)
 * The net-snmp type is ASN_GAUGE. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the jmfcDiskCacheFreeSpace data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param jmfcDiskCacheFreeSpace_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
jmfcDiskCacheFreeSpace_get( jmfcDiskCacheTable_rowreq_ctx *rowreq_ctx, u_long * jmfcDiskCacheFreeSpace_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != jmfcDiskCacheFreeSpace_val_ptr );


    DEBUGMSGTL(("verbose:jmfcDiskCacheTable:jmfcDiskCacheFreeSpace_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the jmfcDiskCacheFreeSpace data.
 * copy (* jmfcDiskCacheFreeSpace_val_ptr ) from rowreq_ctx->data
 */
    (* jmfcDiskCacheFreeSpace_val_ptr ) = rowreq_ctx->data.jmfcDiskCacheFreeSpace;

    return MFD_SUCCESS;
} /* jmfcDiskCacheFreeSpace_get */



/** @} */
