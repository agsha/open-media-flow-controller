/*
 * (C) Copyright 2011-12  Juniper Networks, Inc
 *
 * This file implements a daemon that reads SMART data from disks
 *
 * Author: Srihari MS
 *
 */

#include <sys/types.h>
#include <stdint.h>
#include <errno.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <assert.h>
#include "nkn_stat.h"
#include "smart_attr.h"

#define SMART_SCRIPT "/opt/nkn/bin/get_smart_data.sh"
#define SMART_OUT "/nkn/tmp/smart"
#define SMART_IN "/nkn/tmp/smart.data"
#define DISK_INFO "/config/nkn/diskcache-startup.info"
#define DEF_CONF_FILE "/config/nkn/nsmartd.conf"

#define SECS_IN_MIN 60
#define MIN_IN_HOUR 60
#define MAX_DISKS   64

/* List of drive models that need throtling of writes */
#define MAX_MODELS 32
typedef struct nsmart_models {
    char model[64];
    int  pe_cycles;
}nsmart_models_t;

nsmart_models_t sup_models[MAX_MODELS];

int num_models = 0;

/* Strcture Definitions */
typedef struct {
    char	model[64];
    char	serial[64];
    char	fw_ver[32];
    int		size_in_gb;
    int		need_throttle;
    int		pe_cycles;
    int		raw_read_err_rate_1;
    int		realloc_sec_cnt_5;
    uint64_t	power_on_secs_9;
    int		power_cycle_count_12;
    int		read_soft_err_rate_13;
    int		gb_erased_100;
    int		resv_block_count_170;
    int		prog_fail_count_171;
    int		erase_fail_count_172;
    int		unexp_power_loss_count_174;
    int		wear_level_count_177;
    int		prog_fail_count_181;
    int		erase_fail_count_182;
    int		end_to_end_err_184;
    int		uncorrectable_errs_reported_187;
    int		temp_in_C_194;
    int		hw_err_recov_195;
    int		realloc_event_count_196;
    int		offline_uncorrectable_198;
    int		udma_crc_err_199;
    int		soft_read_err_rate_201;
    int		soft_ecc_correction_204;
    int		head_amplitude_230;
    int		ssd_life_left_231;
    int		avl_resv_space_232;
    int		media_wearout_233;
    int		unknown_attr_234;
    int		unknown_attr_235;
    int		total_writes_241;
    int		total_read_242;
}dev_smart_t;

typedef struct {
    char dev_name[64];
    dev_smart_t	smart;
    int		counters_added;
    int		init_done;
}disk_info_t;

/* Global Variables */
disk_info_t disks[MAX_DISKS];
int glob_num_disks;
int run_as_daemon = 0;
int wait_mins = 60;
int simulate = 0;
int first = 1;

/*Function  Prototypes */
extern void config_and_run_counter_update(void );

static void
read_smart_values_from_file(disk_info_t *dinfo)
{
    FILE* fp = NULL;
    dev_smart_t* smart;
    char buf[1024], fname[1024], *p, *dev, *name;
    char field[256], equals[8], value[256];
    int line_no = 0, ret;
    uint64_t power_on_secs = 0;
    int gb_erased = 0;

    dev = dinfo->dev_name;
    smart = &dinfo->smart;

    name = strrchr(dev, '/');
    if (!name)
        return;
    name++;

    snprintf(fname, 512, "%s.%s", SMART_IN, name);
    fp = fopen(fname, "r");
    if (!fp) {
	fprintf(stderr, "Unable to open data file %s\n", fname);
	return;
    }

    while (!feof(fp)) {

	if (fgets(buf, 1024, fp) == NULL)
	    break;

	line_no++;
	/* Skip lines that begib with ;, # */
	if ( (buf[0] == '\n') || (buf[0] == 35) || (buf[0] == ';') ) {
	    continue;
        }

	ret = sscanf(buf, "%s%s%s", field, equals, value);
        if ( (ret < 3) || (equals[0] != '=') ) {
            fprintf(stderr, "read_config_file: Invalid line %d in"
		    "config file %s. Usage: field = value\n", line_no, fname);
           return;
        }

	/* model, pe_cycles should be in sequence in the config file*/
	if (!strcmp(field, POWER_ON_SECS_9)) {
	    power_on_secs = strtoul(value, NULL, 10);
	} else if (!strcmp(field, GB_ERASED_100)) {
	    gb_erased = strtoul(value, NULL, 10);
	}
    }

    smart->power_on_secs_9 = power_on_secs;
    smart->gb_erased_100 = gb_erased;
    fclose(fp);

}   /* read_smart_values_from_file */


static int
get_smart_details(disk_info_t *dinfo)
{
    char smart_cmd[256], out_file[128];
    char attr9[64], drive_size[16];
    char *name, *dev;
    FILE* fp = NULL;
    dev_smart_t* smart;
    int hour = 0, min = 0, sec = 0;
    int ret = 0, i;

    /* If throttling not required, do not issue smartctl command */
    if (dinfo->init_done && !dinfo->smart.need_throttle)
	return 0;

    /* Run the 'get_smart_data.sh' to read the SMART attributes
     * from the disk
     */
    dev = dinfo->dev_name;
    smart = &dinfo->smart;

    name = strrchr(dev, '/');
    if (!name)
	return -1;
    name++;

    snprintf(out_file, 128, "%s.%s", SMART_OUT, name);
    snprintf(smart_cmd, 256, "%s %s %s", SMART_SCRIPT, dev, out_file);

    ret = system(smart_cmd);
    if (ret) {
	fprintf(stderr, "Unable to get SMART data for device %s\n", dev);
	return ret;
    }

    /* Read the SMART values from the output file generated by the script */
    fp = fopen(out_file, "r");
    if (!fp) {
	ret = -errno;
	fprintf(stderr, "Unable to open %s (err:%d)\n", out_file, ret);
	return ret;
    }

    fscanf(fp, "%s\n%s\n%s\n%s\n%d\n%d\n%s\n%d\n%d\n"
		"%d\n%d\n%d\n%d\n%d\n%d\n%d\n%d\n%d\n%d\n"
		"%d\n%d\n%d\n%d\n%d\n%d\n%d\n%d\n%d\n%d\n"
		"%d\n%d\n%d\n%d\n%d\n",
		(char *)&smart->model,
		(char *)&smart->serial,
		(char *)&smart->fw_ver,
		(char *)drive_size,
		(int *)&smart->raw_read_err_rate_1,
		(int *)&smart->realloc_sec_cnt_5,
		(char *)attr9,
		(int *)&smart->power_cycle_count_12,
		(int *)&smart->read_soft_err_rate_13,
		(int *)&smart->gb_erased_100,
		(int *)&smart->resv_block_count_170,
		(int *)&smart->prog_fail_count_171,
		(int *)&smart->erase_fail_count_172,
		(int *)&smart->unexp_power_loss_count_174,
		(int *)&smart->wear_level_count_177,
		(int *)&smart->prog_fail_count_181,
		(int *)&smart->erase_fail_count_182,
		(int *)&smart->end_to_end_err_184,
		(int *)&smart->uncorrectable_errs_reported_187,
		(int *)&smart->temp_in_C_194,
		(int *)&smart->hw_err_recov_195,
		(int *)&smart->realloc_event_count_196,
		(int *)&smart->offline_uncorrectable_198,
		(int *)&smart->udma_crc_err_199,
		(int *)&smart->soft_read_err_rate_201,
		(int *)&smart->soft_ecc_correction_204,
		(int *)&smart->head_amplitude_230,
		(int *)&smart->ssd_life_left_231,
		(int *)&smart->avl_resv_space_232,
		(int *)&smart->media_wearout_233,
		(int *)&smart->unknown_attr_234,
		(int *)&smart->unknown_attr_235,
		(int *)&smart->total_writes_241,
		(int *)&smart->total_read_242);

    sscanf(attr9,"%dh+%dm+%ds", &hour, &min, &sec);
    smart->power_on_secs_9 = (hour*MIN_IN_HOUR + min) * SECS_IN_MIN + sec;

    if (!dinfo->init_done) {
	for (i = 0; i < num_models; i++) {
	    if (strstr(smart->model, sup_models[i].model)) {
		smart->size_in_gb = atoi(drive_size);
		smart->need_throttle = 1;
		smart->pe_cycles =  sup_models[i].pe_cycles;
	    }
	}
	dinfo->init_done = 1;
    }
    fclose(fp);

    /* Override smartctl values from a data file, if config option
     * is set to simulate throttling */
    if (simulate)
	read_smart_values_from_file(dinfo);

    /* Sleep for 5 mins before issuing the next smartctl command.
     * Issuing smartctl back to back is affecting the response time
     * of the MFC */
    if (!first)
	sleep(300);
    return 0;
}   /* get_smart_details */

static int
get_disk_list(void)
{
    FILE *fp = NULL;
    char dev[64];
    int ret, disk_num = 0;

    /* Get the disks from the 'diskcache-startup.info' file */
    fp = fopen(DISK_INFO, "r");
    if (!fp) {
	ret = -errno;
	fprintf(stderr, "Unable to open %s (err:%d)\n", DISK_INFO, ret);
	return ret;
    }

    while(1){
        ret = fscanf(fp, "%*s  %*s  %*s  %s  %*s  %*s  %*s  %*s\n", dev);
        if (ret && ret != EOF) {
	    strncpy(disks[disk_num].dev_name, dev, 64);
	    disk_num++;
	} else {
            break;
	}
    }
    fclose(fp);

    return disk_num;
}   /* get_disk_list */

static void
daemonize(void)
{

    if (0 != fork())
	exit(0);

    if (-1 == setsid())
	exit(0);

    signal(SIGHUP, SIG_IGN);

    if (0 != fork())
	exit(0);

    /* Do not chdir when this processis managed by the PM
     * if (chdir("/") != 0) exit(0);
     */
}   /* daemonize */

static void
add_disk_attrs(int num)
{
    char* name;
    int i = num;

    if (disks[i].counters_added)
	return;

	name = strrchr(disks[i].dev_name, '/');
	if (!name)
	    return ;
	name++;

    nkn_mon_add(NEED_THROTTLE, name,
		&disks[i].smart.need_throttle,4);
    nkn_mon_add(DRIVE_SIZE_IN_GB, name,
		&disks[i].smart.size_in_gb,4);
    nkn_mon_add(PE_CYCLES, name,
		&disks[i].smart.pe_cycles, 4);
    nkn_mon_add(RAW_READ_ERR_RATE_1, name,
		&disks[i].smart.raw_read_err_rate_1,4);
    nkn_mon_add(REALLOC_SEC_CNT_5, name,
		&disks[i].smart.realloc_sec_cnt_5, 4);
    nkn_mon_add(POWER_ON_SECS_9, name,
		&disks[i].smart.power_on_secs_9, 8);
    nkn_mon_add(POWER_CYCLE_COUNT_12, name,
		&disks[i].smart.power_cycle_count_12, 4);
    nkn_mon_add(READ_SOFT_ERR_RATE_13, name,
		&disks[i].smart.read_soft_err_rate_13, 4);
    nkn_mon_add(GB_ERASED_100, name,
		&disks[i].smart.gb_erased_100, 4);
    nkn_mon_add(TEMP_IN_C_194, name,
		&disks[i].smart.temp_in_C_194, 4);
    nkn_mon_add(RESV_BLOCK_COUNT_170, name,
		&disks[i].smart.resv_block_count_170, 4);
    nkn_mon_add(PROG_FAIL_COUNT_171, name,
		&disks[i].smart.prog_fail_count_171, 4);
    nkn_mon_add(ERASE_FAIL_COUNT_172, name,
		&disks[i].smart.erase_fail_count_172, 4);
    nkn_mon_add(UNEXP_POWER_LOSS_COUNT_174, name,
		&disks[i].smart.unexp_power_loss_count_174, 4);
    nkn_mon_add(WEAR_LEVEL_COUNT_177, name,
		&disks[i].smart.wear_level_count_177, 4);
    nkn_mon_add(PROG_FAIL_COUNT_181, name,
		&disks[i].smart.prog_fail_count_181, 4);
    nkn_mon_add(ERASE_FAIL_COUNT_182, name,
		&disks[i].smart.erase_fail_count_182, 4);
    nkn_mon_add(END_TO_END_ERR_184, name,
		&disks[i].smart.end_to_end_err_184, 4);
    nkn_mon_add(UNCORRECTABLE_ERRS_REPORTED_187, name,
		&disks[i].smart.uncorrectable_errs_reported_187, 4);
    nkn_mon_add(TEMP_IN_C_194, name,
		&disks[i].smart.temp_in_C_194, 4);
    nkn_mon_add(HW_ERR_RECOV_195, name,
		&disks[i].smart.hw_err_recov_195, 4);
    nkn_mon_add(REALLOC_EVENT_COUNT_196, name,
		&disks[i].smart.realloc_event_count_196, 4);
    nkn_mon_add(OFFLINE_UNCORRECTABLE_198, name,
		&disks[i].smart.offline_uncorrectable_198, 4);
    nkn_mon_add(UDMA_CRC_ERR_199, name,
		&disks[i].smart.udma_crc_err_199, 4);
    nkn_mon_add(SOFT_READ_ERR_RATE_201, name,
		&disks[i].smart.soft_read_err_rate_201, 4);
    nkn_mon_add(SOFT_ECC_CORRECTION_204, name,
		&disks[i].smart.soft_ecc_correction_204, 4);
    nkn_mon_add(HEAD_AMPLITUDE_230, name,
		&disks[i].smart.head_amplitude_230, 4);
    nkn_mon_add(SSD_LIFE_LEFT_231, name,
		&disks[i].smart.ssd_life_left_231, 4);
    nkn_mon_add(AVL_RESV_SPACE_232, name,
		&disks[i].smart.avl_resv_space_232, 4);
    nkn_mon_add(MEDIA_WEAROUT_233, name,
		&disks[i].smart.media_wearout_233, 4);
    nkn_mon_add(UNKNOWN_ATTR_234, name,
		&disks[i].smart.unknown_attr_234, 4);
    nkn_mon_add(UNKNOWN_ATTR_235, name,
		&disks[i].smart.unknown_attr_235, 4);
    nkn_mon_add(TOTAL_WRITES_241, name,
		&disks[i].smart.total_writes_241, 4);
    nkn_mon_add(TOTAL_READ_242, name,
		&disks[i].smart.total_read_242, 4);

    disks[i].counters_added = 1;

    return ;
}   /* add_disk_attrs */

static void
read_config_file(const char *fname)
{
    FILE* fp = NULL;
    char buf[1024], *p;
    char field[256], equals[8], value[256];
    int line_no = 0, ret;

    fp = fopen(fname, "r");
    if (!fp) {
	fprintf(stderr, "Unable to open config file %s\n", fname);
	fprintf(stderr, "nsmartd will run with default settings\n");
	return;
    }

    while (!feof(fp)) {

	if (fgets(buf, 1024, fp) == NULL)
	    break;

	line_no++;
	/* Skip lines that begib with ;, # */
	if ( (buf[0] == '\n') || (buf[0] == 35) || (buf[0] == ';') ) {
	    continue;
        }

	ret = sscanf(buf, "%s%s%s", field, equals, value);
        if ( (ret < 3) || (equals[0] != '=') ) {
            fprintf(stderr, "read_config_file: Invalid line %d in"
		    "config file %s. Usage: field = value\n", line_no, fname);
           return;
        }

	/* model, pe_cycles should be in sequence in the config file*/
	if (!strcmp(field, "daemon")) {
	    run_as_daemon = atoi(value);
	} else if (!strcmp(field, "frequency")) {
	    wait_mins = atoi(value);
	} else if (!strcmp(field, "simulate")) {
	    simulate = atoi(value);
	} else if (!strcmp(field, "model")) {
	    if (num_models >= MAX_MODELS)
		assert(0);
	    strcpy(sup_models[num_models].model, value);
	} else if (!strcmp(field, "pe_cycles")) {
	    sup_models[num_models].pe_cycles = atoi(value);
	    num_models++;
	}
    }

    fclose(fp);
}   /* read_config_file */


static void
print_usage(void)
{
    fprintf(stderr, "Usage: nsmartd [config file]\n");
    exit(0);
}   /* print_usage */

int
main(int argc, char* argv[])
{
    int i;
    char buf[128];

    if (argc > 2)
	print_usage();

    if (argc == 2)
	read_config_file(argv[1]);
    else
	read_config_file(DEF_CONF_FILE);

    if (run_as_daemon)
	daemonize();

    /* Initialize the nkncnt library that manages the counters */
    config_and_run_counter_update();

    /* Get the list of disks to be manage */
    glob_num_disks = get_disk_list();
    if (glob_num_disks <= 0) {
	fprintf(stderr, "Did not find any disks\n");
	return -1;
    }

    while(1) {

	/* Read the SMART data for all the disks */
	for(i=0;i<glob_num_disks;i++) {
	    get_smart_details(&disks[i]);


	    add_disk_attrs(i);
#if 0
	    printf("Device : %s\nModel : %s\nSerial : %s\nFW Vers : %s\n",
			disks[i].dev_name,
			disks[i].smart.model,
			disks[i].smart.serial,
			disks[i].smart.fw_ver);

	    printf("Power on Sec : %ld\nGB Erased : %d\nTemperature : %d\n\n",
			disks[i].smart.power_on_secs_9,
			disks[i].smart.gb_erased_100,
			disks[i].smart.temp_in_C_194);
#endif
	};
	/* Remember if we walked through all the disks once */
	if (first)
	    first = 0;
	sleep(wait_mins * 60);
    }
    return 0;
}   /* main */
