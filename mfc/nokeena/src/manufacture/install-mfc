#! /bin/bash
#
DRY_RUN=no
CACHE_OPT=unset
USE_MODEL=none
MANUF_DIR=none
IMAGE_LOCATION_1=/
IMAGE_LOCATION_2=/mnt/cdrom/
MFG_LOG_FILE=/tmp/manufacture.log
LOGF=/tmp/install-mfc.log
M_PID=
T_PID=

# root.profile which executes when the user logs in as root,
# executes interactive-install.sh.
# Interactive-install.sh figuers out where in the install process we are,
# and if installing from media or PXE and runs these as needed:
#  -- overlay-manuf.sh  (when non-PXE)
#  -- pxe-install (when PXE)
#  -- pre-install.sh

# Now pre-install.sh runs install-mfc which runs post-install.sh
# The return value from pre-install.sh is either from it's own code
# or the non-zero return code from install-mfc or post-install.sh.
# When the return value is the following, interactive-install.sh does:
#  0 thru 8 -- prints "Install returned <value>" and then exits with 0.
#  9 -- Silently exits with 10.
#  10 or above, it exits with than value.
# If interactive-install.sh is trying to reboot or halt the system it returns 0
# or if there is some very odd failure happening.

# Now when root.profile gets the return value from interactive-install.sh it does:
#  0-8 -- Prints "Login as root to install MFC" and exits.
#  9   -- Exits.
# 10   -- Prints message about using exit to start installation over,
#         and to use the reboot or halt commands to do those actions,
#         and then it goes to a shell prompt.
# >10  -- Goes to a shell prompt
#
# When root.profile exits, a new login prompt is displayed by the system.
# When the user exits from the shell prompt, a new login prompt is displayed.


date > ${LOGF}
echo "${@}" >> ${LOGF}
rm -f /tmp/failure.txt

trap_int_handler()
{
  echo
  echo "(Interrupt)"
  echo
  [ ! -z "${M_PID}" ] && kill ${M_PID}
  [ ! -z "${T_PID}" ] && kill ${T_PID}
  exit 1
}
trap "trap_int_handler" INT

Fail_Print()
{
  echo "${@}"
  echo "${@}" >> /tmp/failure.txt
  echo "${@}" >> ${LOGF}
}
Log()
{
  echo "${@}" >> ${LOGF}
}
Log_Print()
{
  echo "${@}"
  echo "${@}" >> ${LOGF}
}

# Supress kernel warnings being printed to the console.
# Lots of them are generated by the commands that manufacture.sh
# (and writeimage.sh), and although they are benign and expected
# it alarms customers, so we need to suppress them.
killall klogd
sleep 1
/sbin/klogd -c 4

##################################################
# When pxe-install was used it:
# 1: Put the image URL in the file /tmp/img.url
# 2: Downloaded and installed the manufacture overlay
# When booted from media, then overlay-manuf.sh
# was automatically run, and it did:
# 0: Made sure the media is mounted.
# 1: Put the image filename in the file /tmp/img.filename
# 2: Installed the manufacture overlay.

# When installing from media, then the file /tmp/img.filename must exist.
# When pxe-install was run, then /tmp/img.url must exist.
if [ ! -f /tmp/img.filename -a ! -f /tmp/img.url ] ; then
  Fail_Print No install file found.
  Fail_Print If PXE booted, then pxe-install was not run.
  Fail_Print If booted from cdrom or usb drive, then invalid media.
  sleep 10
  exit 1
fi
if [ "_${EULA}" = "_skip" ] ; then
  EULA_ANS=accepted-eula
elif [ -f  /tmp/eula_response.txt ] ; then
  EULA_ANS=`cat /tmp/eula_response.txt`
else
  EULA_ANS="no"
  EULA_FILE=/etc/eula.txt
  if [ ! -f ${EULA_FILE} ] ; then
      Fail_Print Missing file ${EULA_FILE}
      Fail_Print Cannot continue
      sleep 10
      exit 1
  fi
fi
MY_DIR=`dirname "${0}"`

CRF_FILE=/etc/customer_rootflop.sh
if [ ! -f ${CRF_FILE} ] ; then
  Fail_Print Missing files.
  Fail_print If PXE booted, then pxe-install was not run.
  Fail_print If booted from cdrom or usb drive, then invalid media.
  sleep 10
  exit 1
fi
# Dot it in so we call the "manufacture_graft_1 functions to get the values of:
# Example:   CFG_MODEL_CHOICES="normal mirror cache vxa1 vxa2 demo8g2 demo32g1 cloudvm cloudrc"
. ${CRF_FILE}
manufacture_graft_1
CFG_CHOICE_LIST=,`echo ${CFG_MODEL_CHOICES} | sed -e "s/ /,/g"`,

Log CFG_MODEL_CHOICES=${CFG_MODEL_CHOICES}
Log CFG_CHOICE_LIST=${CFG_CHOICE_LIST}

# Filter out the device that has the cdrom or usb drive mounted.
SKIP1=`df /mnt/cdrom | grep /mnt/cdrom | cut -f1 -d' ' | cut -f3 -d/`
SKIP2=`df / | grep '/$' | cut -f1 -d' ' | cut -f3 -d/`
[ -z "${SKIP1}" ] && SKIP1=zzzzzzzzzzzzzzzzzzzz
[ -z "${SKIP2}" ] && SKIP2=zzzzzzzzzzzzzzzzzzzz


F=/tmp/usage.txt
rm -f ${F}
UL() { echo "${@}" >> ${F} ; }

Usage()
{
  [ "${SHOW_USAGE}" = "no" ] && return
  SYNTAX_LINE="[--dryrun]"
  if [ "${SHOW_CACHE_OPTIONS}" = "yes" ] ; then
    SYNTAX_LINE="${SYNTAX_LINE} init-cache|keep-cache"
    UL "You must specify either 'init-cache' or 'keep-cache'"
  fi
  UL "You must specify 'root-dev=...'"
  UL "On VXA machine to use eUSB you must specify 'eusb-dev=...'"
  SYNTAX_LINE="${SYNTAX_LINE} [Other Settings]"
  UL "Other Settings include:"
  UL "accept-eula"
  Help_Manuf_Opt all >> ${F}
  UL "Must specify disk-layout= with one of these: ${CFG_MODEL_CHOICES}"
  UL "NOTE: You must specify disk-layout= with one of these: ${CFG_MODEL_CHOICES}"
  SYNTAX_LINE="${SYNTAX_LINE} [eth-setup <args>]"
  UL "On the end of the command line you can optionally add the 'eth-setup' command"
  UL "so that you can use a single command line to do install-mfd and eth-setup."
  UL "To get the syntax help for that command, just type 'eth-setup' at the prompt."
  echo
  echo Utility to install MFC from an image file.
  echo Syntax:
  echo "${SYNTAX_LINE}"
  cat ${F}
  echo Syntax:
  echo "${SYNTAX_LINE}"
}

ETH_SET_CMDLINE=

# The install-options.txt file the following (and others) from the boot command line:
IOP_MFG_OPT=
# See S30_mfc_install for format and explanations.
if [ -f /tmp/install-options.txt ] ; then
  . /tmp/install-options.txt
fi
################################################################
# Dot in the file that has the functions Parse_Manuf_Opt() and Help_Manuf_Opt()
# The function Parse_Manuf_Opt sets as needed:
#  OPT_RDISK_DEV
#  OPT_RDISK_PDEV
#  OPT_EDISK_DEV
#  OPT_EDISK_PDEV
#
#  OPT_DISK_LAYOUT
#  OPT_BOOT_FROM
#  OPT_MAX_FS
#
#  OPT_BUF_ISIZE
#  OPT_BUF_GW
#  OPT_BUF_MAX
#
#  OPT_CACHE_ISIZE
#  OPT_CACHE_GW
#  OPT_CACHE_MAX
#  OPT_CACHEFS_PERCENT
#
#  OPT_LOG_ISIZE
#  OPT_LOG_GW
#  OPT_LOG_MAX
#
#  OPT_COREDUMP_ISIZE
#  OPT_COREDUMP_GW
#  OPT_COREDUMP_MAX
#
#  OPT_ROOT_ISIZE
#  OPT_ROOT_GW
#  OPT_ROOT_MAX
#
#  OPT_CONFIG_ISIZE
#  OPT_CONFIG_GW
#  OPT_CONFIG_MAX
#
#  OPT_VAR_ISIZE
#  OPT_VAR_GW
#  OPT_VAR_MAX
#
################################################################
. /sbin/parse_manuf_opt.sh

XOPT=
SHOW_CACHE_OPTIONS=yes
SHOW_USAGE=yes
for ITEM in ${*}
do
    if [ ! -z "${ETH_SET_CMDLINE}" ] ; then
      ETH_SET_CMDLINE="${ETH_SET_CMDLINE} ${ITEM}"
      continue
    fi
    [ -z "${ITEM}" ] && break
    case ${ITEM} in
    -x)       XOPT="-x" ; continue ;;
    --nocacheusage) SHOW_CACHE_OPTIONS=no ; continue ;;
    --nousage)      SHOW_USAGE=no; continue ;;
    --dryrun) DRY_RUN=dry_run ; continue ;;
    *-cache)  CACHE_OPT=${ITEM} ; continue ;;
    -*|_help)  Usage; exit 9 ;;
    accept-eula)  EULA_ANS="accepted-eula" ; continue ;;
    eth-setup)    ETH_SET_CMDLINE=" "      ; continue ;;
    disk-layout=*|root-dev=*|hdd2-dev=*|eusb-dev=*|boot-from=*|max-fs=*|buf-part=*|cache-part=*|log-part=*|coredump-part=*|root-part=*|config-part=*|var-part=*)
      Parse_Manuf_Opt "${ITEM}"
      if [ "${INVALID_FLAG}" = "invalid" ] ; then
        A=`echo "${ITEM}" | cut -f1 -d=`
        B=`echo "${ITEM}" | cut -f2- -d=`
        echo
        if [ "${A}" = "${B}" ] ; then
          Fail_Print The ${A} setting is not valid
        else
          Fail_Print The ${A} setting is not valid: "${B}"
        fi
        Usage
        exit 2
      fi
      continue ;;
    esac
    if [ "${SHOW_USAGE}" = "yes" ] ; then
      Fail_Print Invalid command line parameter ${ITEM}
      Usage
    else
      Fail_Print Internal error,  unknown install-mfc parameter ${ITEM}
    fi
    exit 2
done
dmesg -c > /tmp/dmesg-before-mfc-install.txt

ERROR_FOUND=noerror
ERROR1=
ERROR2=
ERROR3=
ERROR4=

########################################################################
# init-cache or keep-cache
########################################################################
case ${CACHE_OPT} in
keep-cache) ;;
init-cache) ;;
*)  ERROR2="Error, must specify either keep-cache or init-cache"
    ERROR_FOUND=error
    ;;
esac

########################################################################
# Disk layout model name
########################################################################
if [ ! -z "${OPT_DISK_LAYOUT}" ] ; then
  echo " ${CFG_MODEL_CHOICES} " | grep " ${OPT_DISK_LAYOUT} " > /dev/null
  [ ${?} -eq 0 ] && USE_MODEL=${OPT_DISK_LAYOUT}
fi

if [ "${USE_MODEL}" = "none" ] ; then
    ERROR1="Error, must specify a filesystem layout model name on the command line"
    ERROR_FOUND=error
fi

Create_Disk_Devs()
{
  # Create the device nodes for the specified HDD type device.
  DNAME=`basename ${1}`
  if [ ! -f /sys/block/${DNAME}/dev ] ; then
    echo No such device ${DNAME}
    return
  fi
  MAJ_NUM=`cat /sys/block/${DNAME}/dev | cut -f1 -d:`
  MIN_NUM=`cat /sys/block/${DNAME}/dev | cut -f2 -d:`
  for DEV_NUM in 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
  do
    [ -b  /dev/${DNAME}${DEV_NUM} ] && continue
    mknod /dev/${DNAME}${DEV_NUM} b ${MAJ_NUM} ${MIN_NUM}
    if [ ${?} -ne 0 ] ; then
      echo Error, failed to create device node /dev/${DNAME}${DEV_NUM}
      echo No more inodes?
    fi
    MIN_NUM=$((MIN_NUM + 1));
  done
}

########################################################################
# Root device name
# The *DISK_DEV device is the one for the whole drive.
# The *DISK_PDEV to the device name that use to create partition device
# names by appending a partition number.  For some devices it is the
# same as the matching *DISK_DEV device name.
########################################################################
USING_EUSB=no-eusb
rm -f /tmp/raid_disk_info.txt
if [ -z "${OPT_RDISK_DEV}" ] ; then
    ERROR3="Error, The device name for the root drive was not specified."
elif [ -z "${OPT_BOOT_FROM}" ] ; then
    # Default to root drive is the combined boot+OS+data drive.
    FIRST_DISK_DEV=${OPT_RDISK_DEV}
    FIRST_DISK_PDEV=${OPT_RDISK_PDEV}
    Create_Disk_Devs ${FIRST_DISK_PDEV}
    SECOND_DISK_DEV=unused
    SECOND_DISK_PDEV=unused
elif [ "${OPT_BOOT_FROM}" = "eusb" -a -z "${OPT_EDISK_DEV}" ] ; then
    ERROR3="Error, The device name for the eUSB drive was not specified."
    ERROR_FOUND=error
elif [ "${OPT_BOOT_FROM}" = "eusb" -a ! -z "${OPT_EDISK_DEV}" ] ; then
    # The eUSB drive is the boot drive (boot & OS)
    # The root drive is the data drive (nkn and log)
    USING_EUSB=using-eusb
    FIRST_DISK_DEV=${OPT_EDISK_DEV}
    FIRST_DISK_PDEV=${OPT_EDISK_PDEV}
    Create_Disk_Devs ${FIRST_DISK_PDEV}
    SECOND_DISK_DEV=${OPT_RDISK_DEV}
    SECOND_DISK_PDEV=${OPT_RDISK_PDEV}
    Create_Disk_Devs ${SECOND_DISK_PDEV}
    echo "Using ${FIRST_DISK_DEV} as Boot drive (eUSB)"
    echo "Using ${SECOND_DISK_DEV} as Data drive."
elif [ "${OPT_BOOT_FROM}" = "mirror" -a -z "${OPT_HDD2_DEV}" ] ; then
    ERROR3="Error, The device name for the second mirror drive was not specified."
    ERROR_FOUND=error
elif [ "${OPT_BOOT_FROM}" = "root" ] ; then
    # Root drive is the combined boot+OS+data drive.
    FIRST_DISK_DEV=${OPT_RDISK_DEV}
    FIRST_DISK_PDEV=${OPT_RDISK_PDEV}
    Create_Disk_Devs ${FIRST_DISK_PDEV}
    SECOND_DISK_DEV=unused
    SECOND_DISK_PDEV=unused
    echo "Using ${FIRST_DISK_DEV} as Boot+Data drive."
elif [ "${OPT_BOOT_FROM}" = "mirror" ] ; then
    # Root drive is the combined boot+OS+data drive.
    FIRST_DISK_DEV=/dev/md
    FIRST_DISK_PDEV=${FIRST_DISK_DEV}
    SECOND_DISK_DEV=unused
    SECOND_DISK_PDEV=unused
    # NOTE-- 
    # A writeimage hook in customer_rootflop.sh reads /tmp/raid_disk_info.txt
    # and executes /sbin/make_raid.sh to create the RAID after the
    # partitions are created on the real disks.  The make_raid.sh script
    # uses the setting in this /tmp/raid_disk_info.txt file.
    echo "Using ${OPT_RDISK_DEV} + ${OPT_HDD2_DEV} for Mirror Boot+Data drive"
    Create_Disk_Devs ${OPT_RDISK_PDEV}
    Create_Disk_Devs ${OPT_HDD2_PDEV}
    echo RAID_DEV=${FIRST_DISK_DEV} >> /tmp/raid_disk_info.txt
    echo D1_DEV=${OPT_RDISK_DEV}    >> /tmp/raid_disk_info.txt
    echo D1_PDEV=${OPT_RDISK_PDEV}  >> /tmp/raid_disk_info.txt
    echo D2_DEV=${OPT_HDD2_DEV}     >> /tmp/raid_disk_info.txt
    echo D2_PDEV=${OPT_HDD2_PDEV}   >> /tmp/raid_disk_info.txt
else
    # Something is wrong.  It should not be able to get here.
    ERROR3="Error, Invalid combination of parameters."
    ERROR_FOUND=error
fi
if [ "${OPT_BOOT_FROM}" != "eusb" -a -f /tmp/unused-eusb-root-dev.txt ] ; then
  E_DEV=`cat /tmp/unused-eusb-root-dev.txt`
  Create_Disk_Devs ${E_DEV}
  # Make sure labels on eusb will not conflict with MFC.
  for i in 1 2 3 4 5 6 7 8 9 10 11 12
  do
    E_DEV_PART=${E_DEV}${i}
    [ ! -b ${E_DEV_PART} ] && continue
    ONE_E_LABEL=`e2label ${E_DEV_PART} 2>/dev/null`
    [ -z "${ONE_E_LABEL}" ] && continue
    case ${ONE_E_LABEL} in
    BOOTMGR|BOOT_1|BOOT_2|ROOT_1|ROOT_2|CONFIG|VAR|COREDUMP|NKN|LOG)
      echo Cleanup eUSB label conflict ${ONE_E_LABEL}
      e2label ${E_DEV_PART} Z_${ONE_E_LABEL} 2> /dev/null
      ;;
    esac
    case ${ONE_E_LABEL} in
    BOOTMGR)
      echo Zero the bootmgr partition on eUSB
      SIZE_K=`sfdisk -q -s ${E_DEV_PART}`
      dd if=/dev/zero of=${E_DEV_PART} bs=1024 count=${SIZE_K}
    esac
  done
  echo Zero the boot sector on eUSB device: ${E_DEV}
  # Zero the boot sector to make sure it is not bootable.
  dd if=/dev/zero of=${E_DEV} bs=512 count=1
fi
if [ "${OPT_BOOT_FROM}" != "mirror" -a ! -z "${HDD2_DEV}" ] ; then
  if [ "${HDD2_DEV}" != "na" ] ; then
    # If the second HDD was used for a mirror, wipe it so it
    # does not cause confusion.
    Create_Disk_Devs ${OPT_HDD2_PDEV}
    THIS_DEV_PART=${HDD2_PDEV}1
    if [ -b ${THIS_DEV_PART} ] ; then
      THIS_LABEL=`e2label ${THIS_DEV_PART} 2>/dev/null`
      if [ "_${THIS_LABEL}" = "_BOOTMGR" ] ; then
        dd if=/dev/zero of=${HDD2_DEV} bs=1G count=1
      fi
    fi
  fi
fi


########################################################################
# Eth options
########################################################################
if [ ! -z ${ETH_SET_CMDLINE} ] ; then
   if [ -f ${MY_DIR}/eth-setup ] ; then
     ${MY_DIR}/eth-setup --dryrun ${ETH_SET_CMDLINE} > /dev/null
     RV=${?}
   elif [ -f /sbin/eth-setup ] ; then
     /sbin/eth-setup --dryrun ${ETH_SET_CMDLINE} > /dev/null
     RV=${?}
   else
      # Don't bother trying to validate eth-setup parameters.
      RV=0
   fi
   if [ ${RV} -ne 0 ] ; then
       ERROR5="eth-setup parameter error: `eth-setup --dryrun ${ETH_SET_CMDLINE}`"
       ERROR_FOUND=error
   fi
fi

if [ "${ERROR_FOUND}" = "error" ] ; then
    [ ! -z "${ERROR1}" ] && Fail_Print "${ERROR1}"
    [ ! -z "${ERROR2}" ] && Fail_Print "${ERROR2}"
    [ ! -z "${ERROR3}" ] && Fail_Print "${ERROR3}"
    [ ! -z "${ERROR4}" ] && Fail_Print "${ERROR4}"
    [ ! -z "${ERROR5}" ] && Fail_Print "${ERROR5}"
    Usage
    exit 2
fi

########################################################################
########################################################################

if [ "_${EULA_ANS}" != "_accepted-eula" ] ; then
    # First use cat to output the EULA agreement text.
    # Then loop, checking for valid user input.
    cat ${EULA_FILE}
    while true
    do
        echo -n Do you accept and agree to this license'? (yes,no,again) '
        read EULA_ANS
        case "_${EULA_ANS}" in
        _yes)
          echo accepted-eula > /tmp/eula_response.txt
          break ;;
        _no)    exit 9 ;;
        _again) ;;
        *)      continue ;;
       esac
       more ${EULA_FILE}
    done
fi
rm -f ${MFG_LOG_FILE}
rm -f /tmp/mke2fs.*

if [ -z ${HOST_ID} ] ; then
  S_SN=`dmidecode -s system-serial-number`
  SMFG=`dmidecode -s system-manufacturer`
  UUID=`dmidecode -s system-uuid`
  [ -z "${S_SN}" ] && S_SN="${UUID}"
  [ "${S_SN}" = "empty" ] && S_SN="${UUID}"
  # Some systems, such as Supermicro, have system-serial-numbers
  # that are not unique.  So only use it for the host-id for
  # systems that we know use unique system serial numbers.
  case ${SMFG} in
  Juniper\ *|HP|Dell\ *|Sun\ Microsystems*) HOST_ID="${S_SN}" ;;
  *) HOST_ID="${UUID}" ;;
  esac
fi

################################################################
# Create overrides from the special manufacturing options:
#
#  OPT_MAX_FS
#
#  OPT_BUF_ISIZE
#  OPT_BUF_GW
#  OPT_BUF_MAX
#
#  OPT_CACHE_ISIZE
#  OPT_CACHE_GW
#  OPT_CACHE_MAX
#  OPT_CACHEFS_PERCENT
#
#  OPT_LOG_ISIZE
#  OPT_LOG_GW
#  OPT_LOG_MAX
#
#  OPT_COREDUMP_ISIZE
#  OPT_COREDUMP_GW
#  OPT_COREDUMP_MAX
#
#  OPT_ROOT_ISIZE
#  OPT_ROOT_GW
#  OPT_ROOT_MAX
#
#  OPT_CONFIG_ISIZE
#  OPT_CONFIG_GW
#  OPT_CONFIG_MAX
#
#  OPT_VAR_ISIZE
#  OPT_VAR_GW
#  OPT_VAR_MAX
#
################################################################

Create_Part_Override()
{
  OVERRIDE_FILE=/config/nkn/partition-override.dot
  CRF=/etc/customer_rootflop.sh
  [ ! -d `dirname ${OVERRIDE_FILE}` ] && mkdir -p `dirname ${OVERRIDE_FILE}`
  rm -f ${OVERRIDE_FILE}
  [ -z "${OPT_MAX_FS}${OPT_BUF_ISIZE}${OPT_CACHE_ISIZE}${OPT_LOG_ISIZE}${OPT_COREDUMP_ISIZE}${OPT_ROOT_ISIZE}${OPT_CONFIG_ISIZE}${OPT_VAR_ISIZE}" ] && return

  # Make a list of all the layout names.
  LAYOUT_LIST=`grep MODEL_ ${CRF}  \
    | grep _LAYOUT= | cut -f2 -d= | sed 's/"//g' | sed "s/\'//g" `

  # Get coredump partition and disk size settings from customer_rootflop.sh
  # using the Ram_size_calc() and Coredump_size_calc().
  . ${CRF}
  Ram_size_calc
  Coredump_size_calc
  # The following variable that we need is set in Coredump_size_calc():
  #    COREDUMP_SIZE
  # The COREDUMP_SIZE variable is used in the IL_LO_*_PART_COREDUMP_SIZE
  # coredump partition size setting.
  # This needs to be set for code later in this function with the comment
  #  "# Handle the case where the value is a variable."
  # so the eval command sets S with the proper value.

  OPT_NKN_ISIZE=${OPT_BUF_ISIZE}
  OPT_NKN_GW=${OPT_BUF_GW}
  OPT_NKN_MAX=${OPT_BUF_MAX}
  OPT_DMFS_ISIZE=
  OPT_DMFS_GW=
  OPT_DMFS_MAX=
  OPT_DMRAW_ISIZE=
  OPT_DMRAW_GW=
  OPT_DMRAW_MAX=
  # When OPT_CACHEFS_PERCENT is set (by Parse_Manuf_Opt) then
  #  OPT_CACHE_ISIZE is set to the value set by the cache-part=N override.
  if [ ! -z "${OPT_CACHEFS_PERCENT}" ] ; then
    OPT_DMFS_ISIZE=$(( ${OPT_CACHE_ISIZE} / ${OPT_CACHEFS_PERCENT} ))
    [ ${OPT_DMFS_ISIZE} -eq 0 ] && OPT_DMFS_ISIZE=10
    OPT_DMRAW_ISIZE=$(( ${OPT_CACHE_ISIZE} - ${OPT_DMFS_ISIZE} ))

    if [ ! -z "${OPT_CACHE_GW}" ] ; then
      OPT_DMFS_GW=$(( ${OPT_CACHE_GW} / ${OPT_CACHEFS_PERCENT} ))
      [ ${DMFS_GW} -eq 0 ] && OPT_DMFS_GW=1
      OPT_DMRAW_GW=$(( ${OPT_CACHE_GW} - ${OPT_DMFS_GW} ))
    fi
    if [ ! -z "${OPT_CACHE_MAX}" ] ; then
      OPT_DMFS_MAX=$(( ${OPT_CACHE_MAX} / ${OPT_CACHEFS_PERCENT} ))
      if [ ${OPT_DMFS_MAX} -le ${OPT_DMFS_ISIZE} ] ; then
        OPT_DMFS_GW=
        OPT_DMFS_MAX=
      fi
      if [ -z "${OPT_DMFS_MAX}" ] ; then
        OPT_DMRAW_MAX=${OPT_CACHE_MAX}
      else
        OPT_DMRAW_MAX=$(( ${OPT_CACHE_MAX} - ${OPT_DMFS_MAX} ))
      fi
      if [ ${OPT_DMRAW_MAX} -le ${OPT_DMFS_ISIZE} ] ; then
        OPT_DMRAW_GW=
        OPT_DMRAW_MAX=
      fi
    fi
  fi

  for LN in ${LAYOUT_LIST}
  do
    PART_NAMES=`grep IL_LO_${LN}_PARTS= ${CRF} | head -1 | cut -f2 -d= | sed 's/"//g' | sed "s/\'//g"`
    Log ${LN}:${PART_NAMES}
    for PN in ${PART_NAMES}
    do
      # When overrides, make sure not bigger than max_fs.
      eval 'O_SIZE=${OPT_'${PN}'_ISIZE}'
      eval 'O_GW=${OPT_'${PN}'_GW}'
      eval 'O_MAX=${OPT_'${PN}'_MAX}'
      if [ ! -z "${OPT_MAX_FS}" ] ; then
        if [ ! -z "${O_SIZE}" ] ; then
          if [ ${O_SIZE} -gt ${OPT_MAX_FS} ] ; then
            O_SIZE=${OPT_MAX_FS}
          fi
        fi
        if [ ! -z "${O_MAX}" ] ; then
          if [ ${O_MAX} -gt ${OPT_MAX_FS} ] ; then
            O_MAX=${OPT_MAX_FS}
          fi
        fi
      fi #
      [ "_${O_SIZE}" = "_0" ] && O_SIZE=
      [ "_${O_GW}"   = "_0" ] && O_GW=
      [ "_${O_MAX}"  = "_0" ] && O_MAX=
      S=`grep IL_LO_${LN}_PART_${PN}_SIZE= ${CRF} | head -1 | cut -f2 -d= | sed 's/"//g' | sed "s/\'//g"`
      W=`grep IL_LO_${LN}_PART_${PN}_GROWTHWEIGHT= ${CRF} | head -1 | cut -f2 -d= | sed 's/"//g' | sed "s/\'//g"`
      C=`grep IL_LO_${LN}_PART_${PN}_GROWTHCAP= ${CRF} | head -1 | cut -f2 -d= | sed 's/"//g' | sed "s/\'//g"`
      if [ ! -z "${S}" ] ; then
        # Handle the case where the value is a variable.
        echo "${S}" | grep -q '^\$'
        if [ ${?} -eq 0 ] ; then
          Log "${LN}_PART_${PN} size is set with a variable ${S}"
          eval S=${S}
        fi
      fi
      if [ ! -z "${OPT_MAX_FS}" -a ! -z "${S}" -a -z "${O_SIZE}" ] ; then
        [ ${S} -gt ${OPT_MAX_FS} ] && \
          O_SIZE=${OPT_MAX_FS}
      fi #
      if [ ! -z "${OPT_MAX_FS}" -a ! -z "${C}" -a -z "${O_MAX}" ] ; then
        [ ${C} -gt ${OPT_MAX_FS} ] && \
          O_MAX=${OPT_MAX_FS}
      fi #
      if [ ! -z "${O_SIZE}" ] ; then
        Log "Override IL_LO_${LN}_PART_${PN}_SIZE=${O_SIZE} (was ${S})"
        echo IL_LO_${LN}_PART_${PN}_SIZE=${O_SIZE} >> ${OVERRIDE_FILE}
        eval SIZE_${PN}=${O_SIZE}
      else
        Log Keep IL_LO_${LN}_PART_${PN}_SIZE=${S}
        eval SIZE_${PN}=${S}
      fi #
      if [ ! -z "${O_GW}"   ] ; then
        Log "Override IL_LO_${LN}_PART_${PN}_GROWTHWEIGHT=${O_GW} (was ${W})"
        echo IL_LO_${LN}_PART_${PN}_GROWTHWEIGHT=${O_GW} >> ${OVERRIDE_FILE}
      fi #
      if [ ! -z "${O_MAX}"  ] ; then
        Log "Override IL_LO_${LN}_PART_${PN}_GROWTHCAP=${O_MAX} (was ${C})"
        echo IL_LO_${LN}_PART_${PN}_GROWTHCAP=${O_MAX} >> ${OVERRIDE_FILE}
      fi #
    done # PN in ${PART_NAMES}

    # Now calculate the minimum disk sizes.
    DISK1_TOTAL=0
    DISK2_TOTAL=0
    for PN in ${PART_NAMES}
    do
      D=`grep IL_LO_${LN}_PART_${PN}_TARGET= ${CRF} | head -1 | cut -f2 -d= | sed 's/"//g' | sed "s/\'//g"`
      eval 'S=${SIZE_'${PN}'}'
      case ${D} in
      DISK1) DISK1_TOTAL=$(( DISK1_TOTAL + S )) ;;
      DISK2) DISK2_TOTAL=$(( DISK2_TOTAL + S )) ;;
      esac
    done # PN in ${PART_NAMES}
    Log DISK1_TOTAL=${DISK1_TOTAL}
    Log DISK2_TOTAL=${DISK2_TOTAL}
    echo IL_LO_${LN}_TARGET_DISK1_MINSIZE=${DISK1_TOTAL} >> ${OVERRIDE_FILE}
    if [ ${DISK2_TOTAL} -ne 0 ] ; then
      echo IL_LO_${LN}_TARGET_DISK2_MINSIZE=${DISK2_TOTAL} >> ${OVERRIDE_FILE}
    fi #
  done # LN in ${LAYOUT_LIST}

  # When DMRAW size is set to zero, remove DMRAW and DMFS from the
  # partition lists.
  ########################################################################
  ### NOTE: It would be better for this script get a copy the existing
  ### IL_LO_*_PARTS= and IL_LOG_LOCS= lines that have DMRAW, and edit out
  ### the DMRAW and DMFS items and put that in the override file.
  ### The way it is now depends on this script being kept up-to-date
  ### with any changes in customer_rootflop.sh
  ###
  ### These model names from customer_rootflop.sh
  ###   CFG_MODEL_CHOICES="normal mirror cache vxa1 vxa2 demo8g2 demo32g1 cloudvm cloudrc"
  ### Layout names for these model names:
  ###   MODEL_cache_LAYOUT="DEFAULT"      has cache
  ###   MODEL_normal_LAYOUT="BIGLOGNC"    no cache
  ###   MODEL_mirror_LAYOUT="MIRROR"      no cache
  ###   MODEL_vxa1_LAYOUT="FLASHROOT"     has cache
  ###   MODEL_vxa2_LAYOUT="FLASHNCACHE"   no cache
  ###   MODEL_cloudvm_LAYOUT="CLOUDVM"    no cache
  ###   MODEL_cloudrc_LAYOUT="CLOUDRC"    has cache
  ###   MODEL_demo8g2_LAYOUT="8GNCACHE"   no cache
  ###   MODEL_demo32g1_LAYOUT="32G"       has cache
  ########################################################################
  if [ ! -z "${OPT_DMRAW_ISIZE}" ] ; then
    if [ ${OPT_DMRAW_ISIZE} -eq 0 ] ; then
      for LN in ${LAYOUT_LIST}
      do
        case ${LN} in
        BIGLOGNC|FLASHNCACHE|3GNCACHE)
          # The no-cache layouts do not have an DM partitions on the root drive.
          continue
          ;;
        DEFAULT|32G|3GCACHE|CLOUDVM)
          echo IL_LO_${LN}_PARTS='"BOOTMGR BOOT1 BOOT2 EXT ROOT1 ROOT2 CONFIG VAR COREDUMP NKN LOG"' \
            >> ${OVERRIDE_FILE}
          echo IL_LO_${LN}_LOCS='"BOOTMGR_1 BOOT_1 BOOT_2 ROOT_1 ROOT_2 CONFIG_1 VAR_1 COREDUMP_1 NKN_1 LOG_1"' \
            >> ${OVERRIDE_FILE}
          # Make the log partition take the rest of the disk.
          echo IL_LO_${LN}_PART_LOG_GROWTHCAP= \
            >> ${OVERRIDE_FILE}
          ;;
        FLASHROOT)
          # FLASHROOT has a different layout than the others.  The large partitions are on the second disk.
          echo IL_LO_FLASHROOT_PARTS='"BOOTMGR BOOT1 BOOT2 EXT ROOT1 ROOT2 CONFIG VAR COREDUMP NKN LOG"' \
            >> ${OVERRIDE_FILE}
          echo IL_LO_FLASHROOT_LOCS='"BOOTMGR_1 BOOT_1 BOOT_2 ROOT_1 ROOT_2 CONFIG_1 VAR_1 COREDUMP_1 NKN_1 LOG_1" ' \
            >> ${OVERRIDE_FILE}
          # Make the log partition take the rest of the disk.
          echo IL_LO_FLASHROOT_PART_LOG_GROWTHCAP= \
            >> ${OVERRIDE_FILE}
          ;;
        *)
          Fail_Print Warning, UNKNOWN MODEL: ${LN}, cannot install with no cache on root drive.
          sleep 10
          exit 2
          ;;
        esac
      done
    fi
  fi
}

Clear_Raid()
{
  # If the disks were previously raided, then we will not be able to
  # use sfdisk (get error "BLKRRPART: Device or resource busy")
  # unless we stop the /dev/md* devices
  [ ! -e /sbin/mdadm ] && ln -s /sbin/mdadm.static /sbin/mdadm

  CR_LOG=/tmp/clear_raid.log
  for PNUM in 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
  do
    R=/dev/md${PNUM}
    [ ! -b ${R} ] && mknod ${R} b 9 ${PNUM}
    echo  \
    mdadm --query --detail ${R} >> ${CR_LOG} 2>&1
    mdadm --query --detail ${R} >> ${CR_LOG} 2>&1
    mdadm --query --detail ${R} > /tmp/mdadm.out.txt 2> /dev/null
    RL=`cat /tmp/mdadm.out.txt | awk '/Raid Level :/ {print $4}'`
    [ "${RL}" != "raid1" ] && continue
    echo \
    mdadm ${R} --remove detached >> ${CR_LOG} 2>&1
    mdadm ${R} --remove detached >> ${CR_LOG} 2>&1
    for THIS_DEV in `cat /tmp/mdadm.out.txt | awk '/\/dev\/[^(md)]/ {print $7}'`
    do
      [ -z "${THIS_DEV}" ] && break
      [ ! -b "${THIS_DEV}" ] && continue
      echo \
      mdadm ${R} --fail ${THIS_DEV} --remove ${THIS_DEV} >> ${CR_LOG} 2>&1
      mdadm ${R} --fail ${THIS_DEV} --remove ${THIS_DEV} >> ${CR_LOG} 2>&1
    done
    echo Stop raid ${R} >> ${CR_LOG}
    echo \
    mdadm --stop ${R} >> ${CR_LOG} 2>&1
    mdadm --stop ${R} >> ${CR_LOG} 2>&1
    echo \
    mdadm --remove ${R} >> ${CR_LOG} 2>&1
    mdadm --remove ${R} >> ${CR_LOG} 2>&1
    for THIS_DEV in `cat /tmp/mdadm.out.txt | awk '/\/dev\/[^(md)]/ {print $7}'`
    do
      [ -z "${THIS_DEV}" ] && break
      [ ! -b "${THIS_DEV}" ] && continue
      echo Clear ${THIS_DEV} >> ${CR_LOG}
      echo \
      mdadm --zero-superblock ${THIS_DEV} >> ${CR_LOG} 2>&1
      mdadm --zero-superblock ${THIS_DEV} >> ${CR_LOG} 2>&1
      # Erase the first 100M of the partition
      echo \
      dd if=/dev/zero of=${THIS_DEV} bs=1M count=100 >> ${CR_LOG} 2>&1
      dd if=/dev/zero of=${THIS_DEV} bs=1M count=100 >> ${CR_LOG} 2>&1
      SIZE_K=`sfdisk -q -s ${THIS_DEV}`
      echo Size of ${THIS_DEV} is ${SIZE_K} >> ${CR_LOG}
      # Erase the last 100M of the partition
      # Use awk because busybox expr does not work above 2^32.
      OFFSET_M=`echo ${SIZE_K} | awk '{f= $1 / 1024 - 100; if (f > 0) {print int(f)} else {print 0}}'`
      echo \
      dd if=/dev/zero of=${THIS_DEV} bs=1M seek=${OFFSET_M} count=100 >> ${CR_LOG} 2>&1
      dd if=/dev/zero of=${THIS_DEV} bs=1M seek=${OFFSET_M} count=100 >> ${CR_LOG} 2>&1
    done
  done
}

Diagnose_Manufacture_Failure()
{
  # INPUTS:  These variables must be set:
  # MFG_LOG_FILE
  # FIRST_DISK_DEV
  # USING_EUSB
  cat ${MFG_LOG_FILE} \
    | grep "^== Creating " \
    | grep " filesystem on /dev/" \
    | sed "s# on /#:/#" \
    | sed "s# for #:#" \
    | cut -f2- -d: \
    > /tmp/fs-created.txt
      # Example output on VXA
      #/dev/sdq2:BOOT1
      #/dev/sdq3:BOOT2
      #/dev/sdq1:BOOTMGR
      #/dev/sdq7:CONFIG
      #/dev/sdq5:ROOT1
      #/dev/sdq6:ROOT2
      #/dev/sdq8:VAR
      #/dev/sda2:COREDUMP
      #/dev/sda5:LOG
      #/dev/sda3:NKN
  PREV=none
  FAILED=
  for i in BOOT1 BOOT2 BOOTMGR CONFIG COREDUMP LOG NKN ROOT1 ROOT2 VAR
  do
    grep -q :${i} /tmp/fs-created.txt
    if [ ${?} -ne 0 ] ;  then
      FAILED=`grep ${PREV} /tmp/fs-created.txt`
    fi
    PREV=${i}
  done  
  if [ ! -z "${FAILED}" ] ; then
    Fail_Print ERROR: !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Fail_Print ERROR: Failed creating ${FAILED}
    echo ERROR: Failed creating ${FAILED} > /tmp/fail-creating.txt
    echo ${FAILED} | grep -q ${FIRST_DISK_DEV}*:
    RD=${?}
    if [ "${USING_EUSB}" = "using-eusb" ] ; then
      if [ ${RD} -eq 0 ] ; then
        Fail_Print ERROR: eUSB drive failure
      else
        Fail_Print ERROR: Root hard drive failure
      fi
    else
      Fail_Print ERROR: Root hard drive failure
    fi
    echo
    return 1
  fi
  cat ${MFG_LOG_FILE} \
    | grep "^== Extracting for location " \
    | sed "s# location #:#" \
    | sed "s# onto #:#" \
    | cut -f2- -d: \
    > /tmp/fs-loaded.txt
      # Example output on VXA which failed on sdq6
      #BOOTMGR_1:/dev/sdq1
      #BOOT_1:/dev/sdq2
      #BOOT_2:/dev/sdq3
      #ROOT_1:/dev/sdq5
      #ROOT_2:/dev/sdq6
  FAIL_MOUNT=`grep "Could not mount partition" ${MFG_LOG_FILE}`
  if [ ! -z "${FAIL_MOUNT}" ] ; then
    DEV=`echo ${FAIL_MOUNT} | cut -f2- -d/ | cut -f1 -d' '`
    FAILED=`cat /tmp/fs-loaded.txt | grep ${DEV}'$'`
    Fail_Print ERROR: !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    Fail_Print ERROR: Failed mounting ${FAILED}
    echo ERROR: Failed mounting ${FAILED} > /tmp/fail-mounting.txt
    echo ${FAILED} | grep -q ${FIRST_DISK_DEV}*:
    RD=${?}
    if [ "${USING_EUSB}" = "using-eusb" ] ; then
      if [ ${RD} -eq 0 ] ; then
        Fail_Print ERROR: eUSB drive failure
      else
        Fail_Print ERROR: Root hard drive failure
      fi
    else
      Fail_Print ERROR: Root hard drive failure
    fi
    echo
    return 1
  fi
  return 0
}

MFG()
{
  if [ -f /tmp/img.filename ] ; then
    # Install from local filesystem
    IMG_TYPE="-f"
    IMG_NAME=`cat /tmp/img.filename`
  elif [ -f /tmp/img.url ] ; then
    IMG_TYPE="-u"
    IMG_NAME=`cat /tmp/img.url`
  else
     # /tmp/img.filename is created by overlay-manuf.sh
     # /tmp/img.url is created by pxe-install
     Fail_Print Error, expected file /tmp/img.filename or /tmp/img.url
     sleep 10
     exit 2
  fi
  if [ -z ${HOST_ID} ] ; then
    H_OPT=
  else
    H_OPT="-h ${HOST_ID}"
  fi
  D_OPT1="-d ${FIRST_DISK_PDEV}"
  D_OPT2=
  [ "${SECOND_DISK_PDEV}" != "unused" ] && D_OPT2="-d ${SECOND_DISK_PDEV}"

  Log_Print == Installation started at `date +%Y%m%d-%H%M%S`
  rm -f /tmp/manufacture.rv
  if [ "${DRY_RUN}" = "dry_run" ] ; then
    echo \
    manufacture.sh -F ${MFG_LOG_FILE} -v -a -m ${USE_MODEL} ${D_OPT1} ${D_OPT2} ${H_OPT} ${IMG_TYPE} "${IMG_NAME}"
  else
    echo \
    manufacture.sh -F ${MFG_LOG_FILE} -v -a -m ${USE_MODEL} ${D_OPT1} ${D_OPT2} ${H_OPT} ${IMG_TYPE} "${IMG_NAME}" >> ${LOGF}
    manufacture.sh -F ${MFG_LOG_FILE} -v -a -m ${USE_MODEL} ${D_OPT1} ${D_OPT2} ${H_OPT} ${IMG_TYPE} "${IMG_NAME}"
      > /tmp/manuf.out 2>&1 &
    M_PID=${!}
    [ ! -f ${MFG_LOG_FILE} ] && sleep 1
    [ ! -f ${MFG_LOG_FILE} ] && sleep 1
    [ ! -f ${MFG_LOG_FILE} ] && sleep 1
    [ ! -f ${MFG_LOG_FILE} ] && sleep 1
    [ ! -f ${MFG_LOG_FILE} ] && sleep 1
    tail -f ${MFG_LOG_FILE} | tee -a ${LOGF} \
      | grep -v "Manufacture done" \
      | grep -v "Ending manufacture" \
      | grep -v " msdos " \
      | grep -v " DOS " \
      | grep -v " no primary " \
      | grep -v "/dev/zero" \
      | grep -v " unrecognized partition " \
      | grep -v " fdisk"\
      &
    T_PID=${!}
    wait ${M_PID}
    if [ ! -f /tmp/imgverify.out ] ; then
      echo 2 > /tmp/manufacture.rv
    else  
      grep "Image location 1 verified successfully" /tmp/imgverify.out > /dev/null
      echo ${?} > /tmp/manufacture.rv
    fi
  fi
}
Create_Part_Override
Clear_Raid
MFG 2> /dev/null

if [ "${DRY_RUN}" = "dry_run" ] ; then
  exit 0
fi
RV=`cat /tmp/manufacture.rv`
if [ ${RV} -ne 0 ] ; then
    Diagnose_Manufacture_Failure
    Fail_Print Installation failed.
    # Exiting with 10 makes it go to a shell prompt after root.profile
    # prints a message before that about using exit and reboot.
    sleep 10
    exit 10
fi

LOG_DEV=`grep Creating ${MFG_LOG_FILE}    | grep "for LOG$"    | cut -f6 -d' ' | head -1`
CONFIG_DEV=`grep Creating ${MFG_LOG_FILE} | grep "for CONFIG$" | cut -f6 -d' ' | head -1`
NKN_DEV=`grep Creating ${MFG_LOG_FILE}    | grep "for NKN$"    | cut -f6 -d' ' | head -1`
ROOT1_DEV=`grep Creating ${MFG_LOG_FILE}  | grep "for ROOT1$"  | cut -f6 -d' ' | head -1`
ROOT2_DEV=`grep Creating ${MFG_LOG_FILE}  | grep "for ROOT2$"  | cut -f6 -d' ' | head -1`

MISSING=no
if [ -z "${LOG_DEV}" ]    ; then MISSING=yes; Fail_Print Error, no /log filesystem. ; fi
if [ -z "${CONFIG_DEV}" ] ; then MISSING=yes; Fail_Print Error, no /config filesystem. ; fi
if [ -z "${NKN_DEV}" ]    ; then MISSING=yes; Fail_Print Error, no /nkn filesystem. ; fi
if [ -z "${ROOT1_DEV}" ]  ; then MISSING=yes; Fail_Print Error, no 1/ filesystem. ; fi
if [ -z "${ROOT2_DEV}" ]  ; then MISSING=yes; Fail_Print Error, no 2/ filesystem. ; fi
if [ "${MISSING}" = "yes" ] ; then
    Diagnose_Manufacture_Failure
    Fail_Print Installation failed.
    exit 3
fi
LOG_MNT=/tmp/mnt_image/DISK1/LOG
CONFIG_MNT=/tmp/mnt_image/DISK1/CONFIG
NKN_MNT=/tmp/mnt_image/NKN
ROOT1_MNT=/tmp/mnt_image/DISK1/ROOT1
ROOT2_MNT=/tmp/mnt_image/DISK1/ROOT2
echo LOG_DEV=${LOG_DEV}        > /tmp/mfg.env
echo LOG_MNT=${LOG_MNT}       >> /tmp/mfg.env
echo CONFIG_DEV=${CONFIG_DEV} >> /tmp/mfg.env
echo NKN_DEV=${NKN_DEV}       >> /tmp/mfg.env
echo CONFIG_MNT=${CONFIG_MNT} >> /tmp/mfg.env
echo ROOT1_DEV=${ROOT1_DEV}   >> /tmp/mfg.env
echo ROOT1_MNT=${ROOT1_MNT}   >> /tmp/mfg.env
echo ROOT2_DEV=${ROOT2_DEV}   >> /tmp/mfg.env
echo ROOT2_MNT=${ROOT2_MNT}   >> /tmp/mfg.env
[ ! -d ${LOG_MNT}    ] && mkdir -p ${LOG_MNT}
[ ! -d ${CONFIG_MNT} ] && mkdir -p ${CONFIG_MNT}
[ ! -d ${NKN_MNT}    ] && mkdir -p ${NKN_MNT}
[ ! -d ${ROOT1_MNT}  ] && mkdir -p ${ROOT1_MNT}
[ ! -d ${ROOT2_MNT}  ] && mkdir -p ${ROOT2_MNT}
mount ${LOG_DEV} ${LOG_MNT}
mount ${CONFIG_DEV} ${CONFIG_MNT}
mount ${NKN_DEV} ${NKN_MNT}
mount ${ROOT1_DEV} ${ROOT1_MNT}
mount ${ROOT2_DEV} ${ROOT2_MNT}

CONFIG_NKN=${CONFIG_MNT}/nkn
mkdir ${CONFIG_NKN}
if [ ! -d ${CONFIG_NKN} ] ; then
    Fail_Print Cannot create ${CONFIG_NKN}
    Fail_Print Installation failed.
    exit 3
fi

# If a dmi-adapter image file was extracted from the mfc image file we need
# to copy it into the nkn filesystem.
# The writeimage graft function 'writeimage_graft_4()' runs the function
# Writeimage_g4 from the the file pre_img_instal.sh, which creates the tmpfs
# /tmp/dmi-adapter-extract/ and puts the dmi-adapter image file there.

FROM_DIR=/tmp/dmi-adapter-extract
TO_DIR=/${NKN_MNT}/dmi-adapter-zips
[ ! -d ${TO_DIR} ] && mkdir ${TO_DIR}
# There should not be any files  at the destination, but make sure anyway.
rm -f  ${TO_DIR}/*
[ -d ${FROM_DIR} ] && cp -a ${FROM_DIR}/* ${TO_DIR}/

# Determine the device names of the DM cache partitions.
USING_LAYOUT=`grep "^==== Using layout: " ${MFG_LOG_FILE} | head -1 | awk '{ print $4 }'`
PART_NUM_DMRAW=`grep IL_LO_${USING_LAYOUT}_PART_DMRAW_PART_NUM= /etc/customer_rootflop.sh | head -1 | cut -f2 -d=`
PART_NUM_DMFS=`grep IL_LO_${USING_LAYOUT}_PART_DMFS_PART_NUM= /etc/customer_rootflop.sh | head -1 | cut -f2 -d=`
DM_DISK_TARGET=none
if [ ! -z "${PART_NUM_DMFS}" -a ! -z "${PART_NUM_DMRAW}" ] ; then
  DM_DISK_TARGET=`grep IL_LO_${USING_LAYOUT}_PART_DMRAW_TARGET= /etc/customer_rootflop.sh | head -1 | cut -f2 -d=`
  case ${DM_DISK_TARGET} in
  DISK1)
    DMFS_DISK_DEV=${FIRST_DISK_DEV}${PART_NUM_DMFS}
    DMFS_DISK_PDEV=${FIRST_DISK_PDEV}${PART_NUM_DMFS}
    DMRAW_DISK_DEV=${FIRST_DISK_DEV}${PART_NUM_DMRAW}
    DMRAW_DISK_PDEV=${FIRST_DISK_PDEV}${PART_NUM_DMRAW}
    ;;
  DISK2)
    DMFS_DISK_DEV=${SECOND_DISK_DEV}${PART_NUM_DMFS}
    DMFS_DISK_PDEV=${SECOND_DISK_PDEV}${PART_NUM_DMFS}
    DMRAW_DISK_DEV=${SECOND_DISK_DEV}${PART_NUM_DMRAW}
    DMRAW_DISK_PDEV=${SECOND_DISK_PDEV}${PART_NUM_DMRAW}
    ;;
  *)
    DM_DISK_TARGET=none
    ;;
  esac
  if [ "${DM_DISK_TARGET}" != "none" ] ; then
    Log DMFS_DISK_PDEV=${DMFS_DISK_PDEV}
    Log DMRAW_DISK_PDEV=${DMRAW_DISK_PDEV}
    if [ ! -b ${DMFS_DISK_PDEV} ] ; then
      Log_Print ERROR, DMFS device ${DMFS_DISK_PDEV} does not exist!
      echo ERROR, DMFS device does not exist! ${DMFS_DISK_PDEV}
      DM_DISK_TARGET=none
    fi
    if [ ! -b ${DMRAW_DISK_PDEV} ] ; then
      Log_Print ERROR, DMFS device ${DMRAW_DISK_PDEV} does not exist!
      echo ERROR, DMFS device does not exist! ${DMRAW_DISK_PDEV}
      DM_DISK_TARGET=none
    fi
  fi
fi
if [ "${DM_DISK_TARGET}" != "none" ] ; then
  MNT=/tmp/mnt_dmfs
  if [ "${CACHE_OPT}" = "init-cache" ] ; then
    INIT_ROOT_DM=yes
  else
    # When the expected filesystem on DMFS exists, then do not create a new filesystem.
    INIT_ROOT_DM=no
    # Now check to see if it is there.
    umount ${MNT} > /dev/null 2> /dev/null
    rm -rf ${MNT}
    mkdir ${MNT}
    touch ${MNT}/it_did_not_get_mounted
    mount -t ext3 ${DMFS_DISK_PDEV} ${MNT} >> ${LOGF} 2>&1
    RV=$?
    ls -l ${MNT} >> ${LOGF} 2>&1
    if [ ! -d ${MNT}/lost+found ] ; then
      Log Failed to mount ${DMFS_DISK_PDEV}
      Log RV=${RV}
      Log_Print WARNING: No existing cache on the root drive to keep.
      INIT_ROOT_DM=yes
    fi
    umount ${DMFS_DISK_PDEV} > /dev/null 2> /dev/null
  fi
  if [ "${INIT_ROOT_DM}" = "yes" ] ; then
    Log_Print "Make filesystem on DMFS"
    Log "Start `date`"
    Log "mke2fs -O ^resize_inode -q -L DMFS -j ${DMFS_DISK_PDEV}"
    mke2fs -O ^resize_inode -q -L DMFS -j ${DMFS_DISK_PDEV}
    Log "# Done `date`"
    Log "Zero first part 4MB of DMRAW"
    Log "Start `date`"
    dd if=/dev/zero of=${DMRAW_DISK_PDEV} bs=512 count=8192 >> ${LOGF} 2>&1
    Log "# Done `date`"
  else
    Log Make sure ${DMFS_DISK_PDEV} has label DMFS
    e2label ${DMFS_DISK_PDEV} DMFS >> ${LOGF} 2>&1
  fi
fi

# Save the data for our scripts at boot time.
echo ${CACHE_OPT}      > ${CONFIG_NKN}/diskcache-init.opt
echo ${FIRST_DISK_DEV}  > ${CONFIG_NKN}/boot-disk.info
echo ${FIRST_DISK_PDEV} > ${CONFIG_NKN}/boot-pdisk.info
echo ${FIRST_DISK_DEV}  > ${CONFIG_NKN}/system-data-disk.info
echo ${FIRST_DISK_PDEV} > ${CONFIG_NKN}/system-data-pdisk.info
echo ${USING_LAYOUT}   > ${CONFIG_NKN}/layout-name.info
if [ "${DM_DISK_TARGET}" = "DISK1" ] ; then
  echo ${DMFS_DISK_PDEV}  > ${CONFIG_NKN}/root_cache_fs
  echo ${DMRAW_DISK_PDEV} > ${CONFIG_NKN}/root_cache_raw
fi
if [ "${DM_DISK_TARGET}" != "none" ] ; then
  echo ${DMFS_DISK_PDEV}  > ${CONFIG_NKN}/first_cache_fs
  echo ${DMRAW_DISK_PDEV} > ${CONFIG_NKN}/first_cache_raw
fi
if [ "${USING_EUSB}" = "using-eusb" ] ; then
  echo ${SECOND_DISK_DEV}  > ${CONFIG_NKN}/system-data-disk.info
  echo ${SECOND_DISK_PDEV} > ${CONFIG_NKN}/system-data-pdisk.info
  echo ${FIRST_DISK_DEV}  > ${CONFIG_NKN}/eusb-disk.info
  # Note: The script mvt-printout reads /tmp/eusb-disk.info
  echo ${FIRST_DISK_DEV}  > /tmp/eusb-disk.info
fi
if [ -f ${OVERRIDE_FILE} ] ; then
  cp ${OVERRIDE_FILE} ${CONFIG_NKN}/
fi

#echo FIRST_DISK_DEV=${FIRST_DISK_DEV}     >  /tmp/disk-devs.txt
#echo FIRST_DISK_PDEV=${FIRST_DISK_PDEV}   >> /tmp/disk-devs.txt
#echo SECOND_DISK_DEV=${SECOND_DISK_DEV}   >> /tmp/disk-devs.txt
#echo SECOND_DISK_PDEV=${SECOND_DISK_PDEV} >> /tmp/disk-devs.txt

if [ -f  /tmp/slot_to_dev.txt ] ; then
  SD_DEV=`cat ${CONFIG_NKN}/system-data-disk.info`
  D_SER_NUM=
  eval `cat /tmp/slot_to_dev.txt \
      | grep "D_DEVNAME=${SD_DEV};"`
  echo ${D_SER_NUM} > ${CONFIG_NKN}/system-data-serial.info
  cp ${CONFIG_NKN}/system-data-serial.info /tmp
fi

if [ ! -f ${ROOT1_MNT}/etc/build_version.txt ] ;then
  Fail_Print Error installing.  Installation incomplete.
  Fail_Print Exiting to the shell to allow debugging.
  # Exiting with 11 makes root.profile go to the shell prompt.
  exit 11
fi
cp ${ROOT1_MNT}/etc/build_version.txt /tmp
cp ${ROOT1_MNT}/etc/build_version.sh /tmp

MFGLOG_DIR=${LOG_MNT}/mfglog
mkdir -p ${MFGLOG_DIR}
if [ ! -d ${MFGLOG_DIR} ] ; then
    Fail_Print Cannot create ${MFGLOG_DIR}
    Fail_Print Installation failed.
    exit 3
fi

Log Installation done at `date +%Y%m%d-%H%M%S`
cmp -s ${ROOT1_MNT}/etc/build_version.sh /etc/build_version.sh
if [ ${?} -ne 0 ] ; then
  if [ ! -f /etc/build_version.sh-orig ] ; then
    mv /etc/build_version.sh /etc/build_version.sh-orig
    mv /etc/build_version.txt /etc/build_version.txt-orig
  fi
  rm -f /etc/build_version.sh
  rm -f /etc/build_version.txt
  cp ${ROOT1_MNT}/etc/build_version.sh /etc/
  cp ${ROOT1_MNT}/etc/build_version.txt /etc/
fi
. /etc/build_version.sh
echo "Version Installed: ${BUILD_PROD_RELEASE} ${BUILD_ID}"
echo "Build date ${BUILD_DATE}"

dmesg -c > /tmp/dmesg-after-mfc-install.txt
cp /tmp/*.* ${MFGLOG_DIR}
cp /etc/build_version.* ${MFGLOG_DIR}
cp /etc/customer_rootflop.sh ${MFGLOG_DIR}
cp /etc/layout_settings.sh ${MFGLOG_DIR}

#echo Saved to /log/mfglog/
#ls ${MFGLOG_DIR}

# Copy over some scripts that we might want to run by hand.
NKN_BIN=${ROOT1_MNT}/opt/nkn/bin
cp ${NKN_BIN}/ethflash /sbin
cp ${NKN_BIN}/eth-reorder.sh /sbin
cp ${NKN_BIN}/eth-device-from-http.sh /sbin

Download_Additional()
{
  WHAT=${1}
  FROM_FILE="${2}"
  FROM_URL_DIR="${3}"
  TO_DIR=${4}
  [ ! -d ${TO_DIR} ] && mkdir -p ${TO_DIR}
  case ${FROM_FILE} in
  http://*|https://*)
    FROM_URL=${FROM_FILE}
    ;;
  /*)
    FROM_URL=`echo ${FROM_URL_DIR} | cut -f1-3 -d/`/${FROM_FILE}
    ;;
  *)
    FROM_URL=${FROM_URL_DIR}/${FROM_FILE}
    ;;
  esac
  echo DOWNLOAD_URL=${FROM_URL} > ${TO_DIR}/download-this.txt
  THIS_FILE=`basename ${FROM_URL}`
  Log_Print Downloading ${THIS_FILE}
  Log_Print from `dirname ${FROM_URL}`
  echo wget -O ${TO_DIR}/${THIS_FILE} ${FROM_URL} > /tmp/wget-${WHAT}.log 2>&1
  wget -O ${TO_DIR}/${THIS_FILE} ${FROM_URL} 2>&1 | tee -a /tmp/wget-${WHAT}.log
  grep -q " error " /tmp/wget-${WHAT}.log
  RV=${?}
  if [ ${RV} -eq 0 -o ! -f ${TO_DIR}/${THIS_FILE} ] ; then
    Fail_Print Error: Failed to download ${THIS_FILE}
    Fail_Print Error: from `dirname ${FROM_URL}`
    exit 1
  fi
  echo PKG_FILE=${THIS_FILE} > ${TO_DIR}/info.txt
}

Copy_Additional()
{
  # Copy all files from /tmp/${1}/ to ${2}/
  THIS=${1}
  TO_DIR=${2}
  [ ! -d ${TO_DIR} ] && mkdir ${TO_DIR}
  # When copying from an actual DVD, this could take a while for large files.
  # Note that VXA installs are from what looks like a DVD but really is a
  # USB thumb drive, so that should be faster, but still may take a while.
  ERR=0
  for i in /tmp/${THIS}/*
  do
    Log cp ${i} ${TO_DIR}
    cp ${i} ${TO_DIR}
    RV=${?}
    if [ ${RV} -ne 0 ] ; then
      Fail_Print Error: Failed to copy ${i}
      Fail_Print Error: to ${TO_DIR}
      ERR=1
    fi
  done
  if [ -z "${3}" ] ; then
    if [ ${ERR} -ne 0 ] ; then
      Fail_Print Error: Failed to copy files to ${TO_DIR}
      exit 1
    fi
  else
    P_FILE=`basename ${3}`
    if [ ! -f ${TO_DIR}/${P_FILE} ] ; then
      Fail_Print Error: Failed to copy ${P_FILE}
      Fail_Print Error: to ${TO_DIR}
      exit 1
    fi
    if [ ${ERR} -ne 0 ] ; then
      Log_Print Aborting installation because of copy failure.
      exit 1
    fi
    echo PKG_FILE=${P_FILE} > ${TO_DIR}/info.txt
  fi
}

sync
umount ${LOG_DEV}
umount ${CONFIG_DEV}
umount ${NKN_DEV}
umount ${ROOT1_DEV}
umount ${ROOT2_DEV}
if [ ! -z ${ETH_SET_CMDLINE} ] ; then
   if [ -f ${MY_DIR}/eth-setup ] ; then
     ${MY_DIR}/eth-setup ${ETH_SET_CMDLINE}
   elif [ -f /sbin/eth-setup ] ; then
     /sbin/eth-setup ${ETH_SET_CMDLINE}
   else
     echo Warning, eth-setup command not found.
   fi
fi
Log_Print == Installation done at `date +%Y%m%d-%H%M%S`

# Run the post script
RV=0
bash ${XOPT} /sbin/post-install.sh
RV=${?}
if [ ${RV} -gt 0 -a ${RV} -lt 9 ] ; then
   Fail_Print Installation failure
   sleep 3
fi
exit ${RV}
